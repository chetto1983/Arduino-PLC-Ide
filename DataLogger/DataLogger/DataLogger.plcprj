<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<plcProject caseSensitive="false" extendedIdNames="false" useCustomWorkspace="true" debugMode="false" extcheck="true" SFCControl="false" strictPointerCheck="true" verboseWarningMode="false" iecTypeConversionRules="false" PNContactsOnEachNetwork="false" LocalVarsFBAccess="false" strictEnumsCheck="true" copyWarningThreshold="200" version="2.11" useLD2="true" useXPLCFiles="false" useFBMethods="false" customSortOfProjectTree="false" autoDerefPointers="false">
	<image>DataLogger.imgx</image>
	<commSettings>Modbus:247,1000,M6#COM:11,38400,N,8,1,H</commSettings>
	<sources>
		<main>
			<resources>
				<resource name="ArduinoOpta" processor="ARMThumb2_VFP2">
					<task name="Fast" interval="t#10000us" priority="0" type="cyclic" hidden="false" dynamic="false" descr="Fast task"/>
					<task name="Slow" interval="t#100000us" priority="1" type="cyclic" hidden="false" dynamic="false" descr="Slow task"/>
					<task name="Background" interval="t#500000us" priority="2" type="cyclic" hidden="false" dynamic="false" descr="Background task"/>
					<task name="Init" interval="t#0us" priority="3" type="single" hidden="false" dynamic="false" descr="Init task"/>
					<task name="MbBoot" interval="t#0us" priority="4" type="single" hidden="true" dynamic="false" descr="Modbus boot task"/>
					<task name="MbMPrm" interval="t#0us" priority="5" type="single" hidden="true" dynamic="false" descr="Modbus master network parametrization"/>
					<task name="COPMBoot" interval="t#0us" priority="6" type="single" hidden="true" dynamic="false" descr="CANopen master boot task"/>
					<task name="COPMEvent" interval="t#0us" priority="7" type="single" hidden="true" dynamic="false" descr="CANopen master event task"/>
					<task name="COPMParam" interval="t#0us" priority="8" type="single" hidden="true" dynamic="false" descr="CANopen master parametrization task"/>
				</resource>
			</resources>
			<tasks>
				<task name="Fast">
					<program>Data_ora</program>
				</task>
			</tasks>
			<globalVars>
				<group name="I_O_mappings_LEDOut" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="Led1" type="BOOL">
						<address type="Q" typeVar="X" index="1" subIndex="0"/>
					</var>
					<var name="Led2" type="BOOL">
						<address type="Q" typeVar="X" index="1" subIndex="1"/>
					</var>
					<var name="Led3" type="BOOL">
						<address type="Q" typeVar="X" index="1" subIndex="2"/>
					</var>
					<var name="Led4" type="BOOL">
						<address type="Q" typeVar="X" index="1" subIndex="3"/>
					</var>
					<var name="GreenLed" type="BOOL">
						<address type="Q" typeVar="X" index="1" subIndex="5"/>
					</var>
					<var name="Blue_Led" type="BOOL"/>
				</group>
				<group name="Global_vars" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="DataTime_Set" type="Set_Data_Ora"/>
					<var name="Set_Date_Time" type="BOOL"/>
					<var name="DataOraCorrenti" type="DATE_AND_TIME"/>
				</group>
				<group name="I_O_mappings_ButInp" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="Set_Data_RTC" type="BOOL"/>
				</group>
			</globalVars>
			<retainVars/>
			<constantVars/>
			<iecVarsDeclaration>
				<group name="I_O_mappings_LEDOut">
					<iecDeclaration active="FALSE"/>
				</group>
				<group name="Global_vars">
					<iecDeclaration active="FALSE"/>
				</group>
				<group name="I_O_mappings_ButInp">
					<iecDeclaration active="FALSE"/>
				</group>
				<group name="Ungrouped_vars">
					<iecDeclaration active="FALSE"/>
				</group>
			</iecVarsDeclaration>
			<functions>
				<function name="DST" version="1.0.0" creationDate="1731588591" lastModifiedDate="1731663794" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<inputVars>
							<var name="UTC" type="DATE_AND_TIME"/>
						</inputVars>
						<localVars>
							<var name="yr" type="INT"/>
							<var name="yr4" type="DWORD"/>
							<var name="ltc" type="DWORD"/>
							<var name="idate" type="UDINT"/>
							<var name="March31" type="DATE_AND_TIME"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[// Extract the year from the UTC date-time
yr := YEAR_OF_DT(UTC);

// Convert UTC to a DWORD representation (assuming this is a UNIX-like timestamp in seconds)
ltc := TO_DWORD(UTC);

// Create a date-time object for March 31st of the given year
March31 := CONCAT_DT(yr, 3, 31, 0, 0, 0);

// Convert March 31st date-time to a UDINT timestamp
idate := TO_UDINT(March31);

// Calculate year-based adjustment for finding the last Sunday of March
yr4 := (5 * yr) / 4; // Avoid bitwise shifts; using integer division to simplify logic
yr4 := yr4 + 1;

// Determine if the local time falls within DST range
DST := (idate - ((yr4 + 3) MOD 7) * 86400 <= ltc) AND (idate + (214 - (yr4 MOD 7)) * 86400 > ltc);
]]>
					</sourceCode>
				</function>
				<function name="YEAR_OF_DT" version="1.0.0" creationDate="1731593576" lastModifiedDate="1731593705" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>INT</returnValue>
					<vars>
						<inputVars>
							<var name="idate" type="DATE_AND_TIME"/>
						</inputVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[(*
version 1.4	7. oct. 2008
programmer 	hugo
tested by		oscat

returs the year of a date  
the function works for dates from 1970 - 2099 

*)

(* @END_DECLARATION := '0' *)
YEAR_OF_DT := TO_INT((TO_DWORD(idate) + 43200) / 31557600 + 1970);


]]>
					</sourceCode>
				</function>
				<function name="WeekDay" version="1.0.0" creationDate="1731602678" lastModifiedDate="1731664313" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>INT</returnValue>
					<vars>
						<inputVars>
							<var name="Curr_Date_Time" type="DATE_AND_TIME"/>
						</inputVars>
						<localVars>
							<var name="DummyUdint" type="UDINT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[
// convert date time to UDINT
DummyUdint := TO_UDINT(Curr_Date_Time);


// Calculate the number of days since the epoch (assuming the epoch starts on a Thursday, Jan 1, 1970)
// Adding 4 adjusts for epoch starting on a Thursday
DummyUdint :=  ((DummyUdint / 86400) +4) MOD 7;


// convert to int
WeekDay:= TO_INT (DummyUdint);




]]>
					</sourceCode>
				</function>
			</functions>
			<functionBlocks>
				<functionBlock name="Set_Data_Time" version="1.0.0" creationDate="1731569613" lastModifiedDate="1731665285" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<inoutVars>
							<var name="bSetTime" type="BOOL"/>
						</inoutVars>
						<inputVars>
							<var name="iSetYears" type="INT"/>
							<var name="iSetMonth" type="INT"/>
							<var name="iSetDay" type="INT"/>
							<var name="iSetHour" type="INT"/>
							<var name="iSetMinute" type="INT"/>
							<var name="iSetSeconds" type="INT"/>
							<var name="iTimeZone" type="INT"/>
							<var name="UseDST" type="BOOL">
								<descr>Use Eu saving time</descr>
							</var>
							<var name="bArduino_TimeOk" type="BOOL"/>
						</inputVars>
						<outputVars>
							<var name="udiTimeSet" type="UDINT"/>
							<var name="bArduino_Set" type="BOOL"/>
						</outputVars>
						<localVars>
							<var name="NONAME" type="BOOL"/>
							<var name="dummyUdint" type="UDINT"/>
							<var name="bIsDts" type="BOOL"/>
							<var name="SetYears" type="INT"/>
							<var name="SetMonth" type="INT"/>
							<var name="SetDay" type="INT"/>
							<var name="SetHour" type="INT"/>
							<var name="SetMinute" type="INT"/>
							<var name="SetSeconds" type="INT"/>
							<var name="TimeZone" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<interfaces/>
					<methods/>
					<sourceCode type="ST">
						<![CDATA[
// Set time function

	SetYears:= LIMIT(iSetYears,1970,2038);
	SetMonth:= LIMIT(iSetMonth,1,12);
	SetDay:= LIMIT(iSetDay,1,31);
	SetHour:= LIMIT(iSetHour,0,23);	
	SetMinute:= LIMIT(iSetMinute,0,59);
	SetSeconds:= LIMIT(iSetSeconds,0,59);

IF (bSetTime) THEN
	
	
	dummyUdint := TO_UDINT(CONCAT_DT(SetYears,SetMonth,SetDay,SetHour,SetMinute,SetSeconds));
	
	
	
	
	// set rtc time to utc
	dummyUdint := dummyUdint - (iTimeZone *3600);
	
	IF (UseDST) THEN
	
		bIsDts:= DST(TO_DATE_AND_TIME(dummyUdint));
		
		IF (bIsDts) THEN
			dummyUdint := dummyUdint -3600;		
		END_IF;		
			
	END_IF;
	
	
	udiTimeSet:= dummyUdint;
	
	
	
	bArduino_Set := true;

END_IF;


// if arduino set the time reset the request
IF (bArduino_TimeOk) THEN
	bArduino_Set := false;
	bSetTime := false;
END_IF;



	


]]>
					</sourceCode>
				</functionBlock>
				<functionBlock name="Curr_Date_Time" version="1.0.0" creationDate="1731598458" lastModifiedDate="1731663886" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<inputVars>
							<var name="UTC_TIMESTAMP" type="UDINT"/>
							<var name="Tz" type="INT">
								<descr>Time Zone</descr>
							</var>
							<var name="use_DST" type="BOOL">
								<descr>Day Saving_time</descr>
							</var>
						</inputVars>
						<outputVars>
							<var name="CURR_DT" type="DATE_AND_TIME"/>
							<var name="Is_DST" type="BOOL"/>
							<var name="Week_Day" type="INT">
								<descr>0 sunday -- 6 saturday</descr>
							</var>
						</outputVars>
						<localVars>
							<var name="Dummy_UDINT" type="UDINT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<interfaces/>
					<methods/>
					<sourceCode type="ST">
						<![CDATA[

// add time zone

Dummy_UDINT := TO_UDINT (UTC_TIMESTAMP +(Tz *3600));


IF (use_DST) THEN
	Is_DST := DST(TO_DATE_AND_TIME(UTC_TIMESTAMP));
		
		// IF SUMMER TIME ADD 1 HOUR		
		IF (Is_DST) THEN
		Dummy_UDINT := Dummy_UDINT +3600;			
			
		END_IF;

CURR_DT := TO_DATE_AND_TIME(Dummy_UDINT);


END_IF;

Week_Day := WeekDay(CURR_DT);
]]>
					</sourceCode>
				</functionBlock>
			</functionBlocks>
			<programs>
				<program name="Inizilaizzazione" version="1.0.0" creationDate="1731319304" lastModifiedDate="1731500960" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars/>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="LD2">
						<LD2 version="1">
							<network label="" id="1" nextID="2" comment="" disabled="false" disableCondition="">
								<assignment fromTmpVar="">
									<input>
										<contact name="?" type="Normal" id="0"/>
									</input>
									<outputs>
										<coil name="?" type="Normal" id="1"/>
									</outputs>
								</assignment>
							</network>
						</LD2>
					</sourceCode>
				</program>
				<program name="Data_ora" version="1.0.0" creationDate="1731570529" lastModifiedDate="1732007383" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="iWeekDay" type="INT">
								<descr>0 Sunday, 6 Saturday</descr>
							</var>
							<var name="BSet" type="BOOL"/>
							<var name="Dummy_Bit" type="BOOL"/>
							<var name="bDST" type="BOOL"/>
							<var name="ClocK1Hz" type="Clock_gen"/>
							<var name="FB_Set_Time" type="Set_Data_Time"/>
							<var name="FB_Curr_Date_Time" type="Curr_Date_Time"/>
							<var name="Summer_time" type="BOOL"/>
							<var name="bSet_Ntp" type="BOOL"/>
							<var name="i_WeekDay" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="LD2">
						<LD2 version="1">
							<network label="" id="1" nextID="11" comment="" disabled="false" disableCondition="">
								<assignment fromTmpVar="">
									<input>
										<and id="7">
											<funcBlock name="Clock_Gen" id="2" instance="Clock1Hz">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="Tempo" neg="false" type="UDINT">
														<const name="500" id="3"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="Out" neg="false" type="BOOL"/>
												</outputs>
											</funcBlock>
											<contact name="ClocK1Hz.Out" type="Normal" id="6"/>
										</and>
									</input>
									<outputs>
										<coil name="GreenLed" type="Normal" id="5"/>
									</outputs>
								</assignment>
							</network>
							<network label="" id="2" nextID="53" comment="Set date and time manualy" disabled="false" disableCondition="">
								<assignment fromTmpVar="">
									<input>
										<funcBlock name="Set_Data_Time" id="36" instance="FB_Set_Time">
											<inputs>
												<pin name="EN" neg="false" type="BOOL"/>
												<pin name="bSetTime$in" neg="false" type="BOOL">
													<var name="BSet" id="51"/>
												</pin>
												<pin name="iSetYears" neg="false" type="INT">
													<var name="DataTime_Set.Anno" id="38"/>
												</pin>
												<pin name="iSetMonth" neg="false" type="INT">
													<var name="DataTime_Set.Mese" id="39"/>
												</pin>
												<pin name="iSetDay" neg="false" type="INT">
													<var name="DataTime_Set.Giorno" id="40"/>
												</pin>
												<pin name="iSetHour" neg="false" type="INT">
													<var name="DataTime_Set.Ore" id="41"/>
												</pin>
												<pin name="iSetMinute" neg="false" type="INT">
													<var name="DataTime_Set.Minuti" id="42"/>
												</pin>
												<pin name="iSetSeconds" neg="false" type="INT">
													<var name="DataTime_Set.Secondi" id="43"/>
												</pin>
												<pin name="iTimeZone" neg="false" type="INT">
													<const name="1" id="44"/>
												</pin>
												<pin name="UseDST" neg="false" type="BOOL">
													<const name="TRUE" id="37"/>
												</pin>
												<pin name="bArduino_TimeOk" neg="false" type="BOOL">
													<var name="TimeSetOk" id="45"/>
												</pin>
											</inputs>
											<outputs>
												<pin name="ENO" neg="false" type="BOOL">
													<outputLine/>
												</pin>
												<pin name="bSetTime$out" neg="false" type="BOOL">
													<var name="BSet" id="52"/>
												</pin>
												<pin name="udiTimeSet" neg="false" type="UDINT">
													<var name="TimeToSet" id="46"/>
												</pin>
												<pin name="bArduino_Set" neg="false" type="BOOL">
													<var name="Set_Time" id="47"/>
												</pin>
											</outputs>
										</funcBlock>
									</input>
									<outputs/>
								</assignment>
							</network>
							<network label="" id="3" nextID="10" comment="Set date and time by NTP" disabled="false" disableCondition="">
								<assignment fromTmpVar="">
									<input>
										<or id="8">
											<contact name="bSet_Ntp" type="Normal" id="0"/>
											<contact name="Set_Data_RTC" type="Normal" id="7"/>
										</or>
									</input>
									<outputs>
										<coil name="NTP_Set" type="Normal" id="1"/>
										<tmpVar id="2"/>
									</outputs>
								</assignment>
								<assignment fromTmpVar="2">
									<input>
										<or id="6">
											<contact name="NtpSetOk" type="Normal" id="3"/>
											<contact name="NtpSetKo" type="Normal" id="5"/>
										</or>
									</input>
									<outputs>
										<coil name="bSet_Ntp" type="Reset" id="4"/>
									</outputs>
								</assignment>
							</network>
							<network label="" id="4" nextID="15" comment="Read Current date and time" disabled="false" disableCondition="">
								<assignment fromTmpVar="">
									<input>
										<funcBlock name="Curr_Date_Time" id="8" instance="FB_Curr_Date_time">
											<inputs>
												<pin name="EN" neg="false" type="BOOL"/>
												<pin name="UTC_TIMESTAMP" neg="false" type="UDINT">
													<var name="TimeStamp" id="9"/>
												</pin>
												<pin name="Tz" neg="false" type="INT">
													<const name="1" id="10"/>
												</pin>
												<pin name="use_DST" neg="false" type="BOOL">
													<const name="true" id="11"/>
												</pin>
											</inputs>
											<outputs>
												<pin name="ENO" neg="false" type="BOOL">
													<outputLine/>
												</pin>
												<pin name="CURR_DT" neg="false" type="DATE_AND_TIME">
													<var name="DataOraCorrenti" id="12"/>
												</pin>
												<pin name="Is_DST" neg="false" type="BOOL">
													<var name="Summer_time" id="13"/>
												</pin>
												<pin name="Week_Day" neg="false" type="INT">
													<var name="i_WeekDay" id="14"/>
												</pin>
											</outputs>
										</funcBlock>
									</input>
									<outputs/>
								</assignment>
							</network>
						</LD2>
					</sourceCode>
				</program>
			</programs>
			<macros/>
			<structs>
				<struct name="Set_Data_Ora" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<var name="Anno" type="INT"/>
						<var name="Mese" type="INT"/>
						<var name="Giorno" type="INT"/>
						<var name="Ore" type="INT"/>
						<var name="Minuti" type="INT"/>
						<var name="Secondi" type="INT"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[Set_Data_Ora: STRUCT
	Anno : INT;
	Mese : INT;
	Giorno : INT;
	Ore: INT;
	Minuti: INT;
	Secondi: INT;	
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
			</structs>
			<typedefs/>
			<enums/>
			<subranges/>
			<interfaces/>
		</main>
		<target id="ArduinoOpta_1p2" name="DataLogger.tgt" fullXml="false">
			<![CDATA[(************************************************************************)
(*                                                                      *)
(*	Description: Definition of target variables and functions           *)
(*                                                                      *)
(************************************************************************)

TYPE
	PWMOutput_t : STRUCT
		period : UDINT;
		pulse : UDINT;
	END_STRUCT;
	
	AnExpOutput_t : STRUCT
		analogOutputs : ARRAY[ 0..7 ] OF REAL;
		PWMOutputs : ARRAY[ 0..3 ] OF PWMOutput_t;
		LEDOutputs: ARRAY[ 0..7 ]  OF BOOL;
	END_STRUCT
END_TYPE


(************************************************************************)
(*                                                                      *)
(*   GLOBAL VARIABLES                                                   *)
(*                                                                      *)
(************************************************************************)

VAR_GLOBAL

	{G:"I/O"}
	sysProgrammableInputs		AT %IW0.0	: ARRAY[ 0..7 ]  OF UINT;	{ IO:"System programmable inputs" }
	sysRelayOutputs				AT %QX0.0	: ARRAY[ 0..3 ]  OF BOOL;	{ IO:"System relay outputs" }
	sysLEDOutputs				AT %QB1.0	: ARRAY[ 0..6 ]  OF BOOL;	{ IO:"System LED outputs" }
	sysButtonInputs				AT %IX1.0	: ARRAY[ 0..0 ]  OF BOOL;	{ IO:"System button inputs" }
	
	sysProgInputs_DigExp0		AT %IW10.0	: ARRAY[ 0..15 ] OF UINT;	{ IO:"Digital expansion 0 programmable inputs" }
	sysProgInputs_DigExp1		AT %IW11.0	: ARRAY[ 0..15 ] OF UINT;	{ IO:"Digital expansion 1 programmable inputs" }
	sysProgInputs_DigExp2		AT %IW12.0	: ARRAY[ 0..15 ] OF UINT;	{ IO:"Digital expansion 2 programmable inputs" }
	sysProgInputs_DigExp3		AT %IW13.0	: ARRAY[ 0..15 ] OF UINT;	{ IO:"Digital expansion 3 programmable inputs" }
	sysProgInputs_DigExp4		AT %IW14.0	: ARRAY[ 0..15 ] OF UINT;	{ IO:"Digital expansion 4 programmable inputs" }
	sysRelayOutputs_DigExp0		AT %QX10.0	: ARRAY[ 0..7 ]  OF BOOL;	{ IO:"Digital expansion 0 relay outputs" }
	sysRelayOutputs_DigExp1		AT %QX11.0	: ARRAY[ 0..7 ]  OF BOOL;	{ IO:"Digital expansion 1 relay outputs" }
	sysRelayOutputs_DigExp2		AT %QX12.0	: ARRAY[ 0..7 ]  OF BOOL;	{ IO:"Digital expansion 2 relay outputs" }
	sysRelayOutputs_DigExp3		AT %QX13.0	: ARRAY[ 0..7 ]  OF BOOL;	{ IO:"Digital expansion 3 relay outputs" }
	sysRelayOutputs_DigExp4		AT %QX14.0	: ARRAY[ 0..7 ]  OF BOOL;	{ IO:"Digital expansion 4 relay outputs" }

	sysAnInputs_AnExp0			AT %IR10.0	: ARRAY[ 0..7 ] OF REAL;	{ IO:"Analog expansion 0 analog inputs" }
	sysAnInputs_AnExp1			AT %IR11.0	: ARRAY[ 0..7 ] OF REAL;	{ IO:"Analog expansion 1 analog inputs" }
	sysAnInputs_AnExp2			AT %IR12.0	: ARRAY[ 0..7 ] OF REAL;	{ IO:"Analog expansion 2 analog inputs" }
	sysAnInputs_AnExp3			AT %IR13.0	: ARRAY[ 0..7 ] OF REAL;	{ IO:"Analog expansion 3 analog inputs" }
	sysAnInputs_AnExp4			AT %IR14.0	: ARRAY[ 0..7 ] OF REAL;	{ IO:"Analog expansion 4 analog inputs" }
	sysAnOutputs_AnExp0			AT %QB10.0	: AnExpOutput_t;			{ IO:"Analog expansion 0 outputs" }
	sysAnOutputs_AnExp1			AT %QB11.0	: AnExpOutput_t;			{ IO:"Analog expansion 1 outputs" }
	sysAnOutputs_AnExp2			AT %QB12.0	: AnExpOutput_t;			{ IO:"Analog expansion 2 outputs" }
	sysAnOutputs_AnExp3			AT %QB13.0	: AnExpOutput_t;			{ IO:"Analog expansion 3 outputs" }
	sysAnOutputs_AnExp4			AT %QB14.0	: AnExpOutput_t;			{ IO:"Analog expansion 4 outputs" }

	{G:"User data block"}
	sysUserDataBlock 		AT %MB0.0 	: ARRAY[ 0..4095 ] OF USINT;	{ IO:"Data block available for user data mapping"}
	
	{G:"Fieldbus variables"}
	sysFieldbusDataRO 		AT %MB100.0 : ARRAY[ 0..2047 ] OF BYTE;	{ IO:"Data block RO required for fieldbus data mapping"}
	sysFieldbusDataRW 		AT %MB101.0 : ARRAY[ 0..2047 ] OF BYTE;	{ IO:"Data block RW required for fieldbus data mapping"}

	{G:"Fieldbus variables"}
	sysModbusTCPMasterDataRO	AT %MB102.0 : ARRAY[ 0..4095 ] OF BYTE;	{ DE:"Data block RO required for ModbusTCP fieldbus data mapping"}
	sysModbusTCPMasterDataRW 	AT %MB103.0 : ARRAY[ 0..4095 ] OF BYTE;	{ DE:"Data block RW required for ModbusTCP fieldbus data mapping"}
	
	{G:"System Timers"}
	sysTimer 				AT %MD60000.0 	: UDINT;	{ DE:"System timer [ms]"}
	sysTimerHiRes 			AT %MD60006.0 	: UDINT;	{ DE:"Hi resolution system timer [us]"}
	
	{G:"System"}
	sysIsSimulMode 			AT %MX60008.0 	: BOOL;	{ DE:"TRUE if is simulator target running, FALSE real target is running"}
	sysHasRS485 			AT %MX60007.0 	: BOOL;	{ DE:"TRUE if RS485 port is present"}
	sysCurrentIPAddress		AT %MB5.0		: ARRAY[0..3] OF USINT; { DE:"Current IP address" }
	sysIPAddressConfigured	AT %MB5.4		: BOOL;                 { DE:"TRUE if IP address is correctly configured" }

END_VAR




(************************************************************************)    
(*                                                                      *)    
(*   EMBEDDED FUNCTIONS                                                 *)    
(*                                                                      *)    
(************************************************************************)   


FUNCTION sysLogWriteMsg : BOOL
	{DE:"Writes a log to LogicLab 'Debug' output pane"}
	VAR_INPUT
		level: UINT;
		msg: STRING;
		info1: DINT;
		info2: DINT;
		info3: DINT;
		info4: DINT;
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION sysCfgAnalogRes : BOOL
	{DE:"Global configuration of system programmable inputs: analog read resolution (12/14/16)"}
	{ HIDDEN:ON }
	VAR_INPUT
		res: USINT;
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION sysCfgProgInput : BOOL
	{DE:"Global configuration of system programmable Inputs. Values for mode: 0 - digital, 1 - analog"}
	{ HIDDEN:ON }
	VAR_INPUT
		pin: USINT;
		mode: USINT;
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION sysCfgProgInput_DigIOExp : BOOL
	{DE:"Global configuration of expansion programmable Inputs. Values for mode: 0 - digital, 1 - analog"}
	{ HIDDEN:ON }
	VAR_INPUT
		expIndex: USINT;
		pin: USINT;
		mode: USINT;
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION sysCfgProgCh_AnIOExp : BOOL
	{DE:"Configuration of expansion analog programmable channel. Values for mode: 0=RTD3 1=RTD2 2=currentADC 3=voltageADC 4=digitalInp 5=currentDAC 6=voltageDAC"}
	{ HIDDEN:ON }
	VAR_INPUT
		expIndex: USINT;
		pin: USINT;
		mode: USINT;
		rtdCurrent: REAL;
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION sysSetConfiguredIOExp : BOOL
	{DE:"Set actual configuration of IOExp in the project"}
	{ HIDDEN:ON }
	VAR_INPUT
		numExp: USINT;
		expType: @UINT;
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

]]>
		</target>
		<targetXML name="DataLogger.tgtx" fullXml="true">
			<target>
				<resources>
					<resource name="ArduinoOpta" processor="ARMThumb2_VFP2">
						<task id="0" name="Fast" period="10000" type="cyclic" descr="Fast task">
							<constraints>
								<validPeriods>
									<period>10000</period>
									<period>20000</period>
									<period>50000</period>
								</validPeriods>
							</constraints>
						</task>
						<task id="1" name="Slow" period="100000" type="cyclic" descr="Slow task"/>
						<task id="2" name="Background" period="500000" type="cyclic" descr="Background task"/>
						<task id="3" name="Init" period="0" type="single" descr="Init task"/>
						<task id="4" name="MbBoot" period="0" type="single" descr="Modbus boot task" hidden="true"/>
						<task id="5" name="MbMPrm" period="0" type="single" descr="Modbus master network parametrization" hidden="true"/>
						<task id="6" name="COPMBoot" period="0" type="single" descr="CANopen master boot task" hidden="true"/>
						<task id="7" name="COPMEvent" period="0" type="single" descr="CANopen master event task" hidden="true"/>
						<task id="8" name="COPMParam" period="0" type="single" descr="CANopen master parametrization task" hidden="true"/>
					</resource>
				</resources>
			</target>
		</targetXML>
		<libraries>
			<lib version="1.0.2" name="c:\program files (x86)\arduino plc ide\catalog\arduinoopta_1p2\arduinoopta\..\..\..\Arduino PLC IDE\Libraries\Standard.plclib" fullXml="true" link="true">
				<descr>Release notes:
- 1.0.2 : changed the behaviour of R_TRIG to be fully compliant to IEC 61131-3. Even after a cold restart R_TRIG.Q will now return TRUE once when R_TRIG.CLK is connected to TRUE.
		</descr>
				<libWorkspace>
					<folder id="7" name="Standard">
						<folder name="Timers">
							<Pou name="TOF"/>
							<Pou name="TON"/>
						</folder>
						<folder name="Set/reset">
							<Pou name="TP"/>
							<Pou name="RS"/>
							<Pou name="SR"/>
						</folder>
						<folder name="Edge detection">
							<Pou name="F_TRIG" genHidden="false"/>
							<Pou name="R_TRIG" genHidden="false"/>
						</folder>
						<folder name="Counters">
							<Pou name="CTD"/>
							<Pou name="CTD_DINT"/>
							<Pou name="CTD_UDINT"/>
							<Pou name="CTU_DINT"/>
							<Pou name="CTU"/>
							<Pou name="CTU_UDINT"/>
							<Pou name="CTUD"/>
							<Pou name="CTUD_DINT"/>
							<Pou name="CTUD_UDINT"/>
						</folder>
					</folder>
				</libWorkspace>
				<globalVars/>
				<retainVars/>
				<constantVars/>
				<functions/>
				<functionBlocks>
					<functionBlock name="CTUD_UDINT" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Up-Down counter (UDINT data type)</title>
						<descr>&lt;HTML&gt;(Same as CTUD_UDINT but with PV and CV of &lt;b&gt;DINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTUD_UDINT block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and &lt;b&gt;count down&lt;/b&gt; for each  FALSE-to-TRUE transition of the input CD.&lt;br/&gt;
Sets the QU output when the accumulated value (CV) reaches the preset value (PV) value and sets the QD output when the accumulated value (CV) becomes 0.&lt;br/&gt;
&lt;img src= ctudscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of LD set CV to PV&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output QU is set&lt;/li&gt;
&lt;li&gt;when CV becomes 0 the output QD is set&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="CU" type="BOOL">
									<descr>Count-up input</descr>
								</var>
								<var name="CD" type="BOOL">
									<descr>Count-down input</descr>
								</var>
								<var name="R" type="BOOL">
									<descr>Reset counter input</descr>
								</var>
								<var name="LD" type="BOOL">
									<descr>Preset counter input</descr>
								</var>
								<var name="PV" type="UDINT">
									<descr>Preset value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="QU" type="BOOL">
									<descr>Count-up output</descr>
								</var>
								<var name="QD" type="BOOL">
									<descr>Count-down output</descr>
								</var>
								<var name="CV" type="UDINT">
									<descr>Counter current value</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="MEMCU" type="BOOL">
									<descr>Previous value of CU</descr>
								</var>
								<var name="MEMCD" type="BOOL">
									<descr>Previous value of CD</descr>
								</var>
								<var name="CUEDGE" type="BOOL">
									<descr>True whenever a posedge on CU is detected</descr>
								</var>
								<var name="CDEDGE" type="BOOL">
									<descr>True whenever a posedge on CD is detected</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(* Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l10

l0:
	(* Check for preset input *)
	LD		LD
	JMPCN	l1
	
	LD		PV
	ST		CV
	JMP		l10

l1:
	(* Check for posedge on CU *)
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	(* Store CU value for next cycle *)	
	LD 		CU
	ST 		MEMCU

	(* Check for posedge on CD *)
	LD		CD
	ANDN 	MEMCD
	ST 		CDEDGE
	(* Store CD value for next cycle *)	
	LD 		CD
	ST 		MEMCD

	(* Check for simultaneous posedges on *)
	LD		CUEDGE
	AND		CDEDGE
	JMPC	l10
	
	(* ASSERT(!CUEDGE || !CDEDGE) *)

	(* Check if posedge on CU and we are in bounds *)
	LD		CUEDGE
	AND(	16#FFFFFFFF
	GT		CV
	)
	JMPCN	l2
	
	(* ASSERT(CUEDGE) *)
	(* Increment *)
	LD		CV
	ADD		1
	ST		CV

l2:
    (* Check if posedge on CD and we are in bounds *)
	LD		CDEDGE
	AND(	CV
	GT		0
	)
	JMPCN	l10
	
	(* ASSERT(CDEDGE) *)
	(* Decrement *)
	LD		CV
	SUB		1
	ST		CV
	
	(* ASSERT(!CUEDGE && !CDEDGE) *)
	
l10:
	(* Up counter output *)
	LD		CV
	GE		PV
	ST		QU

	(* Down counter output *)
	LD		CV
	LE		0
	ST		QD
]]>
						</sourceCode>
						<images>
							<image name="ctudscheme.png" width="376" height="244">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAAXgAAAD0CAYAAACRmD2xAAAWEklEQVR4nO3dPXbbSLrG8afu
mTM3mpmW7w7USxB3YHoJctALkHM5kCPzcCI5MHNpAR2ISxC9A3IJ5g6u1NOTzQ3qBgVQAAgQ
QBEfBeD/O4ftpvBVJMEXLwv1IQEAAAAAAAAAAAAAAAAAAAAAMBymbAVrbRflkCQZkypOfODD
H7ssCwCEJhMjS/1XS+UAAPQs1ABvC/4fAFBRqAEeAHCmEAN8XsZOFg8ANYUY4AEADQgtwJ/K
1MniAaCG0AI8AKAhf+m7ABnJRp5H7eABANWRwQPASBHgAWCkQquiycUQBQBQHxk8AIwUAR4A
Rso/wBtzJ2NeZIyNHs8y5jpnveQ6p9fNQfXMyByfC9090L0+P2/f86Pu84D5BXhjniXdSPok
a42sNZJeJT3JmJucLXaH9dy6+2jdO9+CAwBOqz8evAvK95I+yNpNZtmTpLmkX2Xta/S3F0l7
WTsr2M9M1u7cn47Hg7fugoCxiDOfLj/XPo4Jh/e+UV2MB38jF7A3OcseJV1IqlL98iiX9edl
/ACAM9UL8MZcSLqUlBfcJWkX/XtVui+X4e/lMn4AQMPqZvCX0b+vJetd1NhnnXUBABXRTBIA
RqpuT9Z99G9Z1l2W4eeum7yhW/dmAgAgrV4GX15vHte97wqWvymvzwcAnMGniuZR0qWMyQvy
N3IZ+brCfu7kfgk8epQBAFCi/mBj1n6LgvuDjPkia10wN+Zernnkp0Mb+Dwuc3+I1v0St4E/
sf6/JP29djmBrIH0PgSa4jeapLUfoo5KD1HnpthO+VUuV5kv11qJDk4AgObV78lauCdzLZeZ
Sy6Lr1JNc2J35mhGJ8alATBlXfRkzecC+kwui6/TigYA0ILmMviGkcEDQFp/GTwAICgEeAAY
qaDmZKX3KgA0hwweAEYqqAy+SJ83V/lVAR+DaA5grWRMeUuLERt7w43gM3hLL1YA8BJ8gAcm
x1r3AM4UfIA30p99lwEAhij4AD821trOH+iXWbreelUfqW0bfmBa/AO8MXcy5kXG2OjxHI1H
k1znKlp2n7P9RbTs6WhZX95ey+Fh334wV3kQbBGEonNUyYfrLV73HPd7cP73wi/AG/MsN/b7
J1lrZK2RG3/mScbcNFg+nIlWQMB01W8m6YYJnkv6IGvfhga29mOUjd/LmPXJMeFDlA6EdaNi
cq7BE2uRwaBzfV/h3UlPotELnwz+RtI+FdzfPMrN0nSdswzGdP9A/xZ9FwBTVS+Df5tHtWia
vXgCj6uC5eGKOn2knqtaFUcyLyekojHZc9JTcg+p35AddHTiu9GvulU0l9G/ZdUvFx5lSd2E
SQbWruqRUydjdMy6lSpUwqBJ3jcmE9+Z1D6S3yXPc9xXV8cxOr6wFD33jS1DuWE8iKEKgCkY
StDAcNQN8Pvo37IMfVg3WE+ocn3nZyia0OQv1bxfo33o67uR15/g1POxqneT1bWM2cu1oskT
173HdfGjCfQAMDQ+rWgeJV3KmLwgfyMX1N2E29buVXxByF4MAABdyu2RKT1b6aeVrhN/u496
rd1k1r2J/v6Q+NuVlbZW2p7o8Rn3svtXJz3tCnqkVnqPui8fDx5VH70K4PWf/7BWR8+Tfyt6
3sKjLr+erNZ+kMvkHw7d+qU7uWx8k1n3UdJHuaw/XncraSNrZ17H7xDDDAAYqtJ7DZUDmxuH
5iF69knWrv2LJRl3IZAk00lwNeYt36l7U6rqdj1cJKY2VAGX4WOhtIPvQ9lrG1riVvf73Fwz
SWvXMmYnF+S5uZpnYsEWQL+ay+Ab1nkGnz74Iduu1JM1kcETwiHprOaBRR3+mtB1Bh+6sWfw
IX+2hwDf2QFzAnWlj9+3ageTcE6Ab9wEztFaPVk9j9Fj4ltrfXqyAoEYWjaJ8BHgS9CTFV2Z
2g3xNtGT1Qlyyj4yGQA4X5ABHgBwvuCqaLLZu5X+Lmv/7KsctX42u95sCMHEW4cAUoABPjRt
NlkDgDYFFeAL6t7/HETTriGUEcCkBBXgg5KcUarHYgCAr6ACfF4VSF/BtVZdOhcDAAEKKsCH
pE6gJqgDCFHIsckl0bebktUAoEGruYuLtxtb5bn9/r6zOFq3oQft4AFgpMLP4HsqI71pgfGK
M2Gv/i5isLHBo807EJYmgmr2ez3277lfgL/dvEi6yFmykfSo1Xyt282V3NR8a63mHwv28zPa
z69azZkkBAAa5Hf5cgF+r9V8lvjbhaQnSXNJH7Sab3S7eZZ0pbwAfruZS3qWuyB8yjmKu4Fh
7bgvscCIFVWFlD3P00YG72soVTTN3WRdzV+1mn+Qm67vLvrrWi5Dv87ZYp5YBwDQsDbq4Pdy
Wbu0mj/qdnMvF+AfM+tdy/0KONkOcux1ZMAUlNV98z1vRxvNJC8l7RLP15Lmut1cHv7iqmcu
dRz0AQANaTbAuzr3C6WrXeL/T1bTXGeWAQAads5N1tOtaNLr/5T0ergp67bfRXX2RXptB49p
8G0Hje5xk7XbdvC7VCua09aS7qJqmisdZ/kYqeA7jBlzmKiFEI+x6WqogmQ1zbVcNk/9OwC0
qJsAv5rv5G68Xss1jyR7nxpj6j/O2bbqvoER63KwsbWongFQgbU29YCfLseieZTrAPVa1vYd
42SWkhbV109+rZvOuQkZgSoaHrypYcOT+1nNj5+PjF+AX83feWzzKqn+dgAmx3z+0XcRRoHx
4AFgpIIfLni73aZ+Tc9mM8Py4Szf7XY2WlFbSbOFx/bRtq2Ub7u12u3eyhfY+zf25WhX8AH+
SFldHMtHs9x8/qHtb7+0sv+4CqCt/bO8eLn9/j5dBZOsCz9VD/69gTsn2f2PsN49KeSrKT1Z
R+DQAsKY+jdZk9u2WC5Z28ox4OHEBcJ+f3/27gsvLPHziqbQk7UT2Tcy+wJZHvbyxIqut+jC
Y/to21bKFy+PyxfY+zf25WhX8AH+SAA/MVnezXLz+cdx1tZwFU1b+2d58XKqaLoT8uXURv/p
pYwhvzHAFDHY2AiraAi0AOAn+AAPYPgYbqAfBHgAozblG7sE+KTbzXlpxmo+3TMJYTn3XG4e
340eEODT/t13AYAR4nvVEwJ82t+if02dThXm8w+XLUVNwHwlf0put1tdXV1576ts/5iMvj90
q7fvFTpGgM/3N0azAzB0/gH+dnOjtxmaJGkvN+H2t2j5naR7SV8Of0tvfynpp+rN7dqVf5/K
xE8Ff58sOa+FwWzW/FtSpSVD9ldEVrJc2eXZMrN9ve2b2r+1NnWONtHF31cIiVL8PjX5+Rpj
zv78umhZ5DdcsAveD3LB2UQ3F7/JTaz9IElRUH+Vuwjkif/O3KwA0IL66ebt5krSVtI3reZf
Msvu5WZt+qDVfBMF+xtJv2o132fW3Uq6PDF5SPeDjb21PPhv+/39f6pudqiDD1etewpHG1N3
X014LVckyfTaHT96T+z3972dRKGevz4ZfN3X4pPB30T/5mXe8UAU8d3BeO7VdBbvLhJXYm7W
wcvOnVn1AUydMebw2O12qUdy2TkXKJ86+Eu5eVX3R0vcXKsm9fx2s5e7KCTr4eOUIswAv5r/
p+rARubzj78q/ZqrH6epeSaL/Z+iz/jcewNNB+UxBvlEfXOYKSMmxyfAX9Rc/1HSvW43V1rN
d9HfbiTtmXy7dX+RoptsZ4zEZ60tvECMMVADXWujUYXUTTPJOIhfS9rpdjOX+xXwpXiTN10G
EK87/qt55br6nG0P/xu/ztwhck8oWt8Ykxoa99x9EshPS77fkkY/DC2GwacO/rXW2i5r3+mt
Hj7s6pkKmqgbw7hkL4C+9yaafmDafDL4vaS5bjeXOS1j5pKeddz2fS1XTTOXC/Sb3Dr8HL20
o22/bjwlVdfdUJvlTFtoW/d97OB9P6tlT60Dhd/KCWiFT4B/lKtDv9FxNUucnWcj5KNc88k7
ueqZ445PQ9bxBQHh49ddWlk14dH7VeU7VbMarO1fNPFrOFS3VnzepvoBfjXf6XYTd2p6TfRc
jYP+Y+JmarzNq243G7ns/VWrefXOTV3WZfYYqCtnzNH7EZ8kJVlwiFEmbhfdx7FDfD+A1vjd
ZF3NvxyaP7rOTZKruvmWOyyBs5YL8IOtez8gY+9U2UTOGIEOv1NtZ87Z/Zc9b5N/KxqXhdfJ
xNcaSAbVdXZ5Tn13YSuaOvvM/Cqo0+qm9snq2bKniWMmj0cVSrf6HA8nZFWrc3wxmiTOUzXz
OqeqrY3sjl9hw+f7GYby2XdQ/RxyGnMYY73zAyfGzdjtdv+bXDabzf4n+Xy73bK8+nI7+/2P
1PIubX/7RbPZzEhvmdFut0ulSPHywzbbLcvrLP/9j8Ny+/398FswxbO0xeMMlT1PxNTsr5aj
X9U1ArzvjVky+HLpwdCOLzgsr7O8b4kqIskF/bzlZduzHEMwhAy+lzL6jgffutXcu16uqXLH
700IY33XkaqDH1jZ0a3QzvFDecjgmxHKB3skoAyq7RtnTX8G8f7yyl32c5rl5y3vUxPn6VDf
v/ADfFft4LPjiAQUSFNW87MGDhuSOr+i6n6B0C0+n34EX0VjrU2VcbfbpUZey1ZXlLWZrrx9
qAFe/l+GkLIqoHdnJI999cWgimYCCNQAqgg+wJddsdpeDgBD5TfpNgAgeAR4ANMzkQlZgq+i
AYYopFYh3LOZLjJ4ABgpAjwAjBQBvshE6ugAjJdfHfxSL5L2Wmh2Yp0nvU20HdtJWmtRfcq+
ZIeC1usS/zHP9F7wCPKLoDuPTUfAHdU6N4RkJfN5ZQeBm/3+R6PLp6KLDP6dFjJR4FtLuouC
PwCgRX7ZZr0M/p0Wek38fS7pWdKXkkz+aHzl1i2jY/pk4edsi9EJaVpBOvM1byhDFXRfB7/Q
Rq6q5qbzYwPAhPR1k3Uj6VJLXfZ0fAAYvb5b0Vz0fHwAGK2+AzwAoCV9B/jX8lUAAD76CvBz
uVY4+56ODwCj132AX+pa0pWkx86PDQAT0u1okkvdSbpXnd6sS4XToLiKoZUXrTD/DKjt+bLv
AgxQ3J8l279l2UP/nDOcE+CvCoLZNy30JfH8JXGCbSR90oLsHQDaFvJVyF08bjedlTEew9t8
/tHLeN4+PQ5D6jHZlKCy3zPZr5lJ3Vt8bdlj5ZnaORa/3vg1FD2vi56sAIBeMaNTgaGM3zGU
ck6VWXT3+bR1rDGcY9nXMIbXVAUZPACMFBl8CJpq5bBoaD8YH86xSSKDB4CRCj+DX82ZnQe1
DLnVx7mmUrdc9hlP5X0oE3wGb63tvMliH00kAaBp4WfwEfv9fftzsoaiTj0nvRThg3NsEgYT
4NtwKlPv9Wf+1/JV+AkKoEzwVTQAAD/BZ/CtZqrfp3szDsD4BR/ggbqovioxgrbsfMbVNPcu
LfUk6TpnyVpuhMldzT1aSbLWHsrY9E3WIbeW4QQv0XPT2pDOrU7Plez7/o/5+T+TF8dxarvd
pp7Pfv8jvfy3X04u12p+VpGmPNjYOy1kog/lV7mJtZ+11GULxwIAFGgjg3+nRWKu1aWuJG0l
PWqhTzX22PrA+kPuEEMGH7aQzq1ez5XshBldbduyKWfwWfG8qxcdHAsAEOkiwMdVM0ywDQAd
ajfAu3r3B7ngXm0OVgBAI9poJvmS6dq8kfQhVS8PYFJ86qzHNHVjX9puRbOXdEFwB4DutV0H
/yjpSkvdtHwcAEBGuwF+oW9yWfxdq8cBABzpYqiCR0n3WuouCvj1LNVag9NB1/ExhGvQgjq3
hn6utBgDCsVt77Nt8Zft989pUvvNJF1Q30m605K28ADQlZCvQt1eKdvIcgId1Clu0eDTw/Gc
bZsU6mvoqlyhvv6yY9YRly+Ucy6JnqwAABSwUrd1b9Zad2Ueep1licPr7HjbJoX6GroqV6iv
v+yYdR59lreMz+tp4lEXGTwAjBQTfgABK8vazslsQ8uKs7LlC728ISLAF+BkOm0M70+oryHU
cmF4BlFFE2IdHACEjgy+QEhNskIyhvcl1NeQVy4SG5wj+ACfvZsOAKgm+ACPFjTVDLTPjlyh
voZQy4VJCj7AG2NG3y4dANoQfIDvHJkTgJHwv9vkBg67U3oo4LWkL1ok5l9d6knSdWbrnaR1
yeiSwxm1rYnR7tqYOT7EcnVUpibu1yRvelbZX5tj2wBSV2PRuOC+lTSXNIu+cO+k6O/Lw0Tb
ScmZntZyo0s+eR0fAFDKt4rmQS6Yzw7T8S30qqU+SvoZLf9QuPVC37TUTtKz9zjxIfLJdrsY
6zrEcnVUpnNGW6y6H7JshKp+Bu+y82u5Kpb0XKvu+U7SVel+FtpE6zKdHwC0wKeKJq5+2ecu
XeiDFnpXcV8bSZcFVToAgDP4BPg2ZmVipicAaNggxqIBANTnE+Bfy1cJYp8AMGk+AT6ue8+v
N1/qWUu9VNzXXNI+1W4eANCI+gHeBeO1pOuoPfwb9/xK7ubpaUtdR+s+1i4DAKCUX9c71+rl
WS6b/6SF9lFwf5IL2rNDVv7Wk/XdoVnlUneS7uWaWn4sOIqN1h2OENubS7JfbWG5Ctt3j6Qd
POAtPkfj8y7z/NT3qi3d9GR1wXsmF+B/Ri/4Ra4ufVZQ5fKipWy07lzuwlAU3AEAZwp5nJc4
g2+2jAwmhgGhlyySusngAQDBCz+DD7uMQKvI4JFEBg8ACJ6Vxt1qwlp79qPvVkahvoauyhXq
6x9LeUPVxPvo9d7XRAYPACPFlH0BMP/0GLP8a1g/bkJ9DV2VK9TXX2Ro5YUfMngAQOdGVQff
V53dkB9NvN9aqnadcZ265q6O05ShlTdUQ/lOkMEDwEgR4AFgpAjwADBS/r1E3eiRd9Ejtpb0
JTXYmBsbfq+FZjn72Eq6LJjDdVQ9Wc+tU56iur32CjUxCmWV0S+7Ok4VIZVlhPr6PnfTk9UF
963cqJCz6ER4J0V/ZxJtAOidbzv4B7lgPjuM8b7Qq5b6KOlntPxDIyUEmtLVGPQhjXUfUlnQ
ufoZvMvOr+Um60jPpeqe7+Qm/QAA9Mgng4+rX/LnUV2QuQNACHzq4C/KVwEA9I1mkgAwUj4B
/rV8FQBA33wCfFz3nt8UcqnnqO17jAsCAPSgfoB3nZjWkq6j9vBv3PMrSZvEX3eSLo/WdS4z
6wIAGuLbDv6LpGdJT1rqkxbaRwH8KbE8ue42Wvdj1F6+aN1jI2mT6zP+9uSFNGphV+dhw8dJ
9ris3TN4JN+9RsT9CaL3xMRvZvTcfrUn39x49fjzyD5vi99NVpfFz+Sqa35GL/JFrjpmlhqq
4G3dV0kvJ9cFADQm5LRyVGPR5AopQw3BouJ60ftWNsNQY2PZABnjHosG6FmV6eMY4A1TF3KK
M/4MHt7qBG8yeTRtKBl8yGc+AR5nyd7QAgYgFffOukku/1Y0QPAI7BiwRhLckL8BZPAApqao
7scrDlbZiDtVABCGWoGeVjQAMFIhV39QRQNgahqtouEmKwCE66wElwAPAOFppOaCAA8ANbXY
0anSoGVVcZMVAEaKAA8AI0WAB4CRIsADwEgR4AFgpAjwADBSBHgAGCkCPACMFAEeAEaKAA8A
AAAAAAAAAAAAAAAAAEbq/wGQpWZSHyQgQgAAAABJRU5ErkJggg==]]>
							</image>
							<image icon="true" name="ctud48.png" width="48" height="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAC5UlEQVRoge1YoZLbMBB92yns
gRRcZ2xWHtSZfEGKDxXHKCHH8wvHW3KHHFzSooLeF1yn6Ep7zAIBNcgHbEEkZ61IthS7OWea
N6ORJa1Xb61drSXgjDP+b5Cnn11jzPxv2USAaEvvhWOMrXrQsA2wSQ/eiJdW27iN04WGCJcL
nRTOBjw3WrfRJMlvAczF2F1RzBb2C2m6WgK4cegqAbwH8FO35wBufXJKZUYOzAwiQpLkDICU
yvZesoPYhXvxPPdKbQneOfrnuiwi5QDAkAcATpJ8z4ioRKaV3SmVLWRSG0/W+FN886gCa8J7
q+aSUyqr5AT5GueimDUmslbYGfnx4fIQNY3wkAcATtNV1QhxoVCMACx1HYIbIWvqEmgkb1B5
yMEGpOlqVBSzcjxZm66lLjZK7Pv8CFt/t401ARycRLtso7/TdCV3HUOGrPJaEDModb+UAYCp
rjmgHG6ADqARgNHjw2UfMVCaB2aGUlnbClTjnRPZeLKGcKPOMLtLgxFUFLOq0RoDSZJ/wG5p
AWCqk5sPrrHP2OWTd2jOJxWKYkZpupIBTUplIMqqjpAgnloTvhXtp18/3gAAkiQ34y5yT2g3
wBXsUCqjpkzsw9HOAU2nPGauFfGR2vWGKOyrtBkXS77RgKHh5H+nzwY8N6ptVPq3SSZ9+jwf
srMxE4jMj1utNlku6jzQBdyzTqOo8+/0QV+2R+xcSHQSolntviyzWGAHYtySyC+v5whZgThb
msiHjAfIb66vqudQFxr+LR3rxdI+zVwvQSeMYxW8+l7xrlZgc32125k+fWXRDsLFxy+gi/t2
QQu8mdbek217zPRB9FUk5c+SUhknSS4veiVsw9pixKfHp68V8lolNgZiSXQ13j2ZCGxpgMx0
TcpjJw25IvFhLwNvaybzLcQXqWUCLeTS1TRXCDdqGQ9Fh5u544OiLR3ayaV2FyTR13oeE2Su
3ZswNGO8K3AiMQAgMl8MbQXOGCz+ArhmepcGiq6VAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="CTUD_DINT" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Up-Down counter (DINT data type)</title>
						<descr>&lt;HTML&gt;(Same as CTUD but with PV and CV of &lt;b&gt;DINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTUD_DINT block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and &lt;b&gt;count down&lt;/b&gt; for each  FALSE-to-TRUE transition of the input CD.&lt;br/&gt;
Sets the QU output when the accumulated value (CV) reaches the preset value (PV) value and sets the QD output when the accumulated value (CV) becomes 0.&lt;br/&gt;
&lt;img src= ctudscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of LD set CV to PV&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output QU is set&lt;/li&gt;
&lt;li&gt;when CV becomes 0 the output QD is set&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="CU" type="BOOL">
									<descr>Count-up input</descr>
								</var>
								<var name="CD" type="BOOL">
									<descr>Count-down input</descr>
								</var>
								<var name="R" type="BOOL">
									<descr>Reset counter input</descr>
								</var>
								<var name="LD" type="BOOL">
									<descr>Preset counter input</descr>
								</var>
								<var name="PV" type="DINT">
									<descr>Preset value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="QU" type="BOOL">
									<descr>Count-up output</descr>
								</var>
								<var name="QD" type="BOOL">
									<descr>Count-down output</descr>
								</var>
								<var name="CV" type="DINT">
									<descr>Counter current value</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="MEMCU" type="BOOL">
									<descr>Previous value of CU</descr>
								</var>
								<var name="MEMCD" type="BOOL">
									<descr>Previous value of CD</descr>
								</var>
								<var name="CUEDGE" type="BOOL">
									<descr>True whenever a posedge on CU is detected</descr>
								</var>
								<var name="CDEDGE" type="BOOL">
									<descr>True whenever a posedge on CD is detected</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(* Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l10

l0:
	(* Check for preset input *)
	LD		LD
	JMPCN	l1
	
	LD		PV
	ST		CV
	JMP		l10

l1:
	(* Check for posedge on CU *)
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	(* Store CU value for next cycle *)	
	LD 		CU
	ST 		MEMCU

	(* Check for posedge on CD *)
	LD		CD
	ANDN 	MEMCD
	ST 		CDEDGE
	(* Store CD value for next cycle *)	
	LD 		CD
	ST 		MEMCD

	(* Check for simultaneous posedges on *)
	LD		CUEDGE
	AND		CDEDGE
	JMPC	l10
	
	(* ASSERT(!CUEDGE || !CDEDGE) *)

	(* Check if posedge on CU and we are in bounds *)
	LD		CUEDGE
	AND(	CV
	LT		16#7FFFFFFF
	)
	JMPCN	l2
	
	(* ASSERT(CUEDGE) *)
	(* Increment *)
	LD		CV
	ADD		1
	ST		CV

l2:
    (* Check if posedge on CD and we are in bounds *)
	LD		CDEDGE
	AND(	CV
	GT		-2147483648
	)
	JMPCN	l10
	
	(* ASSERT(CDEDGE) *)
	(* Decrement *)
	LD		CV
	SUB		1
	ST		CV
	
	(* ASSERT(!CUEDGE && !CDEDGE) *)
	
l10:
	(* Up counter output *)
	LD		CV
	GE		PV
	ST		QU

	(* Down counter output *)
	LD		CV
	LE		0
	ST		QD
]]>
						</sourceCode>
						<images>
							<image name="ctudscheme.png" width="376" height="244">
								<![CDATA[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]]>
							</image>
							<image icon="true" name="ctud48.png" width="48" height="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAC5UlEQVRoge1YoZLbMBB92yns
gRRcZ2xWHtSZfEGKDxXHKCHH8wvHW3KHHFzSooLeF1yn6Ep7zAIBNcgHbEEkZ61IthS7OWea
N6ORJa1Xb61drSXgjDP+b5Cnn11jzPxv2USAaEvvhWOMrXrQsA2wSQ/eiJdW27iN04WGCJcL
nRTOBjw3WrfRJMlvAczF2F1RzBb2C2m6WgK4cegqAbwH8FO35wBufXJKZUYOzAwiQpLkDICU
yvZesoPYhXvxPPdKbQneOfrnuiwi5QDAkAcATpJ8z4ioRKaV3SmVLWRSG0/W+FN886gCa8J7
q+aSUyqr5AT5GueimDUmslbYGfnx4fIQNY3wkAcATtNV1QhxoVCMACx1HYIbIWvqEmgkb1B5
yMEGpOlqVBSzcjxZm66lLjZK7Pv8CFt/t401ARycRLtso7/TdCV3HUOGrPJaEDModb+UAYCp
rjmgHG6ADqARgNHjw2UfMVCaB2aGUlnbClTjnRPZeLKGcKPOMLtLgxFUFLOq0RoDSZJ/wG5p
AWCqk5sPrrHP2OWTd2jOJxWKYkZpupIBTUplIMqqjpAgnloTvhXtp18/3gAAkiQ34y5yT2g3
wBXsUCqjpkzsw9HOAU2nPGauFfGR2vWGKOyrtBkXS77RgKHh5H+nzwY8N6ptVPq3SSZ9+jwf
srMxE4jMj1utNlku6jzQBdyzTqOo8+/0QV+2R+xcSHQSolntviyzWGAHYtySyC+v5whZgThb
msiHjAfIb66vqudQFxr+LR3rxdI+zVwvQSeMYxW8+l7xrlZgc32125k+fWXRDsLFxy+gi/t2
QQu8mdbek217zPRB9FUk5c+SUhknSS4veiVsw9pixKfHp68V8lolNgZiSXQ13j2ZCGxpgMx0
TcpjJw25IvFhLwNvaybzLcQXqWUCLeTS1TRXCDdqGQ9Fh5u544OiLR3ayaV2FyTR13oeE2Su
3ZswNGO8K3AiMQAgMl8MbQXOGCz+ArhmepcGiq6VAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="CTUD" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Up-Down counter</title>
						<descr>&lt;HTML&gt;The CTUD block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and &lt;b&gt;count down&lt;/b&gt; for each  FALSE-to-TRUE transition of the input CD.&lt;br/&gt;
Sets the QU output when the accumulated value (CV) reaches the preset value (PV) value and sets the QD output when the accumulated value (CV) becomes 0.&lt;br/&gt;
&lt;img src= ctudscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of LD set CV to PV&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output QU is set&lt;/li&gt;
&lt;li&gt;when CV becomes 0 the output QD is set&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="CU" type="BOOL">
									<descr>Count-up input</descr>
								</var>
								<var name="CD" type="BOOL">
									<descr>Count-down input</descr>
								</var>
								<var name="R" type="BOOL">
									<descr>Reset counter input</descr>
								</var>
								<var name="LD" type="BOOL">
									<descr>Preset counter input</descr>
								</var>
								<var name="PV" type="INT">
									<descr>Preset value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="QU" type="BOOL">
									<descr>Count-up output</descr>
								</var>
								<var name="QD" type="BOOL">
									<descr>Count-down output</descr>
								</var>
								<var name="CV" type="INT">
									<descr>Counter current value</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="MEMCU" type="BOOL">
									<descr>Previous value of CU</descr>
								</var>
								<var name="MEMCD" type="BOOL">
									<descr>Previous value of CD</descr>
								</var>
								<var name="CUEDGE" type="BOOL">
									<descr>True whenever a posedge on CU is detected</descr>
								</var>
								<var name="CDEDGE" type="BOOL">
									<descr>True whenever a posedge on CD is detected</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(* Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l10

l0:
	(* Check for preset input *)
	LD		LD
	JMPCN	l1
	
	LD		PV
	ST		CV
	JMP		l10
	
l1:
	(* Check for posedge on CU *)
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	(* Store CU value for next cycle *)	
	LD 		CU
	ST 		MEMCU
	
	(* Check for posedge on CD *)
	LD		CD
	ANDN 	MEMCD
	ST 		CDEDGE
	(* Store CD value for next cycle *)	
	LD 		CD
	ST 		MEMCD

	(* Check for simultaneous posedges on *)
	LD		CUEDGE
	AND		CDEDGE
	JMPC	l10
	
	(* ASSERT(!CUEDGE || !CDEDGE) *)

	(* Check if posedge on CU and we are in bounds *)
	LD		CUEDGE
	AND(	CV
	LT		16#7FFF
	)
	JMPCN	l2
	
	(* ASSERT(CUEDGE) *)
	(* Increment *)
	LD		CV
	ADD		1
	ST		CV
	
l2: 
    (* Check if posedge on CD and we are in bounds *)
	LD		CDEDGE
	AND(	CV
	GT		-32768
	)
	JMPCN	l10
	
	(* ASSERT(CDEDGE) *)
	(* Decrement *)
	LD		CV
	SUB		1
	ST		CV
	
	(* ASSERT(!CUEDGE && !CDEDGE) *)
	
l10:
	(* Up counter output *)
	LD		CV
	GE		PV
	ST		QU

	(* Down counter output *)
	LD		CV
	LE		0
	ST		QD
]]>
						</sourceCode>
						<images>
							<image name="ctudscheme.png" width="376" height="244">
								<![CDATA[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]]>
							</image>
							<image icon="true" name="ctud48.png" width="48" height="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAC5UlEQVRoge1YoZLbMBB92yns
gRRcZ2xWHtSZfEGKDxXHKCHH8wvHW3KHHFzSooLeF1yn6Ep7zAIBNcgHbEEkZ61IthS7OWea
N6ORJa1Xb61drSXgjDP+b5Cnn11jzPxv2USAaEvvhWOMrXrQsA2wSQ/eiJdW27iN04WGCJcL
nRTOBjw3WrfRJMlvAczF2F1RzBb2C2m6WgK4cegqAbwH8FO35wBufXJKZUYOzAwiQpLkDICU
yvZesoPYhXvxPPdKbQneOfrnuiwi5QDAkAcATpJ8z4ioRKaV3SmVLWRSG0/W+FN886gCa8J7
q+aSUyqr5AT5GueimDUmslbYGfnx4fIQNY3wkAcATtNV1QhxoVCMACx1HYIbIWvqEmgkb1B5
yMEGpOlqVBSzcjxZm66lLjZK7Pv8CFt/t401ARycRLtso7/TdCV3HUOGrPJaEDModb+UAYCp
rjmgHG6ADqARgNHjw2UfMVCaB2aGUlnbClTjnRPZeLKGcKPOMLtLgxFUFLOq0RoDSZJ/wG5p
AWCqk5sPrrHP2OWTd2jOJxWKYkZpupIBTUplIMqqjpAgnloTvhXtp18/3gAAkiQ34y5yT2g3
wBXsUCqjpkzsw9HOAU2nPGauFfGR2vWGKOyrtBkXS77RgKHh5H+nzwY8N6ptVPq3SSZ9+jwf
srMxE4jMj1utNlku6jzQBdyzTqOo8+/0QV+2R+xcSHQSolntviyzWGAHYtySyC+v5whZgThb
msiHjAfIb66vqudQFxr+LR3rxdI+zVwvQSeMYxW8+l7xrlZgc32125k+fWXRDsLFxy+gi/t2
QQu8mdbek217zPRB9FUk5c+SUhknSS4veiVsw9pixKfHp68V8lolNgZiSXQ13j2ZCGxpgMx0
TcpjJw25IvFhLwNvaybzLcQXqWUCLeTS1TRXCDdqGQ9Fh5u544OiLR3ayaV2FyTR13oeE2Su
3ZswNGO8K3AiMQAgMl8MbQXOGCz+ArhmepcGiq6VAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="CTU_UDINT" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Up counter (UDINT data type)</title>
						<descr>&lt;HTML&gt;(Same as CTU but with PV and CV of &lt;b&gt;UDINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTU_UDINT block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and sets the output Q when the accumulated value (CV) reaches the preset value (PV) value.&lt;br/&gt;
&lt;img src= ctuscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is equal to PV its value remains until a rising edge of R&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="CU" type="BOOL">
									<descr>Count-up on input rising edge</descr>
								</var>
								<var name="R" type="BOOL">
									<descr>Reset counter input</descr>
								</var>
								<var name="PV" type="UDINT">
									<descr>Preset value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Q" type="BOOL">
									<descr>Count-up output</descr>
								</var>
								<var name="CV" type="UDINT">
									<descr>Counter current value</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="CUEDGE" type="BOOL"/>
								<var name="MEMCU" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	
	LD 		CU
	ST 		MEMCU
	
	LD 		CUEDGE
	AND(	CV
	LT		16#FFFFFFFF
	)
	JMPCN	l1
	
	LD		CV
	ADD		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	GE		PV
	ST		Q
	

]]>
						</sourceCode>
						<images>
							<image icon="true" name="ctu48.png" width="48" height="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAACtUlEQVRoge2YoXLcMBCGf3UK
G3AF7YzFyoM6kye44KDiO3RHwu8VwluSQz5c0qKA5gnaKWppw2wQUIN7gC2w1ifLki3ZzkU3
9TfjsSWt17vWrtYyMDHxfyMc/WQbI6KntSYAIUrzXljGyDhHjemAaXT0Trw02hw21hCKEVsI
nRSTA89N5zKaJOktgJU2ts2yxdq8QcrdBsCNRVcB4BLAT9VeAbh1yeX5kuVARBBCIElSAiDy
fNm4yUxiG/fa9copVRq4tfSv1LEOlAMANh4AKEnShhNBhUwp2+b5cq0XtfOLR/zN7hyqQMrg
xqzZ5PJ8WclpxtdszrJFayHrxKzIv76/6aOmFYfxAEBS7qqGTwj5MgOwUWcfbjRZPhdAq/FM
FSG9HZByN8uyRXF+8chdG3WYFGjG/AxlvJvOcgJ7F9Ehy+gfKXf6qsPGCON4rRnGFKpflwGA
eagRvWZALW0zADOOfyn7aKoo+MLML05WF4NzQAuhUegy2KTTgSRJP6A+tXNV3FzYxj7jUE/e
o72eBOEzA3Pjge+09sPvH28BAEmS8rjNuAd0O2BL9t4cbR8wdJcXlAMxbSmZ4CQOTbKn5uQ/
pycHnpsqB/QE5TgfM2mpz8pGJCAEf7jVzpyJQfuBIdDIOlnR4E+JXm92RA4hpHUKBFt1eLNE
2gRbCAlLIdzy6hk+MxDmS1edCK0jFvn99VV17RtCcVUvG6QmS8U0Uf1ATAdefavsrmZgf311
WJk+fSWt7cXZxy8QZ/fdgga0n9fu09vmGPdB69OMrKUxASQsA8Y91nETlx6Xvk7KdcI/iYcY
MdR5+8O0xNYd0Ctdm/LQh/r8InHRqMDlmQS/C58QMnS1PcvHNtEx7suAP3PHRwR7GtvWq1pB
Tcaaz2Mi+Ld7G7E545yBE8kBAIH1IrYZmIiWf2FOAyn58r38AAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="CTU" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Up counter</title>
						<descr>&lt;HTML&gt;The CTU block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and sets the output Q when the accumulated value (CV) reaches the preset value (PV) value.&lt;br/&gt;
&lt;img src= ctuscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is equal to PV its value remains until a rising edge of R&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="CU" type="BOOL">
									<descr>Count-up on input rising edge</descr>
								</var>
								<var name="R" type="BOOL">
									<descr>Reset counter input</descr>
								</var>
								<var name="PV" type="INT">
									<descr>Preset value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Q" type="BOOL">
									<descr>Count-up output</descr>
								</var>
								<var name="CV" type="INT">
									<descr>Counter current value</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="CUEDGE" type="BOOL"/>
								<var name="MEMCU" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	
	LD 		CU
	ST 		MEMCU
	
	LD 		CUEDGE
	AND(	CV
	LT		16#7FFF
	)
	JMPCN	l1
	
	LD		CV
	ADD		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	GE		PV
	ST		Q
	

]]>
						</sourceCode>
						<images>
							<image name="ctuscheme.png" width="336" height="200">
								<![CDATA[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
Si8AAAAASUVORK5CYII=]]>
							</image>
							<image icon="true" name="ctu48.png" width="48" height="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAACtUlEQVRoge2YoXLcMBCGf3UK
G3AF7YzFyoM6kye44KDiO3RHwu8VwluSQz5c0qKA5gnaKWppw2wQUIN7gC2w1ifLki3ZzkU3
9TfjsSWt17vWrtYyMDHxfyMc/WQbI6KntSYAIUrzXljGyDhHjemAaXT0Trw02hw21hCKEVsI
nRSTA89N5zKaJOktgJU2ts2yxdq8QcrdBsCNRVcB4BLAT9VeAbh1yeX5kuVARBBCIElSAiDy
fNm4yUxiG/fa9copVRq4tfSv1LEOlAMANh4AKEnShhNBhUwp2+b5cq0XtfOLR/zN7hyqQMrg
xqzZ5PJ8WclpxtdszrJFayHrxKzIv76/6aOmFYfxAEBS7qqGTwj5MgOwUWcfbjRZPhdAq/FM
FSG9HZByN8uyRXF+8chdG3WYFGjG/AxlvJvOcgJ7F9Ehy+gfKXf6qsPGCON4rRnGFKpflwGA
eagRvWZALW0zADOOfyn7aKoo+MLML05WF4NzQAuhUegy2KTTgSRJP6A+tXNV3FzYxj7jUE/e
o72eBOEzA3Pjge+09sPvH28BAEmS8rjNuAd0O2BL9t4cbR8wdJcXlAMxbSmZ4CQOTbKn5uQ/
pycHnpsqB/QE5TgfM2mpz8pGJCAEf7jVzpyJQfuBIdDIOlnR4E+JXm92RA4hpHUKBFt1eLNE
2gRbCAlLIdzy6hk+MxDmS1edCK0jFvn99VV17RtCcVUvG6QmS8U0Uf1ATAdefavsrmZgf311
WJk+fSWt7cXZxy8QZ/fdgga0n9fu09vmGPdB69OMrKUxASQsA8Y91nETlx6Xvk7KdcI/iYcY
MdR5+8O0xNYd0Ctdm/LQh/r8InHRqMDlmQS/C58QMnS1PcvHNtEx7suAP3PHRwR7GtvWq1pB
Tcaaz2Mi+Ld7G7E545yBE8kBAIH1IrYZmIiWf2FOAyn58r38AAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="CTU_DINT" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Up counter (DINT data type)</title>
						<descr>&lt;HTML&gt;(Same as CTU but with PV and CV of &lt;b&gt;DINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTU_DINT block &lt;b&gt;counts up&lt;/b&gt; for each FALSE-to-TRUE transition of the input CU and sets the output Q when the accumulated value (CV) reaches the preset value (PV) value.&lt;br/&gt;
&lt;img src= ctuscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of R reset CV to 0&lt;/li&gt;
&lt;li&gt;rising edge of CU increments CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches PV the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is equal to PV its value remains until a rising edge of R&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="CU" type="BOOL">
									<descr>Count-up on input rising edge</descr>
								</var>
								<var name="R" type="BOOL">
									<descr>Reset counter input</descr>
								</var>
								<var name="PV" type="DINT">
									<descr>Preset value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Q" type="BOOL">
									<descr>Count-up output</descr>
								</var>
								<var name="CV" type="DINT">
									<descr>Counter current value</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="CUEDGE" type="BOOL"/>
								<var name="MEMCU" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		R
	JMPCN	l0
	
	LD		0
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD		CU
	ANDN 	MEMCU
	ST 		CUEDGE
	
	LD 		CU
	ST 		MEMCU
	
	LD 		CUEDGE
	AND(	CV
	LT		16#7FFFFFFF
	)
	JMPCN	l1
	
	LD		CV
	ADD		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	GE		PV
	ST		Q
	

]]>
						</sourceCode>
						<images>
							<image name="ctuscheme.png" width="336" height="200">
								<![CDATA[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
Si8AAAAASUVORK5CYII=]]>
							</image>
							<image icon="true" name="ctu48.png" width="48" height="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAACtUlEQVRoge2YoXLcMBCGf3UK
G3AF7YzFyoM6kye44KDiO3RHwu8VwluSQz5c0qKA5gnaKWppw2wQUIN7gC2w1ifLki3ZzkU3
9TfjsSWt17vWrtYyMDHxfyMc/WQbI6KntSYAIUrzXljGyDhHjemAaXT0Trw02hw21hCKEVsI
nRSTA89N5zKaJOktgJU2ts2yxdq8QcrdBsCNRVcB4BLAT9VeAbh1yeX5kuVARBBCIElSAiDy
fNm4yUxiG/fa9copVRq4tfSv1LEOlAMANh4AKEnShhNBhUwp2+b5cq0XtfOLR/zN7hyqQMrg
xqzZ5PJ8WclpxtdszrJFayHrxKzIv76/6aOmFYfxAEBS7qqGTwj5MgOwUWcfbjRZPhdAq/FM
FSG9HZByN8uyRXF+8chdG3WYFGjG/AxlvJvOcgJ7F9Ehy+gfKXf6qsPGCON4rRnGFKpflwGA
eagRvWZALW0zADOOfyn7aKoo+MLML05WF4NzQAuhUegy2KTTgSRJP6A+tXNV3FzYxj7jUE/e
o72eBOEzA3Pjge+09sPvH28BAEmS8rjNuAd0O2BL9t4cbR8wdJcXlAMxbSmZ4CQOTbKn5uQ/
pycHnpsqB/QE5TgfM2mpz8pGJCAEf7jVzpyJQfuBIdDIOlnR4E+JXm92RA4hpHUKBFt1eLNE
2gRbCAlLIdzy6hk+MxDmS1edCK0jFvn99VV17RtCcVUvG6QmS8U0Uf1ATAdefavsrmZgf311
WJk+fSWt7cXZxy8QZ/fdgga0n9fu09vmGPdB69OMrKUxASQsA8Y91nETlx6Xvk7KdcI/iYcY
MdR5+8O0xNYd0Ctdm/LQh/r8InHRqMDlmQS/C58QMnS1PcvHNtEx7suAP3PHRwR7GtvWq1pB
Tcaaz2Mi+Ld7G7E545yBE8kBAIH1IrYZmIiWf2FOAyn58r38AAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="CTD_UDINT" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Down counter (UDINT data type)</title>
						<descr>&lt;HTML&gt;(Same as CTD but with PV and CV of &lt;b&gt;UDINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTD_UDINT block &lt;b&gt;counts down&lt;/b&gt; for each FALSE-to-TRUE transition of the input CD and sets the output Q when the accumulated value (CV) reaches the 0 value.&lt;br/&gt;
&lt;img src= ctdscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of LD set CV to the value of PV&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches 0 the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is 0 its value remains 0 until a rising edge of LD&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="CD" type="BOOL">
									<descr>Count-down on input rising edge</descr>
								</var>
								<var name="LD" type="BOOL">
									<descr>Preset counter input</descr>
								</var>
								<var name="PV" type="UDINT">
									<descr>Preset value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Q" type="BOOL">
									<descr>Count-down output</descr>
								</var>
								<var name="CV" type="UDINT">
									<descr>Counter current value</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="CDEDGE" type="BOOL"/>
								<var name="MEMCD" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		LD
	JMPCN	l0
	
	LD		PV
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD 	CD
	ANDN 	MEMCD
	ST 		CDEDGE
	
	LD 		CD
	ST 		MEMCD
	
	LD 		CDEDGE
	AND(	CV
	GT		0
	)
	JMPCN	l1
	
	LD		CV
	SUB		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	LE		0
	ST		Q
	

]]>
						</sourceCode>
						<images>
							<image name="ctdscheme.png" width="336" height="200">
								<![CDATA[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]]>
							</image>
							<image icon="true" name="ctd48.png" width="48" height="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADBElEQVRoge1YvW7bMBD+WHRs
AthDA1Bbpg7NVDRP4Ayd2jeQJmdpZ79C9naJJ3nu0k4Zmido4KlZm40EmiEGnO7XQaJ8okiL
st2Yaf0BhCTyJN7H++GJwA47/N8Qnn5yjRHR39WmA4Qo1HviGCPrGjVsArbS0ZN4aj0bt3G6
UIxwudCjwo7AttGaRqXMhwDOHTIzACdKpVMASJLJCMCZTw7AtHweAPhm66F11lSCCEIIEBGS
ZAKXjB3ELkwBjB39w7KddpS7YXIDAIfLJjd7j1IpkgQNEp02Mg4pcwIwVio9PTq+xZ268OpQ
KnzqGDtHQc5rARtJMoFS6dKNzIuXr3+BiBof/vH9eZfPBMG36xeWmFTPIS4EAJAyP7tTF70k
AQD0yu4ZE+kBGLGxldFWshQWyAAEEpAy76Ewta3c9Oj41tyPymZjBndsNObQOpsBqK1wG4Jc
SOtspnXW7ydvhFKpANAvhwZMzJATVutjkYGW4aeUucliFNDCCRhcXx1ACAGzUkDh/xuKgR6A
Xuk+SxOI1lk1HhwDPjAX2ghY3hdwFJNceSCAgJT5KxT+HwrXpvcZwGV5f4hFrBgXrL1jUqSU
eY2EUqkwwWsQYgEfgRmA8fXVgZnM9LtkbywCtsyQyVXQOqtIFCufBqhb4MH+A9b9y+sUAzH9
Uhp0DmLjn7Hg3ymnqd5JFPEvJVeMW8A+jWjsejGCExCOa5RW4CsaGsRtVtga0RACbcpt1cXW
roVKhJLYjKWIgDKdewk4Kym/aNC0gXKtuP/wrrrflAVC0ZWEWUfX1foyUZEzi3KBqj7TH1HD
s8WpTMVk/v5t1bn/6SsBELyvDXsfv0DsXbYLWqD7Qe09/myP1fp+n9QJsHIYWmcEED/o5bDN
F5pifXLeGKJ5fSh5UejIj1VCY2BVJdYl756MFZTsg8SCpJGDtkKA5kKIfa4Xv4oGAT4PdyE2
97L5XBxc8qJlPBQrnMxtD6Iz09gqUG9VvCl7PiSEOXZfhtjIeC3wSGIAQMdCMDYL7BAt/gCj
bz7ec2bPQgAAAABJRU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="CTD_DINT" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Down counter (DINT data type)</title>
						<descr>&lt;HTML&gt;(Same as CTD but with PV and CV of &lt;b&gt;DINT&lt;/b&gt; data type)&lt;br/&gt;&lt;br/&gt;
The CTD_DINT block &lt;b&gt;counts down&lt;/b&gt; for each FALSE-to-TRUE transition of the input CD and sets the output Q when the accumulated value (CV) reaches the 0 value.&lt;br/&gt;
&lt;img src= ctdscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of LD set CV to the value of PV&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches 0 the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is 0 its value remains 0 until a rising edge of LD&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="CD" type="BOOL">
									<descr>Count-down on input rising edge</descr>
								</var>
								<var name="LD" type="BOOL">
									<descr>Preset counter input</descr>
								</var>
								<var name="PV" type="DINT">
									<descr>Preset value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Q" type="BOOL">
									<descr>Count-down output</descr>
								</var>
								<var name="CV" type="DINT">
									<descr>Counter current value</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="CDEDGE" type="BOOL"/>
								<var name="MEMCD" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		LD
	JMPCN	l0
	
	LD		PV
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD 	CD
	ANDN 	MEMCD
	ST 		CDEDGE
	
	LD 		CD
	ST 		MEMCD
	
	LD 		CDEDGE
	AND(	CV
	GT		-2147483648
	)
	JMPCN	l1
	
	LD		CV
	SUB		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	LE		0
	ST		Q
	

]]>
						</sourceCode>
						<images>
							<image name="ctdscheme.png" width="336" height="200">
								<![CDATA[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]]>
							</image>
							<image icon="true" name="ctd48.png" width="48" height="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADBElEQVRoge1YvW7bMBD+WHRs
AthDA1Bbpg7NVDRP4Ayd2jeQJmdpZ79C9naJJ3nu0k4Zmido4KlZm40EmiEGnO7XQaJ8okiL
st2Yaf0BhCTyJN7H++GJwA47/N8Qnn5yjRHR39WmA4Qo1HviGCPrGjVsArbS0ZN4aj0bt3G6
UIxwudCjwo7AttGaRqXMhwDOHTIzACdKpVMASJLJCMCZTw7AtHweAPhm66F11lSCCEIIEBGS
ZAKXjB3ELkwBjB39w7KddpS7YXIDAIfLJjd7j1IpkgQNEp02Mg4pcwIwVio9PTq+xZ268OpQ
KnzqGDtHQc5rARtJMoFS6dKNzIuXr3+BiBof/vH9eZfPBMG36xeWmFTPIS4EAJAyP7tTF70k
AQD0yu4ZE+kBGLGxldFWshQWyAAEEpAy76Ewta3c9Oj41tyPymZjBndsNObQOpsBqK1wG4Jc
SOtspnXW7ydvhFKpANAvhwZMzJATVutjkYGW4aeUucliFNDCCRhcXx1ACAGzUkDh/xuKgR6A
Xuk+SxOI1lk1HhwDPjAX2ghY3hdwFJNceSCAgJT5KxT+HwrXpvcZwGV5f4hFrBgXrL1jUqSU
eY2EUqkwwWsQYgEfgRmA8fXVgZnM9LtkbywCtsyQyVXQOqtIFCufBqhb4MH+A9b9y+sUAzH9
Uhp0DmLjn7Hg3ymnqd5JFPEvJVeMW8A+jWjsejGCExCOa5RW4CsaGsRtVtga0RACbcpt1cXW
roVKhJLYjKWIgDKdewk4Kym/aNC0gXKtuP/wrrrflAVC0ZWEWUfX1foyUZEzi3KBqj7TH1HD
s8WpTMVk/v5t1bn/6SsBELyvDXsfv0DsXbYLWqD7Qe09/myP1fp+n9QJsHIYWmcEED/o5bDN
F5pifXLeGKJ5fSh5UejIj1VCY2BVJdYl756MFZTsg8SCpJGDtkKA5kKIfa4Xv4oGAT4PdyE2
97L5XBxc8qJlPBQrnMxtD6Iz09gqUG9VvCl7PiSEOXZfhtjIeC3wSGIAQMdCMDYL7BAt/gCj
bz7ec2bPQgAAAABJRU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="CTD" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Down counter</title>
						<descr>&lt;HTML&gt;The CTD block &lt;b&gt;counts down&lt;/b&gt; for each FALSE-to-TRUE transition of the input CD and sets the output Q when the accumulated value (CV) reaches the 0 value.&lt;br/&gt;
&lt;img src= ctdscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;rising edge of LD set CV to the value of PV&lt;/li&gt;
&lt;li&gt;rising edge of CD decrements CV by 1&lt;/li&gt;
&lt;li&gt;when CV reaches 0 the output Q is set&lt;/li&gt;
&lt;li&gt;once CV is 0 its value remains 0 until a rising edge of LD&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="CD" type="BOOL">
									<descr>Count-down on input rising edge</descr>
								</var>
								<var name="LD" type="BOOL">
									<descr>Preset counter input</descr>
								</var>
								<var name="PV" type="INT">
									<descr>Preset value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Q" type="BOOL">
									<descr>Count-down output</descr>
								</var>
								<var name="CV" type="INT">
									<descr>Counter current value</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="CDEDGE" type="BOOL"/>
								<var name="MEMCD" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(*	Check for reset input *)
	LD		LD
	JMPCN	l0
	
	LD		PV
	ST		CV
	JMP		l1

	(*	Check for increment enable *)
l0:
	LD 		CD
	ANDN 	MEMCD
	ST 		CDEDGE
	
	LD 		CD
	ST 		MEMCD
	
	LD 		CDEDGE
	AND(	CV
	GT		-32768
	)
	JMPCN	l1
	
	LD		CV
	SUB		1
	ST		CV
	
l1:

	(*	Counter output	*)
	LD		CV
	LE		0
	ST		Q
	

]]>
						</sourceCode>
						<images>
							<image name="ctdscheme.png" width="336" height="200">
								<![CDATA[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]]>
							</image>
							<image icon="true" name="ctd48.png" width="48" height="48">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAADBElEQVRoge1YvW7bMBD+WHRs
AthDA1Bbpg7NVDRP4Ayd2jeQJmdpZ79C9naJJ3nu0k4Zmido4KlZm40EmiEGnO7XQaJ8okiL
st2Yaf0BhCTyJN7H++GJwA47/N8Qnn5yjRHR39WmA4Qo1HviGCPrGjVsArbS0ZN4aj0bt3G6
UIxwudCjwo7AttGaRqXMhwDOHTIzACdKpVMASJLJCMCZTw7AtHweAPhm66F11lSCCEIIEBGS
ZAKXjB3ELkwBjB39w7KddpS7YXIDAIfLJjd7j1IpkgQNEp02Mg4pcwIwVio9PTq+xZ268OpQ
KnzqGDtHQc5rARtJMoFS6dKNzIuXr3+BiBof/vH9eZfPBMG36xeWmFTPIS4EAJAyP7tTF70k
AQD0yu4ZE+kBGLGxldFWshQWyAAEEpAy76Ewta3c9Oj41tyPymZjBndsNObQOpsBqK1wG4Jc
SOtspnXW7ydvhFKpANAvhwZMzJATVutjkYGW4aeUucliFNDCCRhcXx1ACAGzUkDh/xuKgR6A
Xuk+SxOI1lk1HhwDPjAX2ghY3hdwFJNceSCAgJT5KxT+HwrXpvcZwGV5f4hFrBgXrL1jUqSU
eY2EUqkwwWsQYgEfgRmA8fXVgZnM9LtkbywCtsyQyVXQOqtIFCufBqhb4MH+A9b9y+sUAzH9
Uhp0DmLjn7Hg3ymnqd5JFPEvJVeMW8A+jWjsejGCExCOa5RW4CsaGsRtVtga0RACbcpt1cXW
roVKhJLYjKWIgDKdewk4Kym/aNC0gXKtuP/wrrrflAVC0ZWEWUfX1foyUZEzi3KBqj7TH1HD
s8WpTMVk/v5t1bn/6SsBELyvDXsfv0DsXbYLWqD7Qe09/myP1fp+n9QJsHIYWmcEED/o5bDN
F5pifXLeGKJ5fSh5UejIj1VCY2BVJdYl756MFZTsg8SCpJGDtkKA5kKIfa4Xv4oGAT4PdyE2
97L5XBxc8qJlPBQrnMxtD6Iz09gqUG9VvCl7PiSEOXZfhtjIeC3wSGIAQMdCMDYL7BAt/gCj
bz7ec2bPQgAAAABJRU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="R_TRIG" version="1.0.1" creationDate="0" lastModifiedDate="0">
						<title>Rising edge detector</title>
						<descr>&lt;HTML&gt;The output Q will remain FALSE as long as the input variable CLK is FALSE.&lt;br&gt;
As soon as CLK returns TRUE, Q will first return TRUE.&lt;br&gt;&lt;br&gt;
This means each time the function is called up, Q will return FALSE until CLK has falling edge followed by an rising edge.&lt;br&gt;&lt;br&gt;
&lt;img src= r_trig.png&gt;</descr>
						<vars>
							<inputVars>
								<var name="clk" type="BOOL">
									<descr>Input for edge detection</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="q" type="BOOL">
									<descr>Raising edge output</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="m" type="BOOL">
									<initValue>FALSE</initValue>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	LD		clk
	ANDN	m
	ST		q

	LD		clk
	ST		m
]]>
						</sourceCode>
						<images>
							<image name="r_trig.png" width="218" height="117">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAANoAAAB1CAYAAAAoV//gAAAAAXNSR0IArs4c6QAAAARnQU1B
AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjAuMjHxIGmVAAAD2ElEQVR4Xu3awXHTTBiA4bRAAVxogSNXWmDogAZoghtnWmBohRL4
S6CAn4OZj2iJIinSOrY/fxbPM7NJbCnJMrvvSHa4OwAXJzRIIDRIIDRIIDRIIDRIIDRIIDRI
IDRIIDRIIDRIIDRIIDRIUD60u7u7PwNumdAgQekd3CITG7dOaJCg7O6dRtYG3CKhQYLyO1dg
7IHQIIHQIIHQIIHQIIHQIIHQIIHQIIHQIIHQIIHQThDTqjaoqfzSCO24QU3ll+YWQqug0lyY
K780QutTaS7MlV8aofWpNBfmyi+N0PpUmgtz5ZdGaH0qzYW58ksjtD6V5sLcUUvz/fvDgsZ4
82Y4MIjnPn8eHky8fHk4fPw4PBh8+3b/Pe/fD08sEFqfSnNhrntpWhTjkCK0cWzT42PT0Fq0
0/imhNan0lyY616apStSiyUiDPF1b2hx7lZkQWh9Ks2Fua6lmQb1lDinJ7T4eu12cUxofSrN
hbmupWm3jRHcmjhnK7Tp7eYWofWpNBfmupbmXKG1zTC9jVwjtD6V5sJc19Kc69axbYTenxeE
1qfSXJjrXpq43Vt6XRWL2+Iafz01vYrFeXH+9lVSaD0qzYW57qVpt4/jkCK+CKiZHh9bul2c
fv8SofWpNBfmjlqaFlsb0zc1xsfaaFfBpdBCnLMWWwut/byKo4KleRmPxzVd+ddvE1qfpXkZ
j8c1XfnXb2uhwS0TGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQ
GiQQGiQQ2iliXkbtUUSdmTxBaMZJo4g6M3nCTYQGG4R2CqHRSWinEBqd8nbJz5+Hw4cPD5sz
Rjz+8WM4YZnQ2IOcXRIxvXp1OLx9+xBWfI7HL16sxiY09iBnl7x7dx9aXNWm4vnXr4cHj/wX
H4TGHlx+l8TVKjZj3CYu+fTp/vjDVe3/4fOv+CA09uDyu+Tr1/vN+OXL8MTExnGhsQeX3yXt
ihVBLWmhxXkLhMYeXH6XCA3cOp4k5lV1bpRy+V1y/JshjwiNPcjZJc97e/8PobEHObskrlbT
P1hHdP5gzT8ib5cs/ResGBHbCqGxB9fdJe31Wdw6br1Gqzxgw/V3SbzrOL6lnBAae1B+l/wN
DW6Y0CCB0CCB0CCB0CCB0CCB0CCB0CCB0CCB0GDFufaf0GBF23+n7sOL7eDpBA1jT+NYQjOM
Z4xjXSy0c3nuPwzOYRzXKftQaLDiXPtPaJBAaJBAaJBAaJBAaJBAaJBAaJDADoYEQoMEQoME
QoMEQoMEQoMEQoMEQoMEQoMEQoMEQoOLOxx+A+X2Hit+emmnAAAAAElFTkSuQmCC]]>
							</image>
							<image icon="true" name="rtrig34.png" width="34" height="34">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAApklEQVRYhe2VUQrEIAxEZ0pP
Vw/V9VA9X/qzLYvUNrGWTSEPBJEYhzFGIAiC4B4UEUUUa0GEZr+CoUuWDliF8Dv+LuQx7EI6
1UTJix15CDdCxp8eQQBH8zMEND+iw3PcOFJtmVVE0ODCJY4cUfQFptyjeVCWGUwZssxbXmxr
bhwZjfEtxaFy87WO7PerhSmr4tw4EkJKiOlj+WvYUCNlHt9/TRBcsQJT/izAApTRbQAAAABJ
RU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="F_TRIG" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Falling edge detector</title>
						<descr>&lt;HTML&gt;The output Q remain FALSE as long as the input variable CLK returns TRUE.&lt;br&gt;
As soon as CLK returns FALSE, Q will first return TRUE.&lt;br&gt;&lt;br&gt;
This means each time the function is called up, Q will return FALSE until CLK has a rising followed by a falling edge.&lt;br&gt;&lt;br&gt;
&lt;img src= f_trig.png &gt;</descr>
						<vars>
							<inputVars>
								<var name="clk" type="BOOL">
									<descr>Input for edge detection</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="q" type="BOOL">
									<descr>Falling edge output</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="m" type="BOOL">
									<initValue>FALSE</initValue>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	LDN		clk
	AND		m
	ST		q

	LD		clk
	ST		m
]]>
						</sourceCode>
						<images>
							<image name="f_trig.png" width="218" height="117">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAANoAAAB1CAYAAAAoV//gAAAAAXNSR0IArs4c6QAAAARnQU1B
AACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5l
dCA0LjAuMjHxIGmVAAAEDUlEQVR4Xu3awXHUShCAYadAAFxIgSNXUqDIgARIghtnUqBIhRAg
BAJ477BUYw2WJbEa2atW79b3VY3t9S72oNZfkg13J2B3QoMEQoMEQoMEQoMEQoMEQoMEQoME
QoMEQoMEQoMEQoMEQoME5UO7u7v7s+CaCQ0SlD6DW2Ri49oJDRKUPXunkbUF10hokKD8mSsw
boHQIIHQIIHQIIHQIIHQIIHQIIHQIIHQIIHQIIHQniG2VW1RU/nRCG3boqbyo7mG0CqotBfm
yo9GaH0q7YW58qMRWp9Ke2Gu/GiE1qfSXpgrPxqh9am0F+bKj0ZofSrthblNo/n+/WGgsd68
GZ4YxOc+fx4eTLx8eTp9/Dg8GHz7dv9n3r8fPrFAaH0q7YW57tG0KMYhRWjj2KbPj01Da9FO
45sSWp9Ke2GuezRLV6QWS0QY4uPe0OK1a5EFofWptBfmukYzDepf4jU9ocXH524Xx4TWp9Je
mOsaTbttjODOideshTa93VwjtD6V9sJc12guFVo7Gaa3kecIrU+lvTDXNZpL3Tq2E6H36wWh
9am0F+a6RxO3e0s/V8VwW1zjj6emV7F4Xbx+/SoptB6V9sJc92ja7eM4pIgvAmqmz48t3S5O
//wSofWptBfmNo2mxdbW9Jca4+faalfBpdBCvOZcbC209vUqrgqW9mU9Xkc6+NuvE1qfpX1Z
j9eRDv7261pocM2EBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgmEBgmE
BgmEBgmEdkviOFn/Xgc69rt3ENoG45PKmq8DHfvdOwhtgwInFMuEdkuEVpbQbonQysqbyq9f
p9OHDw8nQ6x4/OPH8IJlQtugHVfKyZlKxPTq1en09u1DWPE+Hr94cTY2oW0gtLJypvLu3X1o
cVWbis+/fj08eORnvBHaBkIra/+pxNUqhh+3iUs+fbp//uGq9t/w/v94I7QN4jg5ViXtP5Wv
X++H/+XL8ImJleeFtkEcJ8eqpP2n0q5YEdSSFlq8boHQNojj5FiVtP9UhJYnjpNjVdL+U1m5
NVx7XmgbxHFyrErafyrbfxnyiNA2iOPkWJWUM5Wn/Xr/D6FtILSycqYSV6vpP1hHdP7B+rKE
VlbeVJb+C1asiO0MoW3QjinlHDuV9vNZ3Dqu/Yxm9S/KOX4q8VvH8S3lhNCesCin/FT+hgZX
TGiQQGiQQGiQQGiQQGiQQGiQQGiQQGiQQGhwxqXOP6HBGe38e+55uNsZPN2gZd3S2kpolvWE
tdVuoV3KU/9icAnjuJ5zHgoNzrjU+Sc0SCA0SCA0SCA0SCA0SCA0SCA0SOAMhgRCgwRCgwRC
gwRCgwRCgwRCgwRCgwRCgwRCgwRCg92dTr8BUO8SN3cafNMAAAAASUVORK5CYII=]]>
							</image>
							<image icon="true" name="ftrig34.png" width="34" height="34">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAqElEQVRYhe2VYQqAIAyF34tO
V4eqDtX51o9aRJQ5S1iwDwQR3R5vToEgCIJ3UEQqROVdUELzkcAhd/O9ijJsQsh1GE5s42Mh
FbELsd6pzP0/dqQSboRQAC0icT0vR2TtmNS7suVx5YgL3DjS5vQ5+6nUOMo8gP0EmQeNBV0D
sM8dOWIj96MxO/hbR/Zap9D6W3DjSAg5Q3Sj5a9h5h1Jdc1lHjeOBMETC4IUMr87wVtwAAAA
AElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="SR" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Bistable, set dominant</title>
						<descr>&lt;HTML&gt;Bistable, set dominant&lt;/br&gt;&lt;/br&gt;
&lt;img src= srscheme.png &gt;</descr>
						<vars>
							<inputVars>
								<var name="s1" type="BOOL">
									<descr>Logic input</descr>
								</var>
								<var name="r" type="BOOL">
									<descr>Reset input</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="q1" type="BOOL">
									<descr>Bistable output</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[	
	LDN		r
	AND		q1
	OR		s1
	ST		q1
]]>
						</sourceCode>
						<images>
							<image name="srscheme.png" width="290" height="146">
								<![CDATA[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]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="RS" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Bistable, reset dominant</title>
						<descr>&lt;HTML&gt;Bistable, reset dominant&lt;/br&gt;&lt;/br&gt;
&lt;img src= rsscheme.png &gt;</descr>
						<vars>
							<inputVars>
								<var name="s" type="BOOL">
									<descr>Logic input</descr>
								</var>
								<var name="r1" type="BOOL">
									<descr>Reset input</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="q1" type="BOOL">
									<descr>Bistable output</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	LD		s
	OR		q1
	ANDN	r1
	ST		q1
]]>
						</sourceCode>
						<images>
							<image name="rsscheme.png" width="290" height="146">
								<![CDATA[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]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="TP" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Pulse generator</title>
						<descr>&lt;HTML&gt;Pulse generator&lt;/br&gt;&lt;/br&gt;
&lt;img src= ptscheme.png &gt;</descr>
						<vars>
							<inputVars>
								<var name="IN" type="BOOL">
									<descr>Timer input source</descr>
								</var>
								<var name="PT" type="UDINT">
									<descr>Preset time value</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Q" type="BOOL">
									<descr>Pulse output</descr>
								</var>
								<var name="ET" type="UDINT">
									<descr>Actual timer value</descr>
								</var>
							</outputVars>
							<externalVars>
								<var name="sysTimer" type="UDINT">
									<descr>1 ms system timer</descr>
								</var>
							</externalVars>
							<localVars>
								<var name="timStart" type="UDINT">
									<descr>Time value at start of counting</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(*	Check if in counting	*)

	LD		Q
	JMPCN	l10
	
	(*	Update actual time *)
	LD		sysTimer
	SUB		timStart
	ST		ET	
	
	(*	Update output *)
	LD		ET
	LT		PT
	ST		Q
	RET
	
l10:

	(*	Check for input status *)

	LD		IN
	JMPCN	l11
	
	LD		ET
	GE		PT
	RETC

	LD		sysTimer
	ST		timStart
	
	LD		TRUE
	ST		Q
	
l11:
	
	(*	No input and no counting active *)
	LD		0
	ST		ET
	

]]>
						</sourceCode>
						<images>
							<image name="ptscheme.png" width="265" height="146">
								<![CDATA[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]]>
							</image>
							<image icon="true" name="tp34.png" width="34" height="34">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAACIAAAAiCAYAAAA6RwvCAAAAxklEQVRYhe2Waw6EIAyEp8bT
6aFwD8X5un/MRqBkYB+mm/RLjLFaKENbBIIgCD5DVNWwimE0UJWv+AFYhhxvYCXvm8hP2Mqn
/f5GEcDOIT7ypJ8bRSKQmvVS+4I6q619vtLrG+N+rzndKDLYCn+PG0UWqOKOS7ajuNc2s6HJ
/mh2THOiXczyAyCaE1WEd1Z7wuJZc2pss7AcMVUYWOHAGVDyliJAGwxThQXvqGqc4CYQwXZ0
zxrNSTolycflf3HFd24UCQLGE7KZdlKKljJmAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="TON" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>On-delay timer</title>
						<descr>&lt;HTML&gt;The TON block produces a delayed output Q of the input IN. The delay time is expressed in milliseconds on the PT input.&lt;/br&gt;&lt;/br&gt;
&lt;img src= tonscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;if IN is FALSE Q is false&lt;/li&gt;
&lt;li&gt;Q becomes TRUE as IN remains TRUE for PT milliseconds&lt;/li&gt;
&lt;li&gt;Q remains TRUE until IN remains TRUE&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="IN" type="BOOL">
									<descr>Timer input source</descr>
								</var>
								<var name="PT" type="UDINT">
									<descr>Preset time value (ms)</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Q" type="BOOL">
									<descr>Timer output</descr>
								</var>
								<var name="ET" type="UDINT">
									<descr>Timer current value (ms)</descr>
								</var>
							</outputVars>
							<externalVars>
								<var name="sysTimer" type="UDINT">
									<descr>1 ms system timer</descr>
								</var>
							</externalVars>
							<localVars>
								<var name="timStart" type="UDINT">
									<descr>Time value at start of counting</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(*	Check if in counting	*)

	LD		IN
	JMPCN	lReset

	(*	Check if Q is TRUE *)
	LD		Q
	RETC
	
	(*	Check if already in counting *)
	LD		timStart
	EQ		0
	JMPCN	lUpdate

	(*	Start of counting *)
	LD		sysTimer
	ST		timStart
	
lUpdate:

	(*	Update timer and check if time elapsed *)
	LD		sysTimer
	SUB		timStart
	ST		ET
	GE		PT
	ST		Q
	RETCN

	(*	Limit actual time value *)
	LD		PT
	ST		ET
	RET

lReset:

	(*	Reset status *)
	LD		0
	ST		ET
	ST		timStart
	LD		FALSE
	ST		Q

]]>
						</sourceCode>
						<images>
							<image name="tonscheme.png" width="230" height="146">
								<![CDATA[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
AAAAAElFTkSuQmCC]]>
							</image>
							<image icon="true" name="ton1.png" width="48" height="58">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAA6CAYAAAD2mdrhAAAD4klEQVRoge3YT4hVdRQH8M91
akhpIVOjmxYR1K4CIUTQyQYai3YWFVFtRPtjjNbCTUQgropqksqRqU1CloS0CjSw0EBECsqN
IESLNs0kTYvSjPG1+J3nez7nvfe7902TyvvC45537znfc869vz/nd+ijjz766KOPPvqojKLt
k2dvXwj+WgWbosmuIX/887yxLqkU1lWEGxbJT/sv3V2/o+01/wX6Cfzf6DQHrlwJLpevClzz
X6DtDK/V4kUXBfPJpbxUtLuMYv5Q2ydQ1kOPAXZDuwSu7yF02/DmxYzlCvwyM3VJbvcFFmon
vhEb8CDuwx1YGc9+xU84ia9wCP8skN+eE1iO7XgRw210VsZvDcbxG97HBGZ79N/THHgSp/G6
FPypkEcVxReXtJI8Gs9O4daQTwdHT6iSwAA+wH7pzR7DCO7BTnyNc0365+LeztAZwdGw3R9c
A9XCL5/AAA7gBZzH87g/kmigVntKWiCKkJtxDOvD9nxwHVAxibIJTGCjNHZHsVe10qIWtqP4
PTjfrcBTKoEn8JI0JB7C8SoOW3AcD+MvbA0fpZCbwHLsDvkVnCjrqAmbpLdfX9hP4OWQd4ev
bOQmsB0rpPG7t4yDFmzCFLZgsun+lDSxV4SvbOQkMCit8/Cq6uV0Pfh6SX6y6VktuIWvwVzS
nATGpHX+R62rTT5ag9+CD1t0vsUP4Wsslzg3ATiYS9qCnODrqPvYkEueU0qsiuvRTM5BvImn
cROWxf0aNuOjDrZ1H6s66FyGnATuAkUxjkcUS3a4OHexg/4bUs3Tis7BF8Un+CPOFXdmxJXM
2j1oKqdbJ223Hs9ZDLXc+xM3d7G7wk9OOb1YB5q//yvinARmkKrKongrQ3/fPPfaTdoGimK/
oqjvDTMZfpA3B85gWK22W6oqu2GHNMyeif/78FpXq1T0rZeKvDMZfpD3Bb6L67pMzgvYJs2D
oZAvZNqOxPX7TP2sBA7H9dFc0h6wscVnV+QmcFY6jKytEFQu1uJeafwfyjXKSeAC3gt5l/Kt
8hwUwU06oeUOuexldALT0unruVKh5WFTcM+Er2zkJjCrsbu+jdVlnHTBao3T2LiSnYoyG9ln
UjtkKb6U2iS9Yk1wLQvuT8sSlN2Jt0kV4xCOSMOpypwowvZIcB0M7tIom8AcHsceqdKcxDda
94hUmNVQC7kZ66QNcTI49gTnXMlYUK0zNyedmo5KY7fe5zmFz6VDz9Im/aV4IAJ/DHfH/Wnp
rZceNs3otbm7XDqQb8UtmT7PSuP9HV0m7GI0d2elNuEu6RQ1ptHcXRE60xrN3cPxy17n++ij
j+sc/wLOpNwgfFLcXQAAAABJRU5ErkJggg==]]>
							</image>
						</images>
					</functionBlock>
					<functionBlock name="TOF" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<title>Off-delay timer</title>
						<descr>&lt;HTML&gt;The TOF block produces a delayed de-activation of the output Q with respect of the input IN. The delay time is expressed in milliseconds on the PT input.&lt;/br&gt;&lt;/br&gt;
&lt;img src= tofscheme.png&gt;
&lt;ul&gt;
&lt;li&gt;if IN is TRUE then Q is TRUE&lt;/li&gt;
&lt;li&gt;Q becomes FALSE after PT milliseconds from IN becomes FALSE&lt;/li&gt;
&lt;li&gt;Q remains FALSE until IN remains FALSE&lt;/li&gt;
&lt;/ul&gt;</descr>
						<vars>
							<inputVars>
								<var name="IN" type="BOOL">
									<descr>Timer input source</descr>
								</var>
								<var name="PT" type="UDINT">
									<descr>Preset time value (ms)</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Q" type="BOOL">
									<descr>Timer output</descr>
								</var>
								<var name="ET" type="UDINT">
									<descr>Timer current value (ms)</descr>
								</var>
							</outputVars>
							<externalVars>
								<var name="sysTimer" type="UDINT">
									<descr>1 ms system timer</descr>
								</var>
							</externalVars>
							<localVars>
								<var name="timStart" type="UDINT">
									<descr>Time value at start of counting</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="IL">
							<![CDATA[
	(*	Check if in counting	*)

	LD		IN
	JMPC	lReset

	(*	Check if falling edge of IN	*)
	LD		Q
	RETCN

	(*	Check if already in counting *)
	LD		timStart
	EQ		0
	JMPCN	lUpdate
	
	(*	Start of counting *)
	LD		sysTimer
	ST		timStart

lUpdate:
	
	(*	Update timer and check if time elapsed *)
	LD		sysTimer
	SUB		timStart
	ST		ET
	GE		PT
	STN		Q
	RETCN
	
	(*	Limit actual time value *)
	LD		PT
	ST		ET
	RET

lReset:

	(*	Reset status *)
	LD		0
	ST		ET
	ST		timStart
	LD		TRUE
	ST		Q

]]>
						</sourceCode>
						<images>
							<image name="tofscheme.png" width="243" height="146">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAAPMAAACSCAYAAACQXvzAAAAIkklEQVR4nO3d/23bRhjG8eeK
LuCMkABdwBohHSAGYsAdIBkhBvp3gXiEeoAacAF3gHoEaYECyQjxCNc/KEoULUpH8u54fPn9
AEJC0aLIEx+9/KWjBAAAACAy1zXCe5/uTZ2rJ+5Svg8wF851RjHYTxHmYzDvfZSFADBBmBtV
+eD/AMaZtDLXqM7AeFnD3FGJqc5ABEVUZgDj/Zz5/ertad8aBjBS1jDXp6Ga+8icmgLiYDMb
MIIwA0YQZsAIwgwYQZgBIwgzYARhXgoumTWv33lm5y4kfZX0qfHsvaQ7ef894nwNZ/3HG973
S2WzPQj0Xt92DOGcNOF1E+GV2bm3ktaS3kp6t22Md9vh9XY8YINz4Y9ChHdO4NyjpEtJK3n/
0hr3TdKLvF8FvWnKzgka04474clVy3Wuorxeuay2x1Dx26Neh0dU5nydE1RV96Ok51dBrtxL
uqQ6Y/a87/8oROg+8+X2303H+Hp/+b2qYJehoIYerc83d3O5m6+z1B5DGW6P0H3muuIeq8pN
FyPmBcAInJoCjAgNc70Zfa7ynqvcABIJDXO9r3zZMb7eDH8eNzsAhrJ9asrSAY56uUJOTR0e
ALPZHkOlbI9ZnJqq3G7/fdydgnLuQs79q2rz+3r03AAYLDzM1eWaK1X7z9+233A/VJ2O2hRz
OSewUP2OZnv/Iu8/y3u3e1QV+72c45JOYELjT015f6dqE5sj2cCE7N04zuoBHw6AxVFoe8z+
xnEA4rEb5oK+dbEg7Qp7bjii3He0OOAlX9LvQWchpPMF2jTE8HWv3tVpb7LXw84dDmf6+emk
YQYWI8MX7KRhdpLNPn7SfHDzKbclbhnsd7vGz9x++Vzrue7hDOxW5vYKNXYf+tQK2vX7YQyX
45hHzuMqGd5r+jDP5UBV6HzOZXlSKrkNSp63kewezQYWhjADRhBmwAjCDBhBmAEjCDNgBGEG
jCDMgBGEGTCCMANGdF7O6R6uvqi6F3Pbi6r7Se1766xuKnfKxt88BXXDC2CYkGuzryX93Rj+
pCrkl5J+1esudteS3vqbpzdR5hBAkCE/tLhX1U/2V1Xd7A6+i8V6vfabzcGNJd1qtToY3xy5
Wq0OfpLUHq/XPzmL+vrm+NVqNer1fcev/vtDY6x/+b391GzaasjrLy8vD8ZvNhsvjW/H3Zvd
PFW/cXy48n2GUxq6z1z3kd11uxpEFGsFXDrr7Tj0J5B1/9hd92sOslqtXvXO2Rp2J8a9Gn9E
1Ncfmdbg14eOr7/ZA//+mLoiOX/zFDwvJbVVjLZuBXn3t2fa5Kx2xT03nNKQyvxR0hdVQeZG
cQlFCDK0nHYMqcyPR5670/5oNhLoWgH7VhL3cBX8N2OrVIliteMchFTma1WN0HwQ5IROrYAh
4ez5XieH5yxnO5aAi0YKk7OSNFdoa5VqSRW5RpgLQpDjWGKQJcJcDIIcx1KDLBHmIpQU5Dmv
9EsOsnTiaLa/ebpTddS6L67B7uHYCphq5VvaUWuLy3kKlXlCSzn/mRrtWCHME5lqk9BatVr6
pnWTvZutz0BzBWxckJ9qH3nf1sZW8JztmFqMm60T5syOrYAJ30va/5rIVJhztmMOMcLMZnZG
OfftLF7hVGMf+bhJw7ykqtyuJDn2jS1V4lrudjwzL6OGY6MyZ0AliYN2PG3am607J/31oXO8
hcrCChhHqnaMUS2b0zg2vVy7PFTmI2I1PkGOg3YMw9HsllhXSZVy/nPup6ZKacfUOJodWeqK
bGkFbC1jjvcw2Y4xEeatWL8kWsIKSJDLRJhFkPsgyOWa9Gh2CWJd/tdeAS2ueFME2WI7prLo
ysxR63BTVmSEGXKvqdq1qm53Z3mfKYIc7sgy+u3z0TZ9l9COqQ2511RT+/m1qg7y35S8ecQ+
crgcIVtCO+awuM1sghyOIM/LosJMkMPlWMYltGNOiwkzQQ5HkOcpJMyPqg54NB+nDowVhyCH
I8jzNfYAWPEIcjiCPG/TXjTy1wefs0eMGO814y5qgtu6xzIO/vxm3I7BcvdHtph95hiWsALm
WMYltOMUpq3Mv/3jTnVOUIL6m9U9XL36eeSYSt/8xk7cOX2K4BDGALl3HRZ/bfY5qXqOODVd
9h8xxNCbrUvVPZqH3L7mACtuWinal8+sTPQ0AhSAnkYA7BBmwAjCDBhBmAEjCDNgBGEGjCDM
gBHmrgBzTklPXHs/r0sZ+7RH6LLFaOO5teMcUJkBIzrD7JwunJN3bn85p3N63D73qeM1P5zT
OsWM9uW93Pbbf9SjMZ2iOXf4aKuXo6NNdtM4Nc0j0z7bbu3HsWmnlOM9SjG0Mn91ThdR5wSD
NFdW7/ePsdNbSgAsGRrmC0l/xpyRVJor+JBHSY4Fbci8nlrG5nMhbTKm3XK0cYmfYypDw3wv
6WPX5jbSKPVLBmUYGuZbSRtJX9jcBsow5mj2raq7V8xicxv9UP3nZ3CYvdez2NyeDQ5q2Tfq
PLP3+izpu9jcBiYX46KRz6o2t2fVMf4Ssels2+jLOb3Xs3O6l9jUBqYU5XLOxuY2gInEvDb7
NuK0APRkrnfO+hc9sa+nTjXd1Bq/cHJdTR3yN2P+PtZrLaN3TgA7hBkwYuLOCbyf24UMqTs/
mFjOz2N2n329i9Xe5eoaVmtXwrm0pwepzIARE1dm55So0I39FjxSNWZWR3rJtmx9DyB2Ve/A
A3VRNabnQoZTzUcXKjNgxOQd+pV6eqLU+Uqh5GUdM2+lLFeu+aAyA0YQZsAIwgwYQZgBIwgz
YARhBowgzIARhBkwgjADRkx+BRiwJCk75qAyA9Pwzjkfo4eRWq9ugxrfKgDiGp1qKjNgRN99
5ljbBLv9hkjTA+aivXUbLQMcAAOmEb2Q9QpzrKNvzZ3+lF36AgU6GmK62gWwQ5gBIwgzYARh
BowgzIARhBkAAAAAAACm/Q+8ohpTstSuawAAAABJRU5ErkJggg==]]>
							</image>
							<image icon="true" name="tof1.png" width="48" height="58">
								<![CDATA[iVBORw0KGgoAAAANSUhEUgAAADAAAAA6CAYAAAD2mdrhAAAD50lEQVRoge3ZT4jVVRQH8M9P
a2ikxTDluHEV1a4CIURQs4HGop1FRdRq0P4Yai3cRATiqqgmqRyZWglNSUirQAOLMRCRgpqN
YLRy00xTtijNGF+Le57zfL437/5+b1KU94XH78y9537POb/fPfeee4ceeuihhx566KGHyija
dfy++u5ag04reUns5GLw7M8t25d1S3y9ccsifUWG3AlVvlYp3PBfoBfA9cZiObCUKJML7Va9
lrl3w3+BtitKrRaBFwWt5FJWKo67gqK1q+0DKGuhSwc7oV0AN/cUWr1y67X05SqcnZ24LLf7
Aku1Ct2KzXgED+IurIq+X/ELTuFrHMG/S2S36wAGsAsvY2UbnVXxW4cd+A0fYgznurTfVQ48
g9N4U3J+OuRhRfHlZa0kD0ffNO4M+XRwdIUqASzHR5iU3uxxbMT92INvcL5B/3y07QmdjZiK
sZPBtbya++UDWI5DeAkX8CIeiiAWUKs9Ky0QRciNOI5NMfZCcB1SMYiyAYxhizR3h3FAtZK5
FmOH8Udwvl+Bp1QAT+MVaUo8ihNVDDbhBB7D39geNkohN4AB7Av5NZwsa6gBo9Lbry/sJ/Fq
yPvCVjZyA9iFIWn+HihjoAmjmMA2jDe0T0iJPRS2spETQJ+0zsPrqh8T687XS+RTDX214Ba2
+nJJcwIYkdb5nzSvNvlodn4bPm7S+Q4/hq2RXOLcAOBwLmkTcpyvo25jcy55TimxJp5TmZx9
eBvP4TasiPYatuKTRcbWbaxZROcK5ARwLyiKHXhcsWy3S/OXFtF/S6p5mrG480XxKf6Mc8U9
GX6lYe06Gsrp5qTtdC80h8Gmtr9we4dxV9nJKaev1YHmn/+LOCeAWaSqsijeydA/2KKtXdIu
oCgmFUV9b5jNsIO8HDiDlWq1fVJV2Qm7pWn2fPx9EG90HJWKvk1SkXcmww7yvsD38dyQyXkR
O6U8GAz5YubYjfH8IVM/K4Cj8Xwil7QLbGmy2RG5AcxJh5H1FZzKxXo8IM3/I7mDcgK4iA9C
3msJ/lnRAkVwk05ouVMuexkdw4x0+nqhlGt5GA3u2bCVjdwAzlnYXd/F2jJGOmCthdPYDiVv
KspsZJ9L1yH9+Eq6JukW64JrRXB/Vpag7E68U6oYB3FMmk5VcqKIsceC63Bwl0bZAObxFPZL
leY4vtW8R6TCrIZayI3YIG2I48GxPzjnS/qCajdz89KpaUqau/V7nml8IR16+hv0+/FwOP4k
7ov2Gemtl542jej2cndAOpBvxx2ZNuek+f6eDgl7LS53z0nXhHulU9SIhcvdodCZsXC5ezR+
2et8Dz30cJPjP37X3iBpuO6PAAAAAElFTkSuQmCC]]>
							</image>
						</images>
					</functionBlock>
				</functionBlocks>
				<programs/>
				<macros/>
				<structs/>
				<typedefs/>
				<enums/>
				<subranges/>
				<interfaces/>
			</lib>
			<lib name="c:\program files (x86)\arduino plc ide\catalog\arduinoopta_1p2\arduinoopta\..\Libraries\AlDatabase.pll" fullXml="false" link="true">
				<![CDATA[(************************************************************************)
(*                                                                      *)
(*   TYPES                                                   			*)
(*                                                                      *)
(************************************************************************)

TYPE
	DBTABLE_RECORD : STRUCT
		{ HIDDEN:ON }
		ipa : UINT;			{ DE:"Index" }
		subi : UINT;		{ DE:"Subindex" }
		typePar : USINT;	{ DE:"Application type" }
		typeVar : USINT;	{ DE:"Variable type" }
		unused : UINT;		{ DE:"Spare" }
		address : DWORD;    { DE:"Address" }
		el : UDINT;			{ DE:"Number of elements" }
		attr : UDINT;		{ DE:"Flags" }
		def : UDINT;		{ DE:"Default" }
		min : REAL;			{ DE:"Min" }
		max : REAL;			{ DE:"Max" }
		scale : REAL;		{ DE:"Scale" }
		off : REAL;			{ DE:"Offset" }
	END_STRUCT;
	
	ALDATABASE_MENU_PAR_FLAGS_ENUM :  ( 	{ DE:"Menu parameter list flags" }
		PAR_ADDRESS_NONE := 0,				{ DE:"No parameter specified" }
		PAR_ADDRESS_DBTABLE_EXT_ID := 1,	{ DE:"ParAddress has the progressive id of the external DB table" }
		PAR_ADDRESS_DBTABLE_SYS_ID := 2,	{ DE:"ParAddress has the progressive id of the system DB table" }
		PAR_ADDRESS_DBTABLE_ADDRESS := 4,	{ DE:"ParAddress has the physical address of a DBTABLE record" }
		PAR_ADDRESS_CUSTOM_ADDRESS := 8		{ DE:"ParAddress point to user custom address" }
	);
	
	ALDATABASE_PARITEM : STRUCT
		{ HIDDEN:ON }
		flags : ALDATABASE_MENU_PAR_FLAGS_ENUM;	{ DE:"Flag" }
		ParAddress : DWORD;			{ DE:"Parameter address (value based on specified flag)" }
		pParName: @STRING;			{ DE:"Param Name" }
		pParDescription: @STRING;	{ DE:"Param Description" }
		pParFormat: @STRING;		{ DE:"Param Format" }
		pParUm: @STRING;			{ DE:"Param Um" }
	END_STRUCT;
	
	ALDATABASE_MENU : STRUCT
		{ HIDDEN:ON }
		id : UINT;						{ DE:"Menu ID" }
		numPars : UINT;					{ DE:"Number of parameters" }
		numSubMenus : UINT;				{ DE:"Number of sub menus" }
		reserved : UINT;				{ DE:"Reserved" }
		caption: @STRING;				{ DE:"Menu string address" }
		pSubMenu: @ALDATABASE_MENU;		{ DE:"Sub menu address" }
		pParList: @ALDATABASE_PARITEM;	{ DE:"Par list address" }
	END_STRUCT;
	
END_TYPE

(************************************************************************)
(*                                                                      *)
(*   GLOBAL VARIABLES                                                   *)
(*                                                                      *)
(************************************************************************)


VAR_GLOBAL
	
	{G:"System"}
	sysParameters 	AT %MW200.0 : ARRAY[ 0..511 ] OF WORD;	{ HIDDEN:ON }
	sysStatusVars 	AT %MW201.0 : ARRAY[ 0..511 ] OF WORD;	{ HIDDEN:ON }

END_VAR

(************************************************************************)    
(*                                                                      *)    
(*   EMBEDDED FUNCTIONS                                                 *)    
(*                                                                      *)    
(************************************************************************)   

FUNCTION sysDBase_SaveAll : BOOL
	{ DE:"Save parameters current values into database" }
	VAR_INPUT
		dummy   : BOOL;    { DE:"Dummy" }
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION sysDBase_SetExtTable : USINT
	{ HIDDEN:ON }
	{ DE:"Set extended database table" }
	VAR_INPUT
		ptrDB   : DWORD;    { DE:"Database Physical address" }
		numPars : UDINT;    { DE:"Number of parameters" }
		idxDatablockE2   : UINT;  { DE:"Index of datablock for E2 parameters" }
		ptrDatablockE2   : DWORD; { DE:"Address of datablock for E2 parameters" }
		numelemsDatablockE2  : UDINT; { DE:"Number of elements of datablock for E2 parameters" }
		datasizeDatablockE2  : USINT; { DE:"Size of an element of datablock for E2 parameters" }
		idxDatablockRAM  : UINT;  { DE:"Index of datablock for RAM parameters" }
		ptrDatablockRAM  : DWORD; { DE:"Address of datablock for RAM parameters" }
		numelemsDatablockRAM : UDINT; { DE:"Number of elements of datablock for RAM parameters" }
		datasizeDatablockRAM  : USINT; { DE:"Size of an element of datablock for RAM parameters" }
		extTableSignature : DWORD;	{ DE:"Signature to reset default value if something changed" }
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION sysDBase_SetExtMenus : BOOL
	{ HIDDEN:ON }
	{ DE:"Set extended database table" }
	VAR_INPUT
		ptrMenuIndex : DWORD; { DE:"Menus index physical address" }
		numMenus : UDINT;     { DE:"Number of parameters" }
	END_VAR
	{CODE:EMBEDDED}
END_FUNCTION

FUNCTION sysWriteParBOOL: BOOL
	{ DE:"Write BOOL to EEPROM. 
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : BOOL;   { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParUSINT: BOOL
	{ DE:"Write USINT to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 	
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : USINT;   { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParSINT: BOOL
	{ DE:"Write SINT to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 	
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : SINT;   { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParBYTE: BOOL
	{ DE:"Write BYTE to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 	
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : BYTE;   { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParINT: BOOL
	{ DE:"Write INT to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 	
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : INT;    { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParUINT: BOOL
	{ DE:"Write UINT to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 	
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : UINT;   { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParWORD: BOOL
	{ DE:"Write WORD to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 	
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : WORD;   { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParDINT: BOOL
	{ DE:"Write DINT to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : DINT;   { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParUDINT: BOOL
	{ DE:"Write UDINT to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 	
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : UDINT;   { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParDWORD: BOOL
	{ DE:"Write DWORD to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 	
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : DWORD;  { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParREAL: BOOL
	{ DE:"Write REAL to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParBOOL(ADR(EEPROMPARAMETER),NewValue); 	
" }
	VAR_INPUT
		address : DWORD;  { DE:"Address" }
		Value   : REAL;   { DE:"Value" }
	END_VAR
	{ CODE:EMBEDDED }
END_FUNCTION


FUNCTION sysWriteParSTRING : BOOL
	{ DE:"Write a STRING to EEPROM.
The function return a BOOL which could have the following meanings:
TRUE	=	Writing executed correctly.
FALSE	=	Writing not executed.

Example: bret:=sysWriteParSTRING(ADR(EEPROMPARAMETER),NewValue,10); 
" }
	VAR_INPUT
		id  : UDINT;  { DE:"Address" }
		msg : STRING; { DE:"String" }
		len : USINT;  { DE:"SIZEOF(String to write)" }		
	END_VAR
  {CODE:EMBEDDED}
END_FUNCTION
]]>
			</lib>
			<lib version="1.2" name="c:\program files (x86)\arduino plc ide\catalog\arduinoopta_1p2\arduinoopta\..\Libraries\AlModbusRTU.plclib" fullXml="true" link="true">
				<descr/>
				<libWorkspace>
					<folder name="AlModbusRTU">
						<folder name="Definitions">
							<folder name="Structures">
								<Definition name="MbMRtuNetList"/>
								<Definition name="MbMRtuStatus"/>
								<Definition name="MbRtuDiagnostics"/>
							</folder>
							<folder name="Enumeratives">
								<Definition name="MbBaudrate"/>
								<Definition name="MbChn"/>
								<Definition name="MbError"/>
								<Definition name="MbException"/>
								<Definition name="MbFunction"/>
								<Definition name="MbMode"/>
								<Definition name="MbParam"/>
								<Definition name="MbRqErr"/>
								<Definition name="MbStatus"/>
								<Definition name="MbRSMode"/>
							</folder>
						</folder>
						<Pou name="sysMbMRtu_FC01"/>
						<Pou name="sysMbMRtu_FC02"/>
						<Pou name="sysMbMRtu_FC03"/>
						<Pou name="sysMbMRtu_FC04"/>
						<Pou name="sysMbMRtu_FC05"/>
						<Pou name="sysMbMRtu_FC06"/>
						<Pou name="sysMbMRtu_FC15"/>
						<Pou name="sysMbMRtu_FC16"/>
						<Pou name="sysMbMRtu_GetMasterStatus"/>
						<Pou name="sysMbMRtu_GetSlaveHandle"/>
						<Pou name="sysMbMRtu_SlaveActivation"/>
						<Pou name="sysMbMRtu_GetSlaveStatus"/>
						<Pou name="sysMbMRtu_SetPostDelay"/>
						<GlobalVars name="ModbusVars">
							<folder name="Definitions">
								<Definition name="MbRtuDiagnostics"/>
								<Definition name="MbMRtuNetList"/>
								<Definition name="MbMRtuStatus"/>
							</folder>
						</GlobalVars>
						<Pou name="sysMbMRtu_Boot"/>
						<Pou name="sysMbMRtu_CloseChn"/>
						<Pou name="sysMbMRtu_NewBroadcastMessage"/>
						<Pou name="sysMbMRtu_NewSlaveMessage"/>
						<Pou name="sysMbMRtu_NewSlaveMessage2"/>
						<Pou name="sysMbMRtu_OpenChn"/>
						<Pou name="sysMbMRtu_SlaveAddToNetList"/>
						<Pou name="sysMbMRtu_SlavePrmInteger"/>
						<Pou name="sysMbMRtu_SlavePrmReal"/>
						<Pou name="sysMbMRtu_MemoryMapping"/>
						<Pou name="sysMbSRtu_Boot"/>
						<Pou name="sysMbSRtu_CloseChn"/>
						<Pou name="sysMbSRtu_OpenChn"/>
					</folder>
				</libWorkspace>
				<globalVars>
					<group name="ModbusVars">
						<var name="sysMbRtuDiagnostics" type="MbRtuDiagnostics" dim0="2">
							<descr>Modbus RTU standard diagnostics</descr>
							<address type="I" typeVar="B" index="60012" subIndex="0"/>
						</var>
						<var name="sysMbMRtuStatus" type="MbMRtuStatus">
							<descr>Modbus master RTU status</descr>
							<address type="I" typeVar="B" index="60010" subIndex="0"/>
						</var>
					</group>
				</globalVars>
				<retainVars>
					<group name="ModbusVars"/>
				</retainVars>
				<constantVars>
					<group name="ModbusVars"/>
				</constantVars>
				<iecVarsDeclaration>
					<group name="ModbusVars">
						<iecDeclaration active="FALSE"/>
					</group>
				</iecVarsDeclaration>
				<functions>
					<function name="sysMbSRtu_OpenChn" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus slave RTU open channel</descr>
						<returnValue>USINT</returnValue>
						<vars>
							<inputVars>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="ser" type="USINT">
									<descr>Serial Port (logical channel id)</descr>
								</var>
								<var name="baud" type="DINT">
									<descr>Serial Port Baudrate, refer to enumerative MbRtuBaudRate</descr>
								</var>
								<var name="mode" type="DINT">
									<descr>Serial Port Mode, refer to enumerative MbRtuMode</descr>
								</var>
								<var name="serCfg" type="USINT">
									<descr>Serial configuration, if TRUE configure serial port using parameters in database</descr>
								</var>
								<var name="phyCfg" type="USINT">
									<descr>Serial Port configuration (physical port id)</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbSRtu_OpenChn2" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus slave RTU open channel</descr>
						<returnValue>USINT</returnValue>
						<vars>
							<inputVars>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="ser" type="USINT">
									<descr>Serial Port (logical channel id)</descr>
								</var>
								<var name="baud" type="DINT">
									<descr>Serial Port Baudrate, refer to enumerative MbRtuBaudRate</descr>
								</var>
								<var name="mode" type="DINT">
									<descr>Serial Port Mode, refer to enumerative MbRtuMode</descr>
								</var>
								<var name="serCfg" type="USINT">
									<descr>Serial configuration, if TRUE configure serial port using parameters in database</descr>
								</var>
								<var name="phyCfg" type="USINT">
									<descr>Serial Port configuration (physical port id)</descr>
								</var>
								<var name="isModbusASCII" type="BOOL">
									<descr>TRUE to enable Modbus </descr>
								</var>
								<var name="rsMode" type="DINT">
									<descr>Serial port RS Mode, refer to enumerative MbRtuRSMode</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbSRtu_CloseChn" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus slave RTU close channel</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus slave RTU channel, returned from sysMbSRtu_OpenChn</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbSRtu_Boot" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus slave RTU Boot Configuration</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="boot" type="BOOL">
									<descr>Modbus slave RTU Boot Configuration command</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_SlavePrmReal" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU slave parametrization with real value</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="id" type="UINT">
									<descr>Unique identification number single slave</descr>
								</var>
								<var name="reg" type="UINT">
									<descr>Modbus element starting address</descr>
								</var>
								<var name="val" type="REAL">
									<descr>Real Value to be written</descr>
								</var>
								<var name="tmo" type="UINT">
									<descr>Time out (ms)</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_MemoryMapping" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU memory structures allocation</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="pMbMNetList" type="DWORD">
									<descr>Address of the net list structure</descr>
								</var>
								<var name="numNodes" type="UDINT">
									<descr>Number of slaves in the netlist</descr>
								</var>
								<var name="pMbMMsgQueue" type="DWORD">
									<descr>Address of the message queue that will be filled</descr>
								</var>
								<var name="numMsg" type="UDINT">
									<descr>Number of messages available for the queue</descr>
								</var>
								<var name="memoryAllocated" type="UDINT">
									<descr>Size in bytes of the memory allocated for network and queue</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_SlavePrmInteger" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU slave parametrization with integer value</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="id" type="UINT">
									<descr>Unique identification number single slave</descr>
								</var>
								<var name="reg" type="UINT">
									<descr>Modbus element starting address</descr>
								</var>
								<var name="dim" type="UINT">
									<descr>Modbus quantity of element</descr>
								</var>
								<var name="val" type="DINT">
									<descr>Integer Value to be written</descr>
								</var>
								<var name="tmo" type="UINT">
									<descr>Time out (ms)</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_SlaveAddToNetList" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU adding slave on network</descr>
						<returnValue>USINT</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="min_poll_time" type="UINT">
									<descr>Modbus slave minimum polling time (ms)</descr>
								</var>
								<var name="prm" type="UINT">
									<descr>Number of parametrization message that slave will be received</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_SlaveAddToNetList2" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU adding slave on network</descr>
						<returnValue>USINT</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="min_poll_time" type="UINT">
									<descr>Modbus slave minimum polling time (ms)</descr>
								</var>
								<var name="prm" type="UINT">
									<descr>Number of parametrization message that slave will be received</descr>
								</var>
								<var name="swapWords" type="USINT">
									<descr>Swap words mode</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_OpenChn" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU open channel</descr>
						<returnValue>USINT</returnValue>
						<vars>
							<inputVars>
								<var name="ser" type="USINT">
									<descr>Serial Port (logical channel id)</descr>
								</var>
								<var name="baud" type="DINT">
									<descr>Serial Port Baudrate, refer to enumerative MbRtuBaudRate</descr>
								</var>
								<var name="mode" type="DINT">
									<descr>Serial Port Mode, refer to enumerative MbRtuMode</descr>
								</var>
								<var name="serCfg" type="USINT">
									<descr>Serial configuration, if TRUE configure serial port using parameters in database</descr>
								</var>
								<var name="phyCfg" type="USINT">
									<descr>Serial Port configuration (physical port id)</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_OpenChn2" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU open channel</descr>
						<returnValue>USINT</returnValue>
						<vars>
							<inputVars>
								<var name="ser" type="USINT">
									<descr>Serial Port (logical channel id)</descr>
								</var>
								<var name="baud" type="DINT">
									<descr>Serial Port Baudrate, refer to enumerative MbRtuBaudRate</descr>
								</var>
								<var name="mode" type="DINT">
									<descr>Serial Port Mode, refer to enumerative MbRtuMode</descr>
								</var>
								<var name="serCfg" type="USINT">
									<descr>Serial configuration, if TRUE configure serial port using parameters in database</descr>
								</var>
								<var name="phyCfg" type="USINT">
									<descr>Serial Port configuration (physical port id)</descr>
								</var>
								<var name="rsMode" type="DINT">
									<descr>Serial port RS Mode, refer to enumerative MbRtuRSMode</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_NewSlaveMessage" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU set new message for a slave</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="fnz" type="DINT">
									<descr>Modbus function, refer to enumerative MbFunction</descr>
								</var>
								<var name="reg" type="UINT">
									<descr>Modbus element starting address</descr>
								</var>
								<var name="dim" type="UINT">
									<descr>Modbus quantity of element</descr>
								</var>
								<var name="db_n" type="UINT">
									<descr>Modbus element corresponding datablock</descr>
								</var>
								<var name="db_o" type="UINT">
									<descr>Modbus element corresponding datablock offset</descr>
								</var>
								<var name="db_t" type="USINT">
									<descr>Modbus element corresponding datablock type</descr>
								</var>
								<var name="poll_time" type="UINT">
									<descr>Polling time (ms)</descr>
								</var>
								<var name="tmo" type="UINT">
									<descr>Time out (ms)</descr>
								</var>
								<var name="modbus_pdu_tx_buffer" type="DWORD">
									<descr>Modbus pdu tx buffer (for on event msg only)</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_NewSlaveMessage2" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU set new message for a slave</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="fnz" type="DINT">
									<descr>Modbus function, refer to enumerative MbFunction</descr>
								</var>
								<var name="reg" type="UINT">
									<descr>Modbus element starting address</descr>
								</var>
								<var name="dim" type="UINT">
									<descr>Modbus quantity of element</descr>
								</var>
								<var name="db_n" type="UINT">
									<descr>Modbus element corresponding datablock</descr>
								</var>
								<var name="db_o" type="UINT">
									<descr>Modbus element corresponding datablock offset</descr>
								</var>
								<var name="db_t" type="USINT">
									<descr>Modbus element corresponding datablock type</descr>
								</var>
								<var name="poll_time" type="UINT">
									<descr>Polling time (ms)</descr>
								</var>
								<var name="tmo" type="UINT">
									<descr>Time out (ms)</descr>
								</var>
								<var name="modbus_pdu_tx_buffer" type="DWORD">
									<descr>Modbus pdu tx buffer (for on event msg only)</descr>
								</var>
								<var name="reg_types_info" type="DWORD">
									<descr>Register types informations</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_NewSlaveMessage3" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU set new message for a slave</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="fnz" type="DINT">
									<descr>Modbus function, refer to enumerative MbFunction</descr>
								</var>
								<var name="reg" type="UINT">
									<descr>Modbus element starting address</descr>
								</var>
								<var name="dim" type="UINT">
									<descr>Modbus quantity of element</descr>
								</var>
								<var name="dbElemsArr" type="@UINT">
									<descr>Array of datablock mappings</descr>
								</var>
								<var name="dbAddrArr" type="PVOID">
									<descr>Array of datablock addresses</descr>
								</var>
								<var name="poll_time" type="UINT">
									<descr>Polling time (ms)</descr>
								</var>
								<var name="tmo" type="UINT">
									<descr>Time out (ms)</descr>
								</var>
								<var name="modbus_pdu_tx_buffer" type="@BYTE">
									<descr>Modbus pdu tx buffer (for on event msg only)</descr>
								</var>
								<var name="reg_types_info" type="@BYTE">
									<descr>Register types informations</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_NewBroadcastMessage" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU set new broadcast message</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="fnz" type="DINT">
									<descr>Modbus function, refer to enumerative MbFunction</descr>
								</var>
								<var name="reg" type="UINT">
									<descr>Modbus element starting address</descr>
								</var>
								<var name="dim" type="UINT">
									<descr>Modbus quantity of element</descr>
								</var>
								<var name="db_n" type="UINT">
									<descr>Modbus element corresponding datablock</descr>
								</var>
								<var name="db_o" type="UINT">
									<descr>Modbus element corresponding datablock offset</descr>
								</var>
								<var name="db_t" type="USINT">
									<descr>Modbus element corresponding datablock type</descr>
								</var>
								<var name="turn_time" type="UINT">
									<descr>Tournaround delay (ms)</descr>
								</var>
								<var name="poll_time" type="UINT">
									<descr>Polling time (ms)</descr>
								</var>
								<var name="modbus_pdu_tx_buffer" type="DWORD">
									<descr>Modbus pdu tx buffer (for on event msg only)</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_SetCurrMsgOneShotVar" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU oneshot variable</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="db_n" type="UINT">
									<descr>Oneshot variable corresponding datablock</descr>
								</var>
								<var name="db_o" type="UINT">
									<descr>Oneshot variable corresponding datablock offset</descr>
								</var>
								<var name="db_t" type="USINT">
									<descr>Oneshot variable corresponding datablock type</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_MsgConfigCompleted" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Message configuration completed</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="dummy" type="BOOL">
									<descr>Dummy parameter</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_CloseChn" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU close channel</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_Boot" version="1.0.0" hidden="true" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU Boot Configuration</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="boot" type="BOOL">
									<descr>Modbus master RTU Boot Configuration command</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_SlaveActivation" version="1.0.0" creationDate="0" lastModifiedDate="1564576166">
						<descr>Modbus master RTU Activate/Deactivate Slave communication</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="handle" type="USINT">
									<descr>Modbus slave handle, returned from sysMbMRtu_GetSlaveHandle</descr>
								</var>
								<var name="activate" type="BOOL">
									<descr>If TRUE, Slave is concurrent in communication</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_GetSlaveHandle" version="1.0.0" creationDate="0" lastModifiedDate="0">
						<descr>Modbus master RTU get offset in Netlist of corresponding slave</descr>
						<returnValue>USINT</returnValue>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMRtu_SetPostDelay" version="1.0.0" hidden="false" creationDate="0" lastModifiedDate="0">
						<descr>Modbus slave RTU: manually set post-delay time of serial communication</descr>
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="postDelay" type="UINT">
									<descr>Post-delay in ms to be used</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
				</functions>
				<functionBlocks>
					<functionBlock name="sysMbMRtu_GetSlaveStatus" version="1.0.0" creationDate="0" lastModifiedDate="1564576166">
						<descr>Modbus master RTU get status of corresponding slave</descr>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
								<var name="hdl" type="USINT">
									<descr>Modbus slave handle, returned from sysMbMRtu_GetSlaveHandle</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="adr" type="USINT">
									<descr>Modbus slave address</descr>
								</var>
								<var name="cfg" type="BOOL">
									<descr>Modbus slave is added to netlist</descr>
								</var>
								<var name="pres" type="BOOL">
									<descr>Modbus slave is present on network</descr>
								</var>
								<var name="active" type="BOOL">
									<descr>Modbus slave is concurrent in communication</descr>
								</var>
								<var name="n_prm" type="UINT">
									<descr>Total number of Parametrization Slave Message</descr>
								</var>
								<var name="n_qmsg" type="UINT">
									<descr>Total number of Configurated Slave Message</descr>
								</var>
								<var name="min_poll_time" type="UINT">
									<descr>Minimum polling time (ms)</descr>
								</var>
								<var name="status" type="MbStatus">
									<descr>Modbus slave state machine, referred to enumerative MbStatus</descr>
								</var>
								<var name="error" type="MbError">
									<descr>Modbus slave last error, referred to enumerative MbError</descr>
								</var>
								<var name="exception" type="MbException">
									<descr>Modbus slave last exception, referred to enumerative MbException</descr>
								</var>
								<var name="n_SlaveExceptionCount" type="UINT">
									<descr>Slave Exception Error Count</descr>
								</var>
								<var name="n_SlaveMessageCount" type="UINT">
									<descr>Slave Message Count</descr>
								</var>
								<var name="n_SlaveNoResponsCount" type="UINT">
									<descr>Slave No Response Count</descr>
								</var>
								<var name="n_SlaveNAKCount" type="UINT">
									<descr>Slave NAK Count</descr>
								</var>
								<var name="n_SlaveBusyCount" type="UINT">
									<descr>Slave Busy Count</descr>
								</var>
								<var name="n_SlaveChrOvrCount" type="UINT">
									<descr>Slave Character Overrun Count</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMRtu_GetMasterStatus" version="1.0.0" creationDate="0" lastModifiedDate="1564573500">
						<descr>Modbus master RTU get status of master</descr>
						<vars>
							<inputVars>
								<var name="chn" type="USINT">
									<descr>Modbus Master RTU channel, referred to sysMbMRtuStatus.chn</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="cfgOk" type="BOOL">
									<descr>Modbus Master configured</descr>
								</var>
								<var name="status" type="MbStatus">
									<descr>Modbus Master state machine, referred to enumerative MbStatus</descr>
								</var>
								<var name="lastError" type="MbError">
									<descr>Modbus Master last error, referred to enumerative MbError</descr>
								</var>
								<var name="nSlaves" type="USINT">
									<descr>Total number of Configurated Slave in Net list</descr>
								</var>
								<var name="nQueuedMsg" type="UINT">
									<descr>Total number of Configurated Broadcast and Single Slave Message</descr>
								</var>
								<var name="nQueuedBroadcastMsg" type="UINT">
									<descr>Total number of Configurated Broadcast Message</descr>
								</var>
								<var name="nBusMsgCount" type="UINT">
									<descr>Bus Message Count</descr>
								</var>
								<var name="nBusCommErrCount" type="UINT">
									<descr>Bus Communication Error Count</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMRtu_FC16" version="1.0.0" creationDate="0" lastModifiedDate="1564576283">
						<descr>Write Multiple Registers - Function 16 (0x10).
This function block can be used in the Background task only.
You have to assure that all input variables, except any objectN variable, where N is greater than the value of no input variable, are properly set before invoking the function block. In particular, the addr input variable must be set to the physical address of an existing Modbus Slave target of this operation. The values of all input variables ranging from object1 to objectN, where N equals the value of no input variable are the values sent on the communication bus to the slave node.
After function block execution, if an error did occur, you can read its code from the errorCode output variable.</descr>
						<vars>
							<inputVars>
								<var name="chn" type="MbChn">
									<descr>Identify which one of the two serial will be used</descr>
								</var>
								<var name="addr" type="USINT">
									<descr>Physical address of the target slave</descr>
								</var>
								<var name="base" type="UINT">
									<descr>Address of the first Holding Register to write</descr>
								</var>
								<var name="no" type="UINT">
									<descr>Number of contiguous Holding Registers to write</descr>
								</var>
								<var name="object1" type="UINT">
									<descr>1st Holding Register value</descr>
								</var>
								<var name="object2" type="UINT">
									<descr>2nd Holding Register value</descr>
								</var>
								<var name="object3" type="UINT">
									<descr>3rd Holding Register value</descr>
								</var>
								<var name="object4" type="UINT">
									<descr>4th Holding Register value</descr>
								</var>
								<var name="object5" type="UINT">
									<descr>5th Holding Register value</descr>
								</var>
								<var name="object6" type="UINT">
									<descr>6th Holding Register value</descr>
								</var>
								<var name="object7" type="UINT">
									<descr>7th Holding Register value</descr>
								</var>
								<var name="object8" type="UINT">
									<descr>8th Holding Register value</descr>
								</var>
								<var name="object9" type="UINT">
									<descr>9th Holding Register value</descr>
								</var>
								<var name="object10" type="UINT">
									<descr>10th Holding Register value</descr>
								</var>
								<var name="object11" type="UINT">
									<descr>11th Holding Register value</descr>
								</var>
								<var name="object12" type="UINT">
									<descr>12th Holding Register value</descr>
								</var>
								<var name="object13" type="UINT">
									<descr>13th Holding Register value</descr>
								</var>
								<var name="object14" type="UINT">
									<descr>14th Holding Register value</descr>
								</var>
								<var name="object15" type="UINT">
									<descr>15th Holding Register value</descr>
								</var>
								<var name="object16" type="UINT">
									<descr>16th Holding Register value</descr>
								</var>
								<var name="pollingTime" type="UINT">
									<descr>Polling time [ms] (Reserved for future use)</descr>
								</var>
								<var name="waitBeforeSend" type="UINT">
									<descr>Time to wait before sending the message [ms]</descr>
								</var>
								<var name="timeout" type="UINT">
									<descr>Timeout [ms]</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="errorCode" type="MbRqErr">
									<descr>Exception Code</descr>
								</var>
								<var name="error" type="BOOL">
									<descr>TRUE = error occurred; FALSE = no error</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="timestamp" type="UDINT">
									<descr>Message timestamp [ms]</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMRtu_FC15" version="1.0.0" creationDate="0" lastModifiedDate="1564576283">
						<descr>Write Multiple Coils - Function 15 (0x0F).
This function block can be used in the Bakcground task only.
You have to assure that all input variables, except any objectN variable, where N is greater than the value of no input variable, are properly set before invoking the function block. In particular, the addr input variable must be set to the physical address of an existing Modbus Slave target of this operation. The values of all input variables ranging from object1 to objectN, where N equals the value of no input variable are the values sent on the communication bus to the slave node.
After function block execution, if an error did occur, you can read its code from the errorCode output variable.</descr>
						<vars>
							<inputVars>
								<var name="chn" type="MbChn">
									<descr>Identify which one of the two serial will be used</descr>
								</var>
								<var name="addr" type="USINT">
									<descr>Physical address of the target slave</descr>
								</var>
								<var name="base" type="UINT">
									<descr>Address of the first Coils to write</descr>
								</var>
								<var name="no" type="UINT">
									<descr>Number of contiguous Coils to write</descr>
								</var>
								<var name="object1" type="BOOL">
									<descr>1st Coil value</descr>
								</var>
								<var name="object2" type="BOOL">
									<descr>2nd Coil value</descr>
								</var>
								<var name="object3" type="BOOL">
									<descr>3rd Coil value</descr>
								</var>
								<var name="object4" type="BOOL">
									<descr>4th Coil value</descr>
								</var>
								<var name="object5" type="BOOL">
									<descr>5th Coil value</descr>
								</var>
								<var name="object6" type="BOOL">
									<descr>6th Coil value</descr>
								</var>
								<var name="object7" type="BOOL">
									<descr>7th Coil value</descr>
								</var>
								<var name="object8" type="BOOL">
									<descr>8th Coil value</descr>
								</var>
								<var name="object9" type="BOOL">
									<descr>9th Coil value</descr>
								</var>
								<var name="object10" type="BOOL">
									<descr>10th Coil value</descr>
								</var>
								<var name="object11" type="BOOL">
									<descr>11th Coil value</descr>
								</var>
								<var name="object12" type="BOOL">
									<descr>12th Coil value</descr>
								</var>
								<var name="object13" type="BOOL">
									<descr>13th Coil value</descr>
								</var>
								<var name="object14" type="BOOL">
									<descr>14th Coil value</descr>
								</var>
								<var name="object15" type="BOOL">
									<descr>15th Coil value</descr>
								</var>
								<var name="object16" type="BOOL">
									<descr>16th Coil value</descr>
								</var>
								<var name="pollingTime" type="UINT">
									<descr>Polling time [ms] (Reserved for future use)</descr>
								</var>
								<var name="waitBeforeSend" type="UINT">
									<descr>Time to wait before sending the message [ms]</descr>
								</var>
								<var name="timeout" type="UINT">
									<descr>Timeout [ms]</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="errorCode" type="MbRqErr">
									<descr>Exception Code</descr>
								</var>
								<var name="error" type="BOOL">
									<descr>TRUE = error occurred; FALSE = no error</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="timestamp" type="UDINT">
									<descr>Message timestamp [ms]</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMRtu_FC06" version="1.0.0" creationDate="0" lastModifiedDate="1564576283">
						<descr>Write Single Register - Function 06 (0x06).
This function block can be used in the Background task only.
You have to assure that all input variables are properly set before invoking the function block. In particular, the addr input variable must be set to the physical address of an existing Modbus Slave target of this operation. The value of the object input variable is the value sent on the communication bus to the slave node.
After function block execution, if an error did occur, you can read its code from the errorCode output variable.</descr>
						<vars>
							<inputVars>
								<var name="chn" type="MbChn">
									<descr>Identify which one of the two serial will be used</descr>
								</var>
								<var name="addr" type="USINT">
									<descr>Physical address of the target slave</descr>
								</var>
								<var name="base" type="UINT">
									<descr>Address of the Register to write</descr>
								</var>
								<var name="object" type="UINT">
									<descr>Register value</descr>
								</var>
								<var name="pollingTime" type="UINT">
									<descr>Polling time [ms] (Reserved for future use)</descr>
								</var>
								<var name="waitBeforeSend" type="UINT">
									<descr>Time to wait before sending the message [ms]</descr>
								</var>
								<var name="timeout" type="UINT">
									<descr>Timeout [ms]</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="errorCode" type="MbRqErr">
									<descr>Exception Code</descr>
								</var>
								<var name="error" type="BOOL">
									<descr>TRUE = error occurred; FALSE = no error</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="timestamp" type="UDINT">
									<descr>Message timestamp [ms]</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMRtu_FC05" version="1.0.0" creationDate="0" lastModifiedDate="1564576283">
						<descr>Write Single Coil - Function 05 (0x05).
This function block can be used in the Background task only.
You have to assure that all input variables are properly set before invoking the function block. In particular, the addr input variable must be set to the physical address of an existing Modbus Slave target of this operation. The value of the object input variable is the value sent on the communication bus to the slave node.
After function block execution, if an error did occur, you can read its code from the errorCode output variable.</descr>
						<vars>
							<inputVars>
								<var name="chn" type="MbChn">
									<descr>Identify which one of the two serial will be used</descr>
								</var>
								<var name="addr" type="USINT">
									<descr>Physical address of the target slave</descr>
								</var>
								<var name="base" type="UINT">
									<descr>Address of the Coil to write</descr>
								</var>
								<var name="object" type="BOOL">
									<descr>Coil value</descr>
								</var>
								<var name="pollingTime" type="UINT">
									<descr>Polling time [ms] (Reserved for future use)</descr>
								</var>
								<var name="waitBeforeSend" type="UINT">
									<descr>Time to wait before sending the message [ms]</descr>
								</var>
								<var name="timeout" type="UINT">
									<descr>Timeout [ms]</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="errorCode" type="MbRqErr">
									<descr>Exception Code</descr>
								</var>
								<var name="error" type="BOOL">
									<descr>TRUE = error occurred; FALSE = no error</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="timestamp" type="UDINT">
									<descr>Message timestamp [ms]</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMRtu_FC04" version="1.0.0" creationDate="0" lastModifiedDate="1564576283">
						<descr>Read Input Registers - Function 04 (0x04).
This function block can be used in the Background task only.
You have to assure that all input variables are properly set before invoking the function block. In particular, the addr input variable must be set to the physical address of an existing Modbus Slave target of this operation.
After function block execution, unless an error occurred, you can use a subset of its output variables (from object1 to objectN, where N equals the value of no input variable) to get the Modbus objects read from the communication bus. If an error did occur, you can read its code from the errorCode output variable.</descr>
						<vars>
							<inputVars>
								<var name="chn" type="MbChn">
									<descr>Identify which one of the two serial will be used</descr>
								</var>
								<var name="addr" type="USINT">
									<descr>Physical address of the target slave</descr>
								</var>
								<var name="base" type="UINT">
									<descr>Address of the first Input Register to be read</descr>
								</var>
								<var name="no" type="UINT">
									<descr>Number of contiguous Input Registers to be read</descr>
								</var>
								<var name="pollingTime" type="UINT">
									<descr>Polling time [ms] (Reserved for future use)</descr>
								</var>
								<var name="waitBeforeSend" type="UINT">
									<descr>Time to wait before sending the message [ms]</descr>
								</var>
								<var name="timeout" type="UINT">
									<descr>Timeout [ms]</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="errorCode" type="MbRqErr">
									<descr>Exception Code</descr>
								</var>
								<var name="error" type="BOOL">
									<descr>TRUE = error occurred; FALSE = no error</descr>
								</var>
								<var name="object1" type="UINT">
									<descr>1st Input Register</descr>
								</var>
								<var name="object2" type="UINT">
									<descr>2nd Input Register</descr>
								</var>
								<var name="object3" type="UINT">
									<descr>3rd Input Register</descr>
								</var>
								<var name="object4" type="UINT">
									<descr>4th Input Register</descr>
								</var>
								<var name="object5" type="UINT">
									<descr>5th Input Register</descr>
								</var>
								<var name="object6" type="UINT">
									<descr>6th Input Register</descr>
								</var>
								<var name="object7" type="UINT">
									<descr>7th Input Register</descr>
								</var>
								<var name="object8" type="UINT">
									<descr>8th Input Register</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="timestamp" type="UDINT">
									<descr>Message timestamp [ms]</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMRtu_FC03" version="1.0.0" creationDate="0" lastModifiedDate="1564576283">
						<descr>Read Holding Registers - Function 03 (0x03).
This function block can be used in the Background task only.
You have to assure that all input variables are properly set before invoking the function block. In particular, the addr input variable must be set to the physical address of an existing Modbus Slave target of this operation.
After function block execution, unless an error occurred, you can use a subset of its output variables (from object1 to objectN, where N equals the value of no input variable) to get the Modbus objects read from the communication bus. If an error did occur, you can read its code from the errorCode output variable.</descr>
						<vars>
							<inputVars>
								<var name="chn" type="MbChn">
									<descr>Identify which one of the two serial will be used</descr>
								</var>
								<var name="addr" type="USINT">
									<descr>Physical address of the target slave</descr>
								</var>
								<var name="base" type="UINT">
									<descr>Address of the first Holding Register to be read</descr>
								</var>
								<var name="no" type="UINT">
									<descr>Number of contiguous Holding Registers to be read</descr>
								</var>
								<var name="pollingTime" type="UINT">
									<descr>Polling time [ms] (Reserved for future use)</descr>
								</var>
								<var name="waitBeforeSend" type="UINT">
									<descr>Time to wait before sending the message [ms]</descr>
								</var>
								<var name="timeout" type="UINT">
									<descr>Timeout [ms]</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="errorCode" type="MbRqErr">
									<descr>Exception Code</descr>
								</var>
								<var name="error" type="BOOL">
									<descr>TRUE = error occurred; FALSE = no error</descr>
								</var>
								<var name="object1" type="UINT">
									<descr>1st Holding Register</descr>
								</var>
								<var name="object2" type="UINT">
									<descr>2nd Holding Register</descr>
								</var>
								<var name="object3" type="UINT">
									<descr>3rd Holding Register</descr>
								</var>
								<var name="object4" type="UINT">
									<descr>4th Holding Register</descr>
								</var>
								<var name="object5" type="UINT">
									<descr>5th Holding Register</descr>
								</var>
								<var name="object6" type="UINT">
									<descr>6th Holding Register</descr>
								</var>
								<var name="object7" type="UINT">
									<descr>7th Holding Register</descr>
								</var>
								<var name="object8" type="UINT">
									<descr>8th Holding Register</descr>
								</var>
								<var name="object9" type="UINT">
									<descr>9th Holding Register</descr>
								</var>
								<var name="object10" type="UINT">
									<descr>10th Holding Register</descr>
								</var>
								<var name="object11" type="UINT">
									<descr>11th Holding Register</descr>
								</var>
								<var name="object12" type="UINT">
									<descr>12th Holding Register</descr>
								</var>
								<var name="object13" type="UINT">
									<descr>13th Holding Register</descr>
								</var>
								<var name="object14" type="UINT">
									<descr>14th Holding Register</descr>
								</var>
								<var name="object15" type="UINT">
									<descr>15th Holding Register</descr>
								</var>
								<var name="object16" type="UINT">
									<descr>16th Holding Register</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="timestamp" type="UDINT">
									<descr>Message timestamp [ms]</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMRtu_FC02" version="1.0.0" creationDate="0" lastModifiedDate="1564576283">
						<descr>Read Inputs Status - Function 02 (0x02).
This function block can be used in the Background task only.
You have to assure that all input variables are properly set before invoking the function block. In particular, the addr input variable must be set to the physical address of an existing Modbus Slave target of this operation.
After function block execution, unless an error occurred, you can use a subset of its output variables (from object1 to objectN, where N equals the value of no input variable) to get the Modbus objects read from the communication bus. If an error did occur, you can read its code from the errorCode output variable.</descr>
						<vars>
							<inputVars>
								<var name="chn" type="MbChn">
									<descr>Identify which one of the two serial will be used</descr>
								</var>
								<var name="addr" type="USINT">
									<descr>Physical address of the target slave</descr>
								</var>
								<var name="base" type="UINT">
									<descr>Address of the first Input to be read</descr>
								</var>
								<var name="no" type="UINT">
									<descr>Number of contiguous Inputs to be read</descr>
								</var>
								<var name="pollingTime" type="UINT">
									<descr>Polling time [ms] (Reserved for future use)</descr>
								</var>
								<var name="waitBeforeSend" type="UINT">
									<descr>Time to wait before sending the message [ms]</descr>
								</var>
								<var name="timeout" type="UINT">
									<descr>Timeout [ms]</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="errorCode" type="MbRqErr">
									<descr>Exception Code</descr>
								</var>
								<var name="error" type="BOOL">
									<descr>TRUE = error occurred; FALSE = no error</descr>
								</var>
								<var name="object1" type="BOOL">
									<descr>1st Input</descr>
								</var>
								<var name="object2" type="BOOL">
									<descr>2nd Input</descr>
								</var>
								<var name="object3" type="BOOL">
									<descr>3rd Input</descr>
								</var>
								<var name="object4" type="BOOL">
									<descr>4th Input</descr>
								</var>
								<var name="object5" type="BOOL">
									<descr>5th Input</descr>
								</var>
								<var name="object6" type="BOOL">
									<descr>6th Input</descr>
								</var>
								<var name="object7" type="BOOL">
									<descr>7th Input</descr>
								</var>
								<var name="object8" type="BOOL">
									<descr>8th Input</descr>
								</var>
								<var name="object9" type="BOOL">
									<descr>9th Input</descr>
								</var>
								<var name="object10" type="BOOL">
									<descr>10th Input</descr>
								</var>
								<var name="object11" type="BOOL">
									<descr>11th Input</descr>
								</var>
								<var name="object12" type="BOOL">
									<descr>12th Input</descr>
								</var>
								<var name="object13" type="BOOL">
									<descr>13th Input</descr>
								</var>
								<var name="object14" type="BOOL">
									<descr>14th Input</descr>
								</var>
								<var name="object15" type="BOOL">
									<descr>15th Input</descr>
								</var>
								<var name="object16" type="BOOL">
									<descr>16th Input</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="timestamp" type="UDINT">
									<descr>Message timestamp [ms]</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMRtu_FC01" version="1.0.0" creationDate="0" lastModifiedDate="1564576283">
						<descr>Read Coil Status - Function 01 (0x01).
This function block can be used in the Background task only.
You have to assure that all input variables are properly set before invoking the function block. In particular, the addr input variable must be set to the physical address of an existing Modbus Slave target of this operation.
After function block execution, unless an error occurred, you can use a subset of its output variables (from object1 to objectN, where N equals the value of no input variable) to get the Modbus objects read from the communication bus. If an error did occur, you can read its code from the errorCode output variable.</descr>
						<vars>
							<inputVars>
								<var name="chn" type="MbChn">
									<descr>Identify which one of the two serial will be used</descr>
								</var>
								<var name="addr" type="USINT">
									<descr>Physical address of the target slave</descr>
								</var>
								<var name="base" type="UINT">
									<descr>Address of the first coil to be read</descr>
								</var>
								<var name="no" type="UINT">
									<descr>Number of contiguous coils to be read</descr>
								</var>
								<var name="pollingTime" type="UINT">
									<descr>Polling time [ms] (Reserved for future use)</descr>
								</var>
								<var name="waitBeforeSend" type="UINT">
									<descr>Time to wait before sending the message [ms]</descr>
								</var>
								<var name="timeout" type="UINT">
									<descr>Timeout [ms]</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="errorCode" type="MbRqErr">
									<descr>Exception Code</descr>
								</var>
								<var name="error" type="BOOL">
									<descr>TRUE = error occurred; FALSE = no error</descr>
								</var>
								<var name="object1" type="BOOL">
									<descr>1st Coil</descr>
								</var>
								<var name="object2" type="BOOL">
									<descr>2nd Coil</descr>
								</var>
								<var name="object3" type="BOOL">
									<descr>3rd Coil</descr>
								</var>
								<var name="object4" type="BOOL">
									<descr>4th Coil</descr>
								</var>
								<var name="object5" type="BOOL">
									<descr>5th Coil</descr>
								</var>
								<var name="object6" type="BOOL">
									<descr>6th Coil</descr>
								</var>
								<var name="object7" type="BOOL">
									<descr>7th Coil</descr>
								</var>
								<var name="object8" type="BOOL">
									<descr>8th Coil</descr>
								</var>
								<var name="object9" type="BOOL">
									<descr>9th Coil</descr>
								</var>
								<var name="object10" type="BOOL">
									<descr>10th Coil</descr>
								</var>
								<var name="object11" type="BOOL">
									<descr>11th Coil</descr>
								</var>
								<var name="object12" type="BOOL">
									<descr>12th Coil</descr>
								</var>
								<var name="object13" type="BOOL">
									<descr>13th Coil</descr>
								</var>
								<var name="object14" type="BOOL">
									<descr>14th Coil</descr>
								</var>
								<var name="object15" type="BOOL">
									<descr>15th Coil</descr>
								</var>
								<var name="object16" type="BOOL">
									<descr>16th Coil</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="timestamp" type="UDINT">
									<descr>Message timestamp [ms]</descr>
								</var>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
				</functionBlocks>
				<programs/>
				<macros/>
				<structs>
					<struct name="MbMRtuStatus" version="1.0.0">
						<descr>Status of Modbus Master RTU</descr>
						<vars>
							<var name="cfg" type="BOOL">
								<descr>Modbus Master configured</descr>
							</var>
							<var name="chn" type="USINT">
								<descr>Modbus master RTU channel, returned from sysMbMRtu_OpenChn</descr>
							</var>
							<var name="numSlaves" type="USINT">
								<descr>Total number of Configurated Slave in Net list</descr>
							</var>
							<var name="reserved" type="USINT">
								<descr>Reserved field</descr>
							</var>
							<var name="status" type="MbStatus">
								<descr>Modbus master state machine, referred to enumerative MbStatus</descr>
							</var>
							<var name="error" type="MbError">
								<descr>Modbus master last error, referred to enumerative MbError</descr>
							</var>
							<var name="numMsg" type="UINT">
								<descr>Total number of Configurated Broadcast and Single Slave Message</descr>
							</var>
							<var name="numBroadcastMsg" type="UINT">
								<descr>Total number of Configurated Broadcast Message</descr>
							</var>
							<var name="numBusMsgCount" type="UINT">
								<descr>Bus Message Count</descr>
							</var>
							<var name="numBusCommErrCount" type="UINT">
								<descr>Bus Communication Error Count</descr>
							</var>
						</vars>
					</struct>
					<struct name="MbMRtuNetList" version="1.0.0">
						<descr>Modbus Master RTU Netlist</descr>
						<vars>
							<var name="chn" type="USINT">
								<descr>Modbus master RTU channel, returned from sysMbMRtu_OpenChn</descr>
							</var>
							<var name="adr" type="USINT">
								<descr>Modbus slave address</descr>
							</var>
							<var name="cfg" type="BOOL">
								<descr>Modbus slave is added to netlist</descr>
							</var>
							<var name="pres" type="BOOL">
								<descr>Modbus slave is present on network</descr>
							</var>
							<var name="active" type="BOOL">
								<descr>Modbus slave is concurrent in communication</descr>
							</var>
							<var name="swapWordsMode" type="USINT">
								<descr>Swap Mode field</descr>
							</var>
							<var name="numParamMsg" type="UINT">
								<descr>Total number of Parametrization Slave Message</descr>
							</var>
							<var name="numQueuedMsg" type="UINT">
								<descr>Total number of Configurated Slave Message</descr>
							</var>
							<var name="minPollingTime" type="UINT">
								<descr>Minimum polling time (ms)</descr>
							</var>
							<var name="status" type="MbStatus">
								<descr>Modbus slave state machine, referred to enumerative MbStatus</descr>
							</var>
							<var name="error" type="MbError">
								<descr>Modbus slave last error, referred to enumerative MbError</descr>
							</var>
							<var name="exception" type="MbException">
								<descr>Modbus slave last exception, referred to enumerative MbException</descr>
							</var>
							<var name="slaveExceptionCount" type="UINT">
								<descr>Slave Exception Error Count</descr>
							</var>
							<var name="slaveMessageCount" type="UINT">
								<descr>Slave Message Count</descr>
							</var>
							<var name="slaveNoResponseCount" type="UINT">
								<descr>Slave No Response Count</descr>
							</var>
							<var name="slaveNoAckCount" type="UINT">
								<descr>Slave NAK Count</descr>
							</var>
							<var name="slaveBusyCount" type="UINT">
								<descr>Slave Busy Count</descr>
							</var>
							<var name="slaveChrOvrCount" type="UINT">
								<descr>Slave Character Overrun Count</descr>
							</var>
						</vars>
					</struct>
					<struct name="MbRtuDiagnostics" version="1.0.0">
						<descr>Standard Modbus diagnostic</descr>
						<vars>
							<var name="slaveBusMsgCount" type="UINT">
								<descr>Bus Message Count</descr>
							</var>
							<var name="slaveBusCommErrCount" type="UINT">
								<descr>Bus Communication Error Count</descr>
							</var>
							<var name="slaveExceptionCount" type="UINT">
								<descr>Slave Exception Error Count</descr>
							</var>
							<var name="slaveMessageCount" type="UINT">
								<descr>Slave Message Count</descr>
							</var>
							<var name="slaveNoResponseCount" type="UINT">
								<descr>Slave No Response Count</descr>
							</var>
							<var name="slaveNoAckCount" type="UINT">
								<descr>Slave NAK Count</descr>
							</var>
							<var name="slaveBusyCount" type="UINT">
								<descr>Slave Busy Count</descr>
							</var>
							<var name="slaveChrOvrCount" type="UINT">
								<descr>Slave Character Overrun Count</descr>
							</var>
						</vars>
					</struct>
				</structs>
				<typedefs/>
				<enums>
					<enum name="MbStatus" version="1.0.0">
						<descr>Modbus Master Status decoding, use for master and slave state</descr>
						<elements>
							<element name="MbStatus_NotConfigured">
								<descr>Not configured</descr>
								<value>0</value>
							</element>
							<element name="MbStatus_Configured">
								<descr>Configured, waiting for go running</descr>
								<value>1</value>
							</element>
							<element name="MbStatus_Configuring">
								<descr>Configuration in progress</descr>
								<value>2</value>
							</element>
							<element name="MbStatus_Stopped">
								<descr>Stopped</descr>
								<value>3</value>
							</element>
							<element name="MbStatus_Starting">
								<descr>Start, waiting for running</descr>
								<value>4</value>
							</element>
							<element name="MbStatus_Running">
								<descr>Running</descr>
								<value>5</value>
							</element>
						</elements>
					</enum>
					<enum name="MbRqErr" version="1.0.0">
						<descr>List of possible errors obtained after a Modbus Master request</descr>
						<elements>
							<element name="MbRqErr_Ok">
								<descr>No error occurred</descr>
								<value>0</value>
							</element>
							<element name="MbRqErr_IllegalFunction">
								<descr>Invalid request message</descr>
								<value>1</value>
							</element>
							<element name="MbRqErr_IllegalDataAddress">
								<descr>Illegal data address</descr>
								<value>2</value>
							</element>
							<element name="MbRqErr_IllegalDataValue">
								<descr>Illegal data value</descr>
								<value>3</value>
							</element>
							<element name="MbRqErr_SlaveDeviceFailure">
								<descr>Salve device failure</descr>
								<value>4</value>
							</element>
							<element name="MbRqErr_Acknowledge">
								<descr>Acknowledge error</descr>
								<value>5</value>
							</element>
							<element name="MbRqErr_SlaveDeviceBusy">
								<descr>Slave device busy</descr>
								<value>6</value>
							</element>
							<element name="MbRqErr_ParityError">
								<descr>Memory parity error</descr>
								<value>7</value>
							</element>
							<element name="MbRqErr_CommChn">
								<descr>Communication channel configuration error</descr>
								<value>8</value>
							</element>
							<element name="MbRqErr_InvalidSlaveAddress">
								<descr>Invalid slave address (address range 0 - 247)</descr>
								<value>9</value>
							</element>
							<element name="MbRqErr_GatewayPathUnavailable">
								<descr>Gateway path unavailable</descr>
								<value>10</value>
							</element>
							<element name="MbRqErr_GatewayDeviceFailed">
								<descr>Gateway target device failed to respond</descr>
								<value>11</value>
							</element>
							<element name="MbRqErr_MsgMaxElements">
								<descr>Invalid number of element for this function</descr>
								<value>12</value>
							</element>
							<element name="MbRqErr_MsgRequestInvalid">
								<descr>Cannot correctly build the request message</descr>
								<value>13</value>
							</element>
							<element name="MbRqErr_MsgResponseInvalid">
								<descr>Invalid response message</descr>
								<value>14</value>
							</element>
							<element name="MbRqErr_MsgSize">
								<descr>Response size error</descr>
								<value>15</value>
							</element>
							<element name="MbRqErr_Timeout">
								<descr>Timeout reached</descr>
								<value>16</value>
							</element>
							<element name="MbRqErr_TaskInvalid">
								<descr>Function invoked by an invalid task</descr>
								<value>17</value>
							</element>
						</elements>
					</enum>
					<enum name="MbParam" version="1.0.0">
						<descr>Modbus Parametrization Request Status decoding</descr>
						<elements>
							<element name="MbParam_Init">
								<descr>Initialization</descr>
								<value>0</value>
							</element>
							<element name="MbParam_Busy">
								<descr>Busy</descr>
								<value>1</value>
							</element>
							<element name="MbParam_SendRequest">
								<descr>Send request</descr>
								<value>2</value>
							</element>
							<element name="MbParam_WaitResponse">
								<descr>Wait response</descr>
								<value>3</value>
							</element>
							<element name="MbParam_Ended">
								<descr>Terminated</descr>
								<value>4</value>
							</element>
						</elements>
					</enum>
					<enum name="MbMode" version="1.0.0">
						<descr>Modbus RTU communication mode</descr>
						<elements>
							<element name="MbMode_8N1">
								<descr>8 bit, no parity, 1 stop bit</descr>
								<value>0</value>
							</element>
							<element name="MbMode_8E1">
								<descr>8 bit, even parity, 1 stop bit</descr>
								<value>1</value>
							</element>
							<element name="MbMode_8O1">
								<descr>8 bit, odd parity, 1 stop bit</descr>
								<value>2</value>
							</element>
							<element name="MbMode_8N2">
								<descr>8 bit, no parity, 2 stop bit</descr>
								<value>3</value>
							</element>
							<element name="MbMode_8E2">
								<descr>8 bit, even parity, 2 stop bit</descr>
								<value>4</value>
							</element>
							<element name="MbMode_8O2">
								<descr>8 bit, odd parity, 2 stop bit</descr>
								<value>5</value>
							</element>
							<element name="MbMode_8S1">
								<descr>8 bit, space parity, 1 stop bit</descr>
								<value>6</value>
							</element>
							<element name="MbMode_8M1">
								<descr>8 bit, mark parity, 1 stop bit</descr>
								<value>7</value>
							</element>
							<element name="MbMode_8S2">
								<descr>8 bit, space parity, 2 stop bit</descr>
								<value>8</value>
							</element>
							<element name="MbMode_8M2">
								<descr>8 bit, mark parity, 2 stop bit</descr>
								<value>9</value>
							</element>
							<element name="MbMode_Auto">
								<descr>Selected by low level driver</descr>
								<value>255</value>
							</element>
						</elements>
					</enum>
					<enum name="MbFunction" version="1.0.0">
						<descr>Modbus Function</descr>
						<elements>
							<element name="MbFunc_ReadCoils">
								<descr>0x01 Read Coils</descr>
								<value>1</value>
							</element>
							<element name="MbFunc_ReadDiscreteInputs">
								<descr>0x02 Read Discrete Inputs</descr>
								<value>2</value>
							</element>
							<element name="MbFunc_ReadHoldingRegs">
								<descr>0x03 Read Holding Registers</descr>
								<value>3</value>
							</element>
							<element name="MbFunc_ReadInputRegs">
								<descr>0x04 Read Input Registers</descr>
								<value>4</value>
							</element>
							<element name="MbFunc_WriteSingleCoil">
								<descr>0x05 Write Single Coil</descr>
								<value>5</value>
							</element>
							<element name="MbFunc_WriteSingleReg">
								<descr>0x06 Write Single Register</descr>
								<value>6</value>
							</element>
							<element name="MbFunc_WriteMultipleCoils">
								<descr>0x0F Write Multiple Coils</descr>
								<value>15</value>
							</element>
							<element name="MbFunc_WriteMultipleRegs">
								<descr>0x10 Write Multiple Registers</descr>
								<value>16</value>
							</element>
						</elements>
					</enum>
					<enum name="MbException" version="1.0.0">
						<descr>Modbus Exception code</descr>
						<elements>
							<element name="MbExc_Ok">
								<descr>No Error</descr>
								<value>0</value>
							</element>
							<element name="MbExc_IllegalFunction">
								<descr>Illegal function</descr>
								<value>1</value>
							</element>
							<element name="MbExc_IllegalDataAddress">
								<descr>Illegal data address</descr>
								<value>2</value>
							</element>
							<element name="MbExc_IllegalDataValue">
								<descr>Illegal data value</descr>
								<value>3</value>
							</element>
							<element name="MbExc_SlaveDeviceFailure">
								<descr>Slave device failure</descr>
								<value>4</value>
							</element>
							<element name="MbExc_Acknowledge">
								<descr>Acknowledge</descr>
								<value>5</value>
							</element>
							<element name="MbExc_SlaveDeviceBusy">
								<descr>Slave device busy</descr>
								<value>6</value>
							</element>
							<element name="MbExc_MemoryParityError">
								<descr>Memory parity error</descr>
								<value>7</value>
							</element>
							<element name="MbExc_GatewayPathUnavailable">
								<descr>Gateway path unavailable</descr>
								<value>10</value>
							</element>
							<element name="MbExc_GatewayTargetDevice">
								<descr>Gateway target device failed to respond</descr>
								<value>11</value>
							</element>
						</elements>
					</enum>
					<enum name="MbError" version="1.0.0">
						<descr>Modbus Master Error decoding, use for master and slave error</descr>
						<elements>
							<element name="MbError_Ok">
								<descr>No error</descr>
								<value>0</value>
							</element>
							<element name="MbError_System">
								<descr>System, internal error</descr>
								<value>1</value>
							</element>
							<element name="MbError_CommChn">
								<descr>Error on communication channel</descr>
								<value>8</value>
							</element>
							<element name="MbError_CommHdl">
								<descr>Invalid communication handle</descr>
								<value>11</value>
							</element>
							<element name="MbError_CommTx">
								<descr>Impossible to send request</descr>
								<value>12</value>
							</element>
							<element name="MbError_CommOpen">
								<descr>Cannot open communication port</descr>
								<value>19</value>
							</element>
							<element name="MbError_SlaveMaxNum">
								<descr>Maximum number of slave</descr>
								<value>20</value>
							</element>
							<element name="MbError_SlaveAddrressInvalid">
								<descr>Invalid slave address</descr>
								<value>21</value>
							</element>
							<element name="MbError_SlaveNotCfg">
								<descr>Slave not exist in netlist</descr>
								<value>22</value>
							</element>
							<element name="MbError_SlaveInUse">
								<descr>Slave address already in use</descr>
								<value>23</value>
							</element>
							<element name="MbError_SlaveLoss">
								<descr>Slave loss</descr>
								<value>24</value>
							</element>
							<element name="MbError_MsgMaxNum">
								<descr>Maximum number of modbus message</descr>
								<value>30</value>
							</element>
							<element name="MbError_MsgFnzInvalid">
								<descr>Invalid modbus function</descr>
								<value>31</value>
							</element>
							<element name="MbError_MsgFnzSize">
								<descr>Invalid modbus function dimension</descr>
								<value>32</value>
							</element>
							<element name="MbError_MsgDatablockInvalid">
								<descr>Invalid datablock</descr>
								<value>33</value>
							</element>
							<element name="MbError_ParamInvalid">
								<descr>System, internal error</descr>
								<value>40</value>
							</element>
							<element name="MbError_ParamException">
								<descr>Exception occured</descr>
								<value>41</value>
							</element>
							<element name="MbError_ParamTimeout">
								<descr>Timeout</descr>
								<value>42</value>
							</element>
						</elements>
					</enum>
					<enum name="MbChn" version="1.0.0">
						<descr>Handler to identify which serial use, for example in modbus master function block</descr>
						<elements>
							<element name="MbChn_0">
								<descr>Handler for use serial 1</descr>
								<value>0</value>
							</element>
							<element name="MbChn_1">
								<descr>Handler for use serial 2</descr>
								<value>1</value>
							</element>
						</elements>
					</enum>
					<enum name="MbBaudrate" version="1.0.0">
						<descr>Modbus RTU communication baudrate</descr>
						<elements>
							<element name="MbBaud_600">
								<descr>600 bit/s</descr>
								<value>600</value>
							</element>
							<element name="MbBaud_1200">
								<descr>1200 bit/s</descr>
								<value>1200</value>
							</element>
							<element name="MbBaud_2400">
								<descr>2400 bit/s</descr>
								<value>2400</value>
							</element>
							<element name="MbBaud_4800">
								<descr>4800 bit/s</descr>
								<value>4800</value>
							</element>
							<element name="MbBaud_9600">
								<descr>9600 bit/s</descr>
								<value>9600</value>
							</element>
							<element name="MbBaud_19200">
								<descr>19200 bit/s</descr>
								<value>19200</value>
							</element>
							<element name="MbBaud_38400">
								<descr>38400 bit/s</descr>
								<value>38400</value>
							</element>
							<element name="MbBaud_57600">
								<descr>57600 bit/s</descr>
								<value>57600</value>
							</element>
							<element name="MbBaud_76800">
								<descr>76800 bit/s</descr>
								<value>76800</value>
							</element>
							<element name="MbBaud_115200">
								<descr>115200 bit/s</descr>
								<value>115200</value>
							</element>
							<element name="MbBaud_Auto">
								<descr>Selected by low level driver</descr>
								<value>0</value>
							</element>
						</elements>
					</enum>
					<enum name="MbRSMode" version="1.0.0">
						<descr>Serial port RS mode</descr>
						<elements>
							<element name="RSMode_Auto">
								<descr>Automatic configuration</descr>
								<value>0</value>
							</element>
							<element name="RSMode_485">
								<descr>RS485 mode</descr>
								<value>1</value>
							</element>
							<element name="RSMode_422">
								<descr>RS422 mode</descr>
								<value>2</value>
							</element>
							<element name="RSMode_232">
								<descr>RS232 mode</descr>
								<value>3</value>
							</element>
						</elements>
					</enum>
				</enums>
				<subranges/>
				<interfaces/>
			</lib>
			<lib version="1.0.0" name="c:\program files (x86)\arduino plc ide\catalog\arduinoopta_1p2\arduinoopta\..\Libraries\AlModbusTCPMaster.plclib" fullXml="true" link="true">
				<descr/>
				<libWorkspace>
					<folder name="Modbus_master_TCP">
						<Pou name="sysMbMTcp_InitMemory"/>
						<Pou name="sysMbMTcp_InitProcessImages"/>
						<Pou name="sysMbMTcp_CheckMemorySize"/>
						<Pou name="sysMbMTcp_InitNetConfiguration"/>
						<GlobalVars name="Diagnostics"/>
						<Pou name="sysMbMTcp_ReadReg_RO"/>
						<Pou name="sysMbMTcp_ReadReg_RW"/>
						<Pou name="sysMbMTcp_WriteReg_M"/>
						<Pou name="sysMbMTcp_WriteReg_S"/>
						<folder name="Enumerations">
							<Definition name="sysMbMTcpEsi"/>
							<Definition name="sysMbMTcpTypeD"/>
							<Definition name="sysMbMTcpTypeImage"/>
						</folder>
						<folder name="Structures">
							<Definition name="MbTcpSlaveState"/>
							<Definition name="MbTcpState"/>
							<Definition name="sysMbMTcpSlaveParam"/>
							<Definition name="sysMbMTcpSlaveImage"/>
							<Definition name="sysMbMTcpSlave"/>
							<Definition name="sysMbMTcpPlcImage"/>
						</folder>
					</folder>
				</libWorkspace>
				<globalVars>
					<group name="Diagnostics">
						<var name="sysMbTcpSlaveState" type="MbTcpSlaveState" dim0="17">
							<address type="I" typeVar="B" index="60020" subIndex="0"/>
						</var>
						<var name="sysMbTcpMState" type="MbTcpState">
							<address type="I" typeVar="B" index="60021" subIndex="0"/>
						</var>
					</group>
				</globalVars>
				<retainVars>
					<group name="Diagnostics"/>
				</retainVars>
				<constantVars>
					<group name="Diagnostics"/>
				</constantVars>
				<iecVarsDeclaration>
					<group name="Diagnostics">
						<iecDeclaration active="FALSE"/>
					</group>
				</iecVarsDeclaration>
				<functions>
					<function name="sysMbMTcp_CheckMemorySize" hidden="true" version="1.0.0" creationDate="1568714837" lastModifiedDate="1568715971">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="mb_param_info_size" type="UINT">
									<descr>MB_PARAM_INFO size</descr>
								</var>
								<var name="mb_image_info_size" type="UINT">
									<descr>MB_IMAGE_INFO size</descr>
								</var>
								<var name="mb_plc_info_size" type="UINT">
									<descr>MB_PLC_INFO size</descr>
								</var>
								<var name="mb_queue_msg_size" type="UINT">
									<descr>MB_QUEUE_MSG size</descr>
								</var>
								<var name="mb_inpout_cmd_size" type="UINT">
									<descr>MB_INPOUT_CMD_SIZE size</descr>
								</var>
								<var name="mbadu_size" type="UINT">
									<descr>MBADU size</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMTcp_InitMemory" hidden="true" version="1.0.0" creationDate="1568714837" lastModifiedDate="1568715971">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="adrMbQueueMsgMemory" type="DWORD">
									<descr>address of MbQueueMsg</descr>
								</var>
								<var name="numMbQueueMsg" type="UDINT">
									<descr>max number of messages</descr>
								</var>
								<var name="adrMBADUMemory" type="DWORD">
									<descr>data pool for packets memory</descr>
								</var>
								<var name="numMBADU" type="UDINT">
									<descr>max number of MBADU packets</descr>
								</var>
								<var name="adrMbInpOutCmdMemory" type="DWORD">
									<descr>data pool for inpout msg</descr>
								</var>
								<var name="numMbInpOutCmd" type="UDINT">
									<descr>max number of inpout msg</descr>
								</var>
								<var name="adrInfoParamsMemory" type="DWORD">
									<descr>additional memory for params</descr>
								</var>
								<var name="adrInfoImageMemory" type="DWORD">
									<descr>additional memory for images</descr>
								</var>
								<var name="adrInfoProcInpMemory" type="DWORD">
									<descr>additional memory for process images input</descr>
								</var>
								<var name="adrInfoProcOutMemory" type="DWORD">
									<descr>additional memory for process images output</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMTcp_InitProcessImages" hidden="true" version="1.0.0" creationDate="1568714837" lastModifiedDate="1568715971">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="adrImgDiscInputStatusMemory" type="DWORD">
									<descr>address of ImgDiscInputStatusMemory</descr>
								</var>
								<var name="adrImgCoilStatusMemory" type="DWORD">
									<descr>address of ImgCoilStatusMemory</descr>
								</var>
								<var name="adrImgRegInputStatusMemory" type="DWORD">
									<descr>address of ImgRegInputStatusMemory</descr>
								</var>
								<var name="adrImgHoldRegStatusMemory" type="DWORD">
									<descr>address of ImgHoldRegStatusMemory</descr>
								</var>
								<var name="adrImgCoilStatusAuxInMemory" type="DWORD">
									<descr>address of ImgCoilStatusAuxInMemory</descr>
								</var>
								<var name="adrImgHoldRegStatusAuxInMemory" type="DWORD">
									<descr>address of ImgHoldRegStatusAuxInMemory</descr>
								</var>
								<var name="adrImgCoilStatusAuxOutMemory" type="DWORD">
									<descr>address of ImgCoilStatusAuxOutMemory</descr>
								</var>
								<var name="numImgHoldRegStatusAuxIn" type="DWORD">
									<descr>number of UINT process images</descr>
								</var>
								<var name="numImgDiscInputStatus" type="DWORD">
									<descr>number of BOOL process images</descr>
								</var>
								<var name="numImgCoilStatus" type="DWORD">
									<descr>number of BOOL process images</descr>
								</var>
								<var name="numImgRegInputStatus" type="DWORD">
									<descr>number of UINT process images</descr>
								</var>
								<var name="numImgHoldRegStatus" type="DWORD">
									<descr>number of UINT process images</descr>
								</var>
								<var name="numImgCoilStatusAuxIn" type="DWORD">
									<descr>number of BOOL process images</descr>
								</var>
								<var name="numImgHoldRegStatusAuxIn" type="DWORD">
									<descr>number of UINT process images</descr>
								</var>
								<var name="numImgCoilStatusAuxOut" type="DWORD">
									<descr>number of BOOL process images</descr>
								</var>
								<var name="numImgHoldRegStatusAuxIn" type="DWORD">
									<descr>number of UINT process images</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
					<function name="sysMbMTcp_InitNetConfiguration" hidden="true" version="1.0.0" creationDate="1568714837" lastModifiedDate="1568715971">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="numTotMasters" type="USINT">
									<descr>total number of masters</descr>
								</var>
								<var name="numTotSlaves" type="USINT">
									<descr>total number of slaves</descr>
								</var>
								<var name="numTotParams" type="UINT">
									<descr>total number of params</descr>
								</var>
								<var name="numTotImages" type="UINT">
									<descr>total number of images</descr>
								</var>
								<var name="numTotProcInput" type="UINT">
									<descr>total number of input processes</descr>
								</var>
								<var name="numTotProcOutput" type="UINT">
									<descr>total number of output processes</descr>
								</var>
								<var name="adrSlavesDefs" type="DWORD">
									<descr>address of slaves definition array</descr>
								</var>
								<var name="adrParamsDefs" type="DWORD">
									<descr>address of params definition array</descr>
								</var>
								<var name="adrImgsDefs" type="DWORD">
									<descr>address of images definition array</descr>
								</var>
								<var name="adrProcInDefs" type="DWORD">
									<descr>address of input processes definition array</descr>
								</var>
								<var name="adrProcOutDefs" type="DWORD">
									<descr>address of output processes definition array</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="EMBEDDED"/>
					</function>
				</functions>
				<functionBlocks>
					<functionBlock name="sysMbMTcp_WriteReg_S" version="1.0.0" creationDate="1568985303" lastModifiedDate="1568985417">
						<descr>Write modbus register using WriteSingleRegister modbus command</descr>
						<vars>
							<inputVars>
								<var name="node" type="UINT">
									<descr>The index of the node in the network</descr>
								</var>
								<var name="reg_addr" type="UINT">
									<descr>The address of the register to read</descr>
								</var>
								<var name="data_type" type="sysMbMTcpTypeD">
									<descr>The type of the data to read</descr>
								</var>
								<var name="data_raw" type="DWORD">
									<descr>Data to be written</descr>
								</var>
								<var name="tmo" type="UDINT">
									<descr>Timeout in ms</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="esi" type="sysMbMTcpEsi">
									<descr>Operation result</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMTcp_WriteReg_M" version="1.0.0" creationDate="1568984942" lastModifiedDate="1568985143">
						<descr>Write modbus register using WriteMultipleRegisters modbus command</descr>
						<vars>
							<inputVars>
								<var name="node" type="UINT">
									<descr>The index of the node in the network</descr>
								</var>
								<var name="reg_addr" type="UINT">
									<descr>The address of the register to read</descr>
								</var>
								<var name="data_type" type="sysMbMTcpTypeD">
									<descr>The type of the data to read</descr>
								</var>
								<var name="data_raw" type="DWORD">
									<descr>Data to be written</descr>
								</var>
								<var name="tmo" type="UDINT">
									<descr>Timeout in ms</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="esi" type="sysMbMTcpEsi">
									<descr>Operation result</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMTcp_ReadReg_RW" version="1.0.0" creationDate="1568984370" lastModifiedDate="1568984752">
						<descr>Read RW modbus register using ReadHoldingRegister modbus command</descr>
						<vars>
							<inputVars>
								<var name="node" type="UINT">
									<descr>The index of the node in the network</descr>
								</var>
								<var name="reg_addr" type="UINT">
									<descr>The address of the register to read</descr>
								</var>
								<var name="data_type" type="sysMbMTcpTypeD">
									<descr>The type of the data to read</descr>
								</var>
								<var name="tmo" type="UDINT">
									<descr>Timeout in ms</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="esi" type="sysMbMTcpEsi">
									<descr>Operation result</descr>
								</var>
								<var name="res_dword" type="DWORD">
									<descr>Result is always put in a dword</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
					<functionBlock name="sysMbMTcp_ReadReg_RO" version="1.0.0" creationDate="1568984177" lastModifiedDate="1568984281">
						<descr>Read RO modbus register using ReadInputRegister modbus command</descr>
						<vars>
							<inputVars>
								<var name="node" type="UINT">
									<descr>The index of the node in the network</descr>
								</var>
								<var name="reg_addr" type="UINT">
									<descr>The address of the register to read</descr>
								</var>
								<var name="data_type" type="sysMbMTcpTypeD">
									<descr>The type of the data to read</descr>
								</var>
								<var name="tmo" type="UDINT">
									<descr>Timeout in ms</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="esi" type="sysMbMTcpEsi">
									<descr>Operation result</descr>
								</var>
								<var name="res_dword" type="DWORD">
									<descr>Result is always put in a dword</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="EMBEDDED"/>
					</functionBlock>
				</functionBlocks>
				<programs/>
				<macros/>
				<structs>
					<struct name="sysMbMTcpPlcImage" hidden="true" version="1.0.0">
						<vars>
							<var name="node" type="USINT">
								<descr>node address</descr>
							</var>
							<var name="block" type="USINT">
								<descr>Input, Output, Input/Output</descr>
							</var>
							<var name="type" type="USINT">
								<descr>bit/word</descr>
							</var>
							<var name="reserved1" type="USINT">
								<descr>reserved1</descr>
							</var>
							<var name="address" type="UINT">
								<descr>Modbus address</descr>
							</var>
							<var name="bitn" type="USINT">
								<descr>Bit extraction offset</descr>
							</var>
							<var name="dbType" type="USINT">
								<descr>Datablock type (M/I/Q)</descr>
							</var>
							<var name="db" type="UDINT">
								<descr>Datablock index</descr>
							</var>
							<var name="db_off" type="UDINT">
								<descr>Datablock offset</descr>
							</var>
							<var name="db_byteoff" type="UDINT">
								<descr>Additional byte offset from physical address calculated with logical address</descr>
							</var>
							<var name="type_v" type="USINT">
								<descr>Image variable type</descr>
							</var>
							<var name="reserved2" type="USINT">
								<descr>reserved2</descr>
							</var>
							<var name="reserved3" type="USINT">
								<descr>reserved3</descr>
							</var>
							<var name="reserved4" type="USINT">
								<descr>reserved4</descr>
							</var>
						</vars>
					</struct>
					<struct name="sysMbMTcpSlave" hidden="true" version="1.0.0">
						<vars>
							<var name="node" type="USINT">
								<descr>node addres</descr>
							</var>
							<var name="address" type="USINT">
								<descr>Modbus address</descr>
							</var>
							<var name="TCPport" type="UINT">
								<descr>TCPport (default 502)</descr>
							</var>
							<var name="Ip" type="STRING" length="15"/>
						</vars>
					</struct>
					<struct name="sysMbMTcpSlaveImage" hidden="true" version="1.0.0">
						<vars>
							<var name="node" type="USINT">
								<descr>Node address</descr>
							</var>
							<var name="funcode" type="USINT">
								<descr>Modbus Function</descr>
							</var>
							<var name="block" type="USINT">
								<descr>Input, Output, Input/Output</descr>
							</var>
							<var name="type" type="USINT">
								<descr>bit/word</descr>
							</var>
							<var name="RdAddress" type="UINT">
								<descr>Modbus read address</descr>
							</var>
							<var name="dimRd" type="UINT">
								<descr>Read data length</descr>
							</var>
							<var name="WrAddress" type="UINT">
								<descr>Modbus write address</descr>
							</var>
							<var name="dimWr" type="UINT">
								<descr>Write data length</descr>
							</var>
							<var name="poll_time" type="UDINT">
								<descr>Polling time</descr>
							</var>
							<var name="tmo" type="UDINT">
								<descr>request timeout</descr>
							</var>
							<var name="waitBeforeSend" type="UDINT">
								<descr>Wait time before transmission</descr>
							</var>
							<var name="db_oneshot" type="UDINT">
								<descr>Datablock index for oneshot variable</descr>
							</var>
							<var name="db_off_oneshot" type="UDINT">
								<descr>Datablock offset for oneshot variable</descr>
							</var>
							<var name="dbByteOffset_oneshot" type="UDINT">
								<descr>Additional byte offset from physical address calculated with logical address</descr>
							</var>
							<var name="hasOneShotVar" type="USINT">
								<descr>Oneshot function presence flag</descr>
							</var>
							<var name="dbType_oneshot" type="USINT">
								<descr>Datablock type (M/I/Q) of oneshot variable</descr>
							</var>
							<var name="writeFirst" type="USINT">
								<descr>Write or Read as first operation (only with input_outputonchange)</descr>
							</var>
							<var name="reserved" type="USINT">
								<descr>Reserved</descr>
							</var>
						</vars>
					</struct>
					<struct name="sysMbMTcpSlaveParam" hidden="true" version="1.0.0">
						<vars>
							<var name="node" type="USINT">
								<descr>node address</descr>
							</var>
							<var name="type_d" type="USINT">
								<descr>data type</descr>
							</var>
							<var name="address" type="UINT">
								<descr>modbus address</descr>
							</var>
							<var name="tmo" type="UDINT">
								<descr>timeout</descr>
							</var>
							<var name="data" type="DWORD">
								<descr>data type union</descr>
							</var>
						</vars>
					</struct>
					<struct name="MbTcpState" version="1.0.0">
						<vars>
							<var name="netConfigOk" type="BOOL">
								<descr>Net configuration OK</descr>
							</var>
							<var name="clientOK" type="BOOL">
								<descr>driver client initialized</descr>
							</var>
							<var name="clientRun" type="BOOL">
								<descr>driver client is running</descr>
							</var>
							<var name="taskRun" type="BOOL">
								<descr>communicaton task is running</descr>
							</var>
							<var name="sysMemoryError" type="BOOL">
								<descr>memory configuration error. this field is used for debug</descr>
							</var>
						</vars>
					</struct>
					<struct name="MbTcpSlaveState" version="1.0.0">
						<vars>
							<var name="cfg" type="BOOL">
								<descr>configured</descr>
							</var>
							<var name="pres" type="BOOL">
								<descr>present</descr>
							</var>
							<var name="active" type="BOOL">
								<descr>active node</descr>
							</var>
							<var name="miss" type="BOOL">
								<descr>delay cycle</descr>
							</var>
							<var name="IP" type="STRING" length="19">
								<descr>IP address</descr>
							</var>
							<var name="address" type="UINT">
								<descr>Subnet modbus address</descr>
							</var>
							<var name="missCnt" type="UINT">
								<descr>delay cycles counter</descr>
							</var>
							<var name="state" type="INT">
								<descr>last modbus error on slave</descr>
							</var>
							<var name="netStat" type="UINT">
								<descr>slave status</descr>
							</var>
						</vars>
					</struct>
				</structs>
				<typedefs/>
				<enums>
					<enum name="sysMbMTcpTypeImage" hidden="true" version="1.0.0">
						<elements>
							<element name="MB_TCP_IMG_BLOCK_INPUT">
								<descr>input</descr>
								<value>0</value>
							</element>
							<element name="MB_TCP_IMG_BLOCK_OUTPUT">
								<descr>output</descr>
								<value>1</value>
							</element>
							<element name="MB_TCP_IMG_BLOCK_INPOUT">
								<descr>input/output</descr>
								<value>2</value>
							</element>
							<element name="MB_TCP_IMG_BLOCK_INPOUTONCHANGE">
								<descr>input/output on change</descr>
								<value>3</value>
							</element>
						</elements>
					</enum>
					<enum name="sysMbMTcpTypeD" version="1.0.0">
						<elements>
							<element name="MB_TCP_DATA_T_SINT">
								<descr>SINT</descr>
								<value>0</value>
							</element>
							<element name="MB_TCP_DATA_T_USINT">
								<descr>USINT</descr>
								<value>1</value>
							</element>
							<element name="MB_TCP_DATA_T_BYTE">
								<descr>BYTE</descr>
								<value>2</value>
							</element>
							<element name="MB_TCP_DATA_T_INT">
								<descr>INT</descr>
								<value>3</value>
							</element>
							<element name="MB_TCP_DATA_T_UINT">
								<descr>UINT</descr>
								<value>4</value>
							</element>
							<element name="MB_TCP_DATA_T_WORD">
								<descr>WORD</descr>
								<value>5</value>
							</element>
							<element name="MB_TCP_DATA_T_DINT">
								<descr>DINT</descr>
								<value>6</value>
							</element>
							<element name="MB_TCP_DATA_T_UDINT">
								<descr>UDINT</descr>
								<value>7</value>
							</element>
							<element name="MB_TCP_DATA_T_DWORD">
								<descr>DWORD</descr>
								<value>8</value>
							</element>
							<element name="MB_TCP_DATA_T_REAL">
								<descr>REAL</descr>
								<value>9</value>
							</element>
							<element name="MB_TCP_DATA_T_BOOL">
								<descr>BOOL</descr>
								<value>10</value>
							</element>
							<element name="MB_TCP_DATA_T_NULL">
								<descr>NULL</descr>
								<value>255</value>
							</element>
						</elements>
					</enum>
					<enum name="sysMbMTcpEsi" version="1.0.0">
						<descr>Return value from modbus function call</descr>
						<elements>
							<element name="MB_TCP_E_NETWORK">
								<descr>Invalid network id specified</descr>
								<value>-339</value>
							</element>
							<element name="MB_TCP_E_CHECKSUM">
								<descr>Checksum</descr>
								<value>-338</value>
							</element>
							<element name="MB_TCP_E_NEGATIVEACKNOWLEDGE">
								<descr>Negative acknowledge</descr>
								<value>-337</value>
							</element>
							<element name="MB_TCP_E_NOTALLOWEDINTIMEDTASK">
								<descr>Function cannot be called in a timed task</descr>
								<value>-336</value>
							</element>
							<element name="MB_TCP_E_SWITCHEDOFF">
								<descr>Node is switched off</descr>
								<value>-335</value>
							</element>
							<element name="MB_TCP_E_ILLEGALDATAPROTOCOL">
								<descr>Illegal data value in protocol</descr>
								<value>-332</value>
							</element>
							<element name="MB_TCP_E_TIMEOUT">
								<descr>Time out richiesta</descr>
								<value>-331</value>
							</element>
							<element name="MB_TCP_E_GATEWAYDEVICEFAILED">
								<descr>Gateway target device failed to respond</descr>
								<value>-330</value>
							</element>
							<element name="MB_TCP_E_GATEWAYPATHUNAV">
								<descr>Gateway path unavailable</descr>
								<value>-329</value>
							</element>
							<element name="MB_TCP_E_MEMORYPARITYERROR">
								<descr>Memory parity error</descr>
								<value>-328</value>
							</element>
							<element name="MB_TCP_E_SLAVEDEVICEBUSY">
								<descr>Slave device busy</descr>
								<value>-327</value>
							</element>
							<element name="MB_TCP_E_ACKNOWLEDGE">
								<descr>Acknowledge</descr>
								<value>-326</value>
							</element>
							<element name="MB_TCP_E_SLAVEDEVICEFAILURE">
								<descr>Slave device failure</descr>
								<value>-325</value>
							</element>
							<element name="MB_TCP_E_ILLEGALDATAVALUE">
								<descr>Illegal data value</descr>
								<value>-324</value>
							</element>
							<element name="MB_TCP_E_ILLEGALDATAADDR">
								<descr>Illegal data address</descr>
								<value>-323</value>
							</element>
							<element name="MB_TCP_E_ILLEGALFUNCTION">
								<descr>Illegal function</descr>
								<value>-322</value>
							</element>
							<element name="MB_TCP_E_IDE">
								<descr>Ide doesn't match</descr>
								<value>-321</value>
							</element>
							<element name="MB_TCP_E_PROTOCOL">
								<descr>Protocol error</descr>
								<value>-320</value>
							</element>
							<element name="MB_TCP_E_DATATYPE">
								<descr>Data type parameter not valid</descr>
								<value>-311</value>
							</element>
							<element name="MB_TCP_E_NODENOTEXIST">
								<descr>Not assigned node</descr>
								<value>-303</value>
							</element>
							<element name="MB_TCP_E_NODE">
								<descr>Not valid node</descr>
								<value>-301</value>
							</element>
							<element name="MB_TCP_E_OK">
								<descr>Successful command</descr>
								<value>0</value>
							</element>
						</elements>
					</enum>
				</enums>
				<subranges/>
				<interfaces/>
			</lib>
			<lib version="1.0.0" name="C:\Users\Davide\Desktop\NordWest\Librerie\NordWest.plclib" fullXml="true" link="true">
				<descr/>
				<libWorkspace>
					<folder name="NordWest">
						<Pou name="Allarmi"/>
						<Pou name="Calc_Temperatura"/>
						<Pou name="Clock_Gen"/>
						<Pou name="Copia_Dati"/>
						<Pou name="Default_Value"/>
						<Pou name="Main"/>
						<Pou name="Output"/>
						<Pou name="Ritenzione"/>
						<Pou name="Sbrinamento"/>
						<Pou name="ScalaLineare" genHidden="false"/>
						<Pou name="Stati"/>
						<Pou name="VelocitaVentola"/>
					</folder>
				</libWorkspace>
				<globalVars/>
				<retainVars/>
				<constantVars/>
				<iecVarsDeclaration/>
				<functions/>
				<functionBlocks>
					<functionBlock name="Calc_Temperatura" version="1.0.0" creationDate="1728475731" lastModifiedDate="1728475909">
						<vars>
							<inputVars>
								<var name="AnaInput" type="REAL"/>
							</inputVars>
							<outputVars>
								<var name="T_Out" type="REAL"/>
							</outputVars>
							<localConsts>
								<const name="a" type="REAL">
									<initValue>0.0039083</initValue>
								</const>
								<const name="b" type="REAL">
									<initValue>-0.0000005775</initValue>
								</const>
							</localConsts>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[T_Out := (-(1.0 / 100.0) * (50.0 * a - 10*sqrt(b * AnaInput + 25.0 * pow(a, 2.0) - 100.0 * b))) / b;
]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="Clock_Gen" version="1.0.0" creationDate="1728628073" lastModifiedDate="1728628391">
						<vars>
							<inputVars>
								<var name="Tempo" type="UDINT"/>
							</inputVars>
							<outputVars>
								<var name="Out" type="BOOL"/>
							</outputVars>
							<localVars>
								<var name="Timer_1" type="TON"/>
								<var name="Timer_2" type="TOF"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="LD2">
							<LD2 version="1">
								<network label="" id="1" nextID="4" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<funcBlock name="TON" id="2" instance="Timer_1">
												<inputs>
													<pin name="IN" neg="false" type="BOOL">
														<contact name="Timer_2.Q" type="Closed" id="0"/>
													</pin>
													<pin name="PT" neg="false" type="UDINT">
														<var name="Tempo" id="3"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="Q" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="ET" neg="false" type="UDINT"/>
												</outputs>
											</funcBlock>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="2" nextID="6" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<funcBlock name="TOF" id="3" instance="Timer_2">
												<inputs>
													<pin name="IN" neg="false" type="BOOL">
														<contact name="Timer_1.Q" type="Normal" id="0"/>
													</pin>
													<pin name="PT" neg="false" type="UDINT">
														<var name="Tempo" id="4"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="Q" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="ET" neg="false" type="UDINT"/>
												</outputs>
											</funcBlock>
										</input>
										<outputs>
											<coil name="Out" type="Normal" id="5"/>
										</outputs>
									</assignment>
								</network>
							</LD2>
						</sourceCode>
					</functionBlock>
					<functionBlock name="ScalaLineare" version="1.0.0" creationDate="1728474704" lastModifiedDate="1730456325">
						<vars>
							<inputVars>
								<var name="in_val" type="REAL"/>
								<var name="In_min" type="REAL"/>
								<var name="In_max" type="REAL"/>
								<var name="out_min" type="REAL"/>
								<var name="out_max" type="REAL"/>
							</inputVars>
							<outputVars>
								<var name="out" type="REAL"/>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[
IF (in_val < in_min) THEN 

	in_val := in_min;
	
END_IF;

IF (in_val > in_max) THEN 

	in_val := in_max;
	
END_IF;
	

IF (in_min <> 0.0 and in_max <>0.0) THEN 


out := (in_val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;

ELSE

	out := out_min;
	
END_IF;


IF (out < out_min) THEN
	out := out_min;
END_IF;

if (out > out_max) then
	out := out_max;
END_IF;



]]>
						</sourceCode>
					</functionBlock>
				</functionBlocks>
				<programs>
					<program name="Allarmi" version="1.0.0" creationDate="1728394010" lastModifiedDate="1729238041">
						<vars>
							<localVars>
								<var name="Dummy_DWord" type="DWORD"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="LD2">
							<LD2 version="1">
								<network label="" id="1" nextID="3" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="ibEmgKo" type="Normal" id="0"/>
										</input>
										<outputs>
											<coil name="bAllarmeEmg" type="Normal" id="1"/>
											<coil name="Dummy_DWord.0" type="Normal" id="2"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="2" nextID="3" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="ibInverterOk" type="Closed" id="0"/>
										</input>
										<outputs>
											<coil name="bAllarmeInv" type="Normal" id="1"/>
											<coil name="Dummy_DWord.1" type="Normal" id="2"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="3" nextID="3" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="ibscattoTermico" type="Normal" id="0"/>
										</input>
										<outputs>
											<coil name="bAllarmeTer" type="Normal" id="1"/>
											<coil name="Dummy_DWord.2" type="Normal" id="2"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="4" nextID="3" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="ibEmgKo" type="Normal" id="0"/>
										</input>
										<outputs>
											<coil name="bAllarmeEmg" type="Normal" id="1"/>
											<coil name="Dummy_DWord.3" type="Normal" id="2"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="5" nextID="8" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="GT" id="3">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="0" neg="false" type="UNDEF">
														<var name="Dummy_DWord" id="4"/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<const name="0" id="7"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="2" neg="false" type="BOOL">
														<var name="b_InAllarme" id="6"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
							</LD2>
						</sourceCode>
					</program>
					<program name="Copia_Dati" version="1.0.0" creationDate="1728910131" lastModifiedDate="1729087427">
						<vars/>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[// Ricette
IF( bInviaRicetta) THEN
wOreImpostate := wRcpOreCiclo  ;
dTempVenFineCic := wRcpDeltaT ;
rSetpoint := rRcpSetTIng ;
rStartForbice := rRcpDeltaTVent;
rForbice:= rRcpDeltaTBanda ;
bInviaRicetta:= FALSE;
END_IF;

	
//Copia Dati Modbus su ritenzione

dContatoreSec_Rt:=dContatoreSec;
dTimerSbrina_Rt:=dTimerSbrina;
dTimerMaxSbrina_Rt:=dTimerMaxSbrina;
rDelta_Rt:=rDelta;
rForbice_Rt:=rForbice;
rSetpoint_Rt:=rSetpoint;
rStartForbice_Rt:=rStartForbice;
rTempFineSbrin_Rt:=rTempFineSbrin;
wMinutiAttuali_Rt:=wMinutiAttuali;
wOreAttuali_Rt:=wOreAttuali;
wOreImpostate_Rt:=wOreImpostate;
dTempVenFineCic_Rt:=dTempVenFineCic;
rPesoTarget_Rt:=rPesoTarget;
wRcpOreCiclo_Rt:=wRcpOreCiclo;
wRcpDeltaT_Rt:=wRcpDeltaT;
rRcpSetTIng_Rt:=rRcpSetTIng;
rRcpDeltaTVent_Rt:=rRcpDeltaTVent;
rRcpDeltaTBanda_Rt:=rRcpDeltaTBanda;
Trendmandata := rTempMandata;
TendRitorno := rTempRitorno;
TrendVentilazione:= rVelVentola;


]]>
						</sourceCode>
					</program>
					<program name="Default_Value" version="1.0.0" creationDate="1728462863" lastModifiedDate="1730457129">
						<vars/>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="LD2">
							<LD2 version="1">
								<network label="" id="1" nextID="53" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="bCaricaDefault" type="Normal" id="0"/>
										</input>
										<outputs>
											<tmpVar id="20"/>
										</outputs>
									</assignment>
									<assignment fromTmpVar="20">
										<input>
											<operator name="MOVE" id="13">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<operator name="MOVE" id="5">
															<inputs>
																<pin name="EN" neg="false" type="BOOL">
																	<operator name="MOVE" id="9">
																		<inputs>
																			<pin name="EN" neg="false" type="BOOL"/>
																			<pin name="0" neg="false" type="UNDEF">
																				<const name="8" id="11"/>
																			</pin>
																		</inputs>
																		<outputs>
																			<pin name="ENO" neg="false" type="BOOL">
																				<outputLine/>
																			</pin>
																			<pin name="1" neg="false" type="UNDEF">
																				<var name="rForbice" id="12"/>
																			</pin>
																		</outputs>
																	</operator>
																</pin>
																<pin name="0" neg="false" type="UNDEF">
																	<const name="35" id="8"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="ENO" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="1" neg="false" type="UNDEF">
																	<var name="rSetpoint" id="7"/>
																</pin>
															</outputs>
														</operator>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="4" id="18"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="rStartForbice" id="19"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
									<assignment fromTmpVar="20">
										<input>
											<operator name="MOVE" id="29">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<operator name="MOVE" id="26">
															<inputs>
																<pin name="EN" neg="false" type="BOOL">
																	<operator name="MOVE" id="23">
																		<inputs>
																			<pin name="EN" neg="false" type="BOOL"/>
																			<pin name="0" neg="false" type="UNDEF">
																				<const name="35" id="24"/>
																			</pin>
																		</inputs>
																		<outputs>
																			<pin name="ENO" neg="false" type="BOOL">
																				<outputLine/>
																			</pin>
																			<pin name="1" neg="false" type="UNDEF">
																				<var name="rTempFineSbrin" id="25"/>
																			</pin>
																		</outputs>
																	</operator>
																</pin>
																<pin name="0" neg="false" type="UNDEF">
																	<const name="100" id="27"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="ENO" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="1" neg="false" type="UNDEF">
																	<var name="wOreImpostate" id="28"/>
																</pin>
															</outputs>
														</operator>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="1000" id="33"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="dTimerSbrina" id="34"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
									<assignment fromTmpVar="20">
										<input>
											<operator name="MOVE" id="49">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<operator name="MOVE" id="37">
															<inputs>
																<pin name="EN" neg="false" type="BOOL"/>
																<pin name="0" neg="false" type="UNDEF">
																	<const name="1000" id="44"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="ENO" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="1" neg="false" type="UNDEF">
																	<var name="dTimerMaxSbrina" id="45"/>
																</pin>
															</outputs>
														</operator>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="0" id="50"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="dTempVenFineCic" id="51"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs>
											<coil name="bCaricaDefault" type="Reset" id="52"/>
										</outputs>
									</assignment>
								</network>
							</LD2>
						</sourceCode>
					</program>
					<program name="Main" version="1.0.0" creationDate="1728381641" lastModifiedDate="1730457541">
						<vars>
							<localVars>
								<var name="bOreDn" type="BOOL"/>
								<var name="TimerStopPeso" type="TON"/>
								<var name="TimerVenFineCiclo" type="TON"/>
								<var name="DummyBit" type="BOOL"/>
								<var name="Clock_1Hz" type="Clock_Gen"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="LD2">
							<LD2 version="1">
								<network label="" id="1" nextID="5" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<funcBlock name="Clock_Gen" id="2" instance="Clock_1Hz">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="Tempo" neg="false" type="UDINT">
														<const name="500" id="3"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="Out" neg="false" type="BOOL">
														<var name="Led_Run" id="4"/>
													</pin>
												</outputs>
											</funcBlock>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="2" nextID="2" comment="Abilitazioni ciclo" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="IbInverterOk" type="Normal" id="0"/>
										</input>
										<outputs>
											<coil name="bAbilitazioni" type="Normal" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="3" nextID="7" comment="Start macchina" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="5">
												<or id="3">
													<contact name="bRqStartLoc" type="Normal" id="2"/>
													<contact name="bRqStartRem" type="Normal" id="0"/>
												</or>
												<contact name="bAbilitazioni" type="Normal" id="4"/>
												<contact name="brqVentilazione" type="Normal" id="6"/>
											</and>
										</input>
										<outputs>
											<coil name="bMarcia" type="Normal" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="4" nextID="2" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="brqVentilazione" type="Closed" id="0"/>
										</input>
										<outputs>
											<coil name="bRqStartLoc" type="Reset" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="5" nextID="9" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="8">
												<operator name="GE" id="2">
													<inputs>
														<pin name="EN" neg="false" type="BOOL"/>
														<pin name="0" neg="false" type="UNDEF">
															<var name="wOreAttuali" id="3"/>
														</pin>
														<pin name="1" neg="false" type="UNDEF">
															<var name="wOreImpostate" id="4"/>
														</pin>
													</inputs>
													<outputs>
														<pin name="ENO" neg="false" type="BOOL">
															<outputLine/>
														</pin>
														<pin name="2" neg="false" type="BOOL">
															<var name="DummyBit" id="6"/>
														</pin>
													</outputs>
												</operator>
												<contact name="DummyBit" type="Normal" id="7"/>
											</and>
										</input>
										<outputs>
											<coil name="bOreDn" type="Normal" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="6" nextID="7" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="4">
												<contact name="bMarcia" type="Normal" id="2"/>
												<or id="6">
													<contact name="bOreDn" type="Normal" id="3"/>
													<contact name="TimerStopPeso.Q" type="Normal" id="5"/>
												</or>
											</and>
										</input>
										<outputs>
											<coil name="bFineCiclo" type="Set" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="7" nextID="3" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="bResetCiclo" type="Normal" id="0"/>
										</input>
										<outputs>
											<coil name="bFineCiclo" type="Reset" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="8" nextID="10" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<funcBlock name="TON" id="4" instance="TimerVenFineCiclo">
												<inputs>
													<pin name="IN" neg="false" type="BOOL">
														<and id="9">
															<contact name="bFineCiclo" type="Normal" id="2"/>
															<contact name="bMarcia" type="Normal" id="8"/>
														</and>
													</pin>
													<pin name="PT" neg="false" type="UDINT">
														<var name="dTempVenFineCic" id="5"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="Q" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="ET" neg="false" type="UDINT"/>
												</outputs>
											</funcBlock>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="9" nextID="6" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="TimerVenFineCiclo.Q" type="Normal" id="2"/>
										</input>
										<outputs>
											<coil name="bRqStartLoc" type="Reset" id="1"/>
											<coil name="bRqVentilazione" type="Reset" id="4"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="10" nextID="15" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="ADD" id="4">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<and id="14">
															<contact name="bMarcia" type="Normal" id="11"/>
															<contact name="Clock_1Hz.Out" type="Positive" id="13"/>
														</and>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="1" id="8"/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="dContatoreSec" id="6"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="2" neg="false" type="UNDEF">
														<var name="dContatoreSec" id="7"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="11" nextID="32" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="25">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<operator name="ADD" id="16">
															<inputs>
																<pin name="EN" neg="false" type="BOOL">
																	<and id="31">
																		<operator name="GE" id="2">
																			<inputs>
																				<pin name="EN" neg="false" type="BOOL"/>
																				<pin name="0" neg="false" type="UNDEF">
																					<var name="dContatoreSec" id="3"/>
																				</pin>
																				<pin name="1" neg="false" type="UNDEF">
																					<const name="60" id="6"/>
																				</pin>
																			</inputs>
																			<outputs>
																				<pin name="ENO" neg="false" type="BOOL">
																					<outputLine/>
																				</pin>
																				<pin name="2" neg="false" type="BOOL">
																					<var name="DummyBit" id="29"/>
																				</pin>
																			</outputs>
																		</operator>
																		<contact name="DummyBit" type="Normal" id="30"/>
																	</and>
																</pin>
																<pin name="0" neg="false" type="UNDEF">
																	<const name="1" id="22"/>
																</pin>
																<pin name="1" neg="false" type="UNDEF">
																	<var name="wMinutiAttuali" id="23"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="ENO" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="2" neg="false" type="UNDEF">
																	<var name="wMinutiAttuali" id="24"/>
																</pin>
															</outputs>
														</operator>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="0" id="28"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="dContatoreSec" id="27"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="12" nextID="38" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="25">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<operator name="ADD" id="16">
															<inputs>
																<pin name="EN" neg="false" type="BOOL">
																	<and id="36">
																		<operator name="GE" id="2">
																			<inputs>
																				<pin name="EN" neg="false" type="BOOL"/>
																				<pin name="0" neg="false" type="UNDEF">
																					<var name="wMinutiAttuali" id="3"/>
																				</pin>
																				<pin name="1" neg="false" type="UNDEF">
																					<const name="60" id="6"/>
																				</pin>
																			</inputs>
																			<outputs>
																				<pin name="ENO" neg="false" type="BOOL">
																					<outputLine/>
																				</pin>
																				<pin name="2" neg="false" type="BOOL">
																					<var name="DummyBit" id="37"/>
																				</pin>
																			</outputs>
																		</operator>
																		<contact name="DummyBit" type="Normal" id="35"/>
																	</and>
																</pin>
																<pin name="0" neg="false" type="UNDEF">
																	<const name="1" id="22"/>
																</pin>
																<pin name="1" neg="false" type="UNDEF">
																	<var name="wOreAttuali" id="23"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="ENO" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="2" neg="false" type="UNDEF">
																	<var name="wOreAttuali" id="24"/>
																</pin>
															</outputs>
														</operator>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="0" id="33"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="wMinutiAttuali" id="34"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="13" nextID="39" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="35">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<operator name="MOVE" id="31">
															<inputs>
																<pin name="EN" neg="false" type="BOOL">
																	<operator name="MOVE" id="2">
																		<inputs>
																			<pin name="EN" neg="false" type="BOOL">
																				<contact name="bResetCiclo" type="Normal" id="0"/>
																			</pin>
																			<pin name="0" neg="false" type="UNDEF">
																				<const name="0" id="10"/>
																			</pin>
																		</inputs>
																		<outputs>
																			<pin name="ENO" neg="false" type="BOOL">
																				<outputLine/>
																			</pin>
																			<pin name="1" neg="false" type="UNDEF">
																				<var name="wOreAttuali" id="11"/>
																			</pin>
																		</outputs>
																	</operator>
																</pin>
																<pin name="0" neg="false" type="UNDEF">
																	<const name="0" id="33"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="ENO" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="1" neg="false" type="UNDEF">
																	<var name="wMinutiAttuali" id="34"/>
																</pin>
															</outputs>
														</operator>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="0" id="37"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="dContatoreSec" id="38"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="14" nextID="5" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="brqVentilazione" type="Closed" id="3"/>
										</input>
										<outputs>
											<coil name="bAttivaJoni" type="Reset" id="2"/>
										</outputs>
									</assignment>
								</network>
							</LD2>
						</sourceCode>
					</program>
					<program name="Output" version="1.0.0" creationDate="1728392786" lastModifiedDate="1730197536">
						<vars>
							<localVars>
								<var name="bTempMandataOk" type="BOOL"/>
								<var name="bTempMandatMin" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="LD2">
							<LD2 version="1">
								<network label="" id="1" nextID="4" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="3">
												<contact name="bMarcia" type="Normal" id="0"/>
												<contact name="bRqSbrinamento" type="Normal" id="2"/>
											</and>
										</input>
										<outputs>
											<coil name="obEvSbrinamento" type="Normal" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="2" nextID="9" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="6">
												<contact name="bRqVentilazione" type="Normal" id="5"/>
												<contact name="bRqSbrinamento" type="Closed" id="7"/>
											</and>
										</input>
										<outputs>
											<coil name="obRicircoloAria" type="Normal" id="1"/>
											<coil name="LedOut3" type="Normal" id="8"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="3" nextID="7" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="3">
												<contact name="bMarcia" type="Normal" id="0"/>
												<or id="5">
													<contact name="ibPresCondensato" type="Closed" id="2"/>
													<contact name="obEvControllo" type="Normal" id="4"/>
												</or>
											</and>
										</input>
										<outputs>
											<coil name="obCondensatore" type="Normal" id="1"/>
											<coil name="LedOut2" type="Normal" id="6"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="4" nextID="8" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="5">
												<contact name="bMarcia" type="Normal" id="2"/>
												<contact name="obEvControllo" type="Closed" id="4"/>
												<contact name="bRqSbrinamento" type="Closed" id="6"/>
											</and>
										</input>
										<outputs>
											<coil name="obEvCondensatore" type="Normal" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="5" nextID="4" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="3">
												<contact name="bMarcia" type="Normal" id="0"/>
												<contact name="bRqSbrinamento" type="Closed" id="2"/>
											</and>
										</input>
										<outputs>
											<coil name="obEvFaseLiquida" type="Normal" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="6" nextID="16" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="SUB" id="11">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="0" neg="false" type="UNDEF">
														<var name="rSetpoint" id="12"/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<const name="0.4" id="15"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="2" neg="false" type="UNDEF">
														<var name="rSetpointDM" id="14"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="7" nextID="14" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="LE" id="10">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<operator name="GE" id="2">
															<inputs>
																<pin name="EN" neg="false" type="BOOL"/>
																<pin name="0" neg="false" type="UNDEF">
																	<var name="rTempMandata" id="3"/>
																</pin>
																<pin name="1" neg="false" type="UNDEF">
																	<var name="rSetpoint" id="4"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="ENO" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="2" neg="false" type="BOOL">
																	<var name="bTempMandataOk" id="5"/>
																</pin>
															</outputs>
														</operator>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<var name="rTempMandata" id="11"/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="rSetpointDM" id="12"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="2" neg="false" type="BOOL">
														<var name="bTempMandatMin" id="13"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="8" nextID="19" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="7">
												<or id="17">
													<contact name="bTempMandataOk" type="Normal" id="15"/>
													<contact name="obEvControllo" type="Normal" id="16"/>
												</or>
												<contact name="bTempMandatMin" type="Closed" id="18"/>
												<contact name="bMarcia" type="Normal" id="12"/>
												<contact name="bRqSbrinamento" type="Closed" id="10"/>
											</and>
										</input>
										<outputs>
											<coil name="obEvControllo" type="Normal" id="1"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="9" nextID="7" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="3">
												<contact name="bMarcia" type="Normal" id="0"/>
												<contact name="bPausaCiclo" type="Closed" id="2"/>
												<contact name="bRqVentilazione" type="Normal" id="4"/>
												<contact name="ibAltaPressOk" type="Normal" id="5"/>
											</and>
										</input>
										<outputs>
											<coil name="obCompressore" type="Normal" id="1"/>
											<coil name="LedOut1" type="Normal" id="6"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="10" nextID="6" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="3">
												<contact name="bAttivaJoni" type="Normal" id="2"/>
												<contact name="obRicircoloAria" type="Normal" id="4"/>
											</and>
										</input>
										<outputs>
											<coil name="obJonizzatore" type="Normal" id="1"/>
											<coil name="LedOut4" type="Normal" id="5"/>
										</outputs>
									</assignment>
								</network>
							</LD2>
						</sourceCode>
					</program>
					<program name="Ritenzione" version="1.0.0" creationDate="1728910802" lastModifiedDate="1730457692">
						<vars/>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[//inizializza i dati modbus ai volori  di ritenzione

dContatoreSec := dContatoreSec_Rt ;
dTimerSbrina := dTimerSbrina_Rt ;
dTimerMaxSbrina := dTimerMaxSbrina_Rt ;
rDelta := rDelta_Rt ;
rForbice := rForbice_Rt ;
rSetpoint := rSetpoint_Rt ;
rStartForbice := rStartForbice_Rt ;
rTempFineSbrin := rTempFineSbrin_Rt ;
wMinutiAttuali := wMinutiAttuali_Rt ;
wOreAttuali := wOreAttuali_Rt ;
wOreImpostate := wOreImpostate_Rt ;
dTempVenFineCic := dTempVenFineCic_Rt ;
rPesoTarget := rPesoTarget_Rt ;
wRcpOreCiclo := wRcpOreCiclo_Rt ;
wRcpDeltaT := wRcpDeltaT_Rt ;
rRcpSetTIng := rRcpSetTIng_Rt ;
rRcpDeltaTVent := rRcpDeltaTVent_Rt ;
rRcpDeltaTBanda := rRcpDeltaTBanda_Rt ;

]]>
						</sourceCode>
					</program>
					<program name="Sbrinamento" version="1.0.0" creationDate="1728391230" lastModifiedDate="1730458163">
						<vars>
							<localVars>
								<var name="Azioni" type="DWORD"/>
								<var name="Transizioni" type="DWORD"/>
								<var name="AzioniZero" type="BOOL"/>
								<var name="TimerSbrina" type="TON"/>
								<var name="TimerMaxSbrina" type="TON"/>
								<var name="b_TempGasOk" type="BOOL"/>
								<var name="TempGas" type="Calc_Temperatura"/>
								<var name="DummyBit" type="BOOL"/>
								<var name="bMinutiDn" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="LD2">
							<LD2 version="1">
								<network label="" id="1" nextID="20" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="17">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="0" neg="false" type="UNDEF">
														<var name="Azioni" id="18"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="Transizioni" id="19"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="2" nextID="9" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="4">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<contact name="bResetCiclo" type="Normal" id="2"/>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="0" id="7"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="Azioni" id="6"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs>
											<coil name="bResetCiclo" type="Reset" id="8"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="3" nextID="16" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="8">
												<operator name="EQ" id="2">
													<inputs>
														<pin name="EN" neg="false" type="BOOL"/>
														<pin name="0" neg="false" type="UNDEF">
															<var name="Azioni" id="3"/>
														</pin>
														<pin name="1" neg="false" type="UNDEF">
															<const name="0" id="15"/>
														</pin>
													</inputs>
													<outputs>
														<pin name="ENO" neg="false" type="BOOL">
															<outputLine/>
														</pin>
														<pin name="2" neg="false" type="BOOL">
															<var name="AzioniZero" id="5"/>
														</pin>
													</outputs>
												</operator>
												<contact name="AzioniZero" type="Normal" id="7"/>
											</and>
										</input>
										<outputs>
											<coil name="Azioni.0" type="Set" id="12"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="4" nextID="7" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="4">
												<contact name="Transizioni.0" type="Normal" id="0"/>
												<contact name="bMarcia" type="Normal" id="3"/>
												<contact name="B_TempGasOk" type="Closed" id="6"/>
											</and>
										</input>
										<outputs>
											<coil name="Azioni.0" type="Reset" id="1"/>
											<coil name="Azioni.1" type="Set" id="2"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="5" nextID="27" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="8">
												<contact name="Transizioni.1" type="Normal" id="0"/>
												<contact name="bMarcia" type="Normal" id="3"/>
											</and>
										</input>
										<outputs>
											<tmpVar id="9"/>
										</outputs>
									</assignment>
									<assignment fromTmpVar="9">
										<input>
											<and id="4">
												<operator name="GE" id="17">
													<inputs>
														<pin name="EN" neg="false" type="BOOL"/>
														<pin name="0" neg="false" type="UNDEF">
															<var name="T_Sbrina_Minuti_Rt" id="21"/>
														</pin>
														<pin name="1" neg="false" type="UNDEF">
															<expression name="dTimerSbrina /1000" id="25"/>
														</pin>
													</inputs>
													<outputs>
														<pin name="ENO" neg="false" type="BOOL">
															<outputLine/>
														</pin>
														<pin name="2" neg="false" type="BOOL">
															<var name="DummyBit" id="23"/>
														</pin>
													</outputs>
												</operator>
												<contact name="DummyBit" type="Normal" id="26"/>
												<contact name="B_TempGasOk" type="Closed" id="7"/>
											</and>
										</input>
										<outputs>
											<coil name="Azioni.1" type="Reset" id="1"/>
											<coil name="Azioni.2" type="Set" id="2"/>
										</outputs>
									</assignment>
									<assignment fromTmpVar="9">
										<input>
											<contact name="B_TempGasOk" type="Normal" id="10"/>
										</input>
										<outputs>
											<coil name="Azioni.1" type="Reset" id="11"/>
											<coil name="Azioni.0" type="Set" id="12"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="6" nextID="9" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="GE" id="2">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="0" neg="false" type="UNDEF">
														<var name="T_Max_Sbrina_Minuti_RT" id="6"/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<expression name="dTimerMaxSbrina /1000" id="7"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="2" neg="false" type="BOOL">
														<var name="bMinutiDn" id="8"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="7" nextID="47" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<and id="38">
												<contact name="Transizioni.2" type="Normal" id="0"/>
												<contact name="bMarcia" type="Normal" id="3"/>
												<or id="44">
													<contact name="bMinutiDn" type="Normal" id="41"/>
													<contact name="b_TempGasOk" type="Normal" id="45"/>
												</or>
											</and>
										</input>
										<outputs>
											<coil name="Azioni.2" type="Reset" id="1"/>
											<coil name="Azioni.0" type="Set" id="2"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="8" nextID="10" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="6">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<operator name="MOVE" id="2">
															<inputs>
																<pin name="EN" neg="false" type="BOOL">
																	<contact name="azioni.0" type="Normal" id="0"/>
																</pin>
																<pin name="0" neg="false" type="UNDEF">
																	<const name="0" id="5"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="ENO" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="1" neg="false" type="UNDEF">
																	<var name="T_Sbrina_Minuti_Rt" id="4"/>
																</pin>
															</outputs>
														</operator>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="0" id="8"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="T_Max_Sbrina_Minuti_RT" id="9"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="9" nextID="21" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="ADD" id="12">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<funcBlock name="TON" id="2" instance="TimerSbrina">
															<inputs>
																<pin name="IN" neg="false" type="BOOL">
																	<and id="20">
																		<contact name="azioni.1" type="Normal" id="0"/>
																		<contact name="TimerSbrina.Q" type="Closed" id="19"/>
																	</and>
																</pin>
																<pin name="PT" neg="false" type="UDINT">
																	<const name="60000" id="11"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="Q" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="ET" neg="false" type="UDINT"/>
															</outputs>
														</funcBlock>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="1" id="16"/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="T_Sbrina_Minuti_Rt" id="14"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="2" neg="false" type="UNDEF">
														<var name="T_Sbrina_Minuti_Rt" id="15"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="10" nextID="33" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<contact name="azioni.2" type="Normal" id="0"/>
										</input>
										<outputs>
											<tmpVar id="6"/>
										</outputs>
									</assignment>
									<assignment fromTmpVar="6">
										<input>
											<operator name="ADD" id="27">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<funcBlock name="TON" id="2" instance="TimerMaxSbrina">
															<inputs>
																<pin name="IN" neg="false" type="BOOL">
																	<contact name="TimerMaxSbrina.Q" type="Closed" id="22"/>
																</pin>
																<pin name="PT" neg="false" type="UDINT">
																	<const name="60000" id="21"/>
																</pin>
															</inputs>
															<outputs>
																<pin name="Q" neg="false" type="BOOL">
																	<outputLine/>
																</pin>
																<pin name="ET" neg="false" type="UDINT"/>
															</outputs>
														</funcBlock>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="1" id="32"/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="T_Max_Sbrina_Minuti_RT" id="30"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="2" neg="false" type="UNDEF">
														<var name="T_Max_Sbrina_Minuti_RT" id="31"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
									<assignment fromTmpVar="6">
										<input>
											<contact name="bMarcia" type="Normal" id="16"/>
										</input>
										<outputs>
											<coil name="bRqSbrinamento" type="Normal" id="8"/>
										</outputs>
									</assignment>
								</network>
								<network label="" id="11" nextID="8" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<funcBlock name="Calc_Temperatura" id="5" instance="TempGas">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="AnaInput" neg="false" type="REAL">
														<var name="irTempGas" id="6"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="T_Out" neg="false" type="REAL">
														<var name="rTempGas" id="7"/>
													</pin>
												</outputs>
											</funcBlock>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="12" nextID="6" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="GE" id="2">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="0" neg="false" type="UNDEF">
														<var name="rTempGas" id="3"/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="rTempFineSbrin" id="4"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="2" neg="false" type="BOOL">
														<var name="B_TempGasOk" id="5"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
							</LD2>
						</sourceCode>
					</program>
					<program name="Stati" version="1.0.0" creationDate="1728458593" lastModifiedDate="1728458829">
						<vars/>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="LD2">
							<LD2 version="1">
								<network label="" id="1" nextID="6" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="2">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<contact name="bMarcia" type="Closed" id="0"/>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="0" id="5"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="wStatus" id="4"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="2" nextID="8" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="2">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<and id="7">
															<contact name="bMarcia" type="Normal" id="0"/>
															<contact name="bAbilitazioni" type="Normal" id="6"/>
														</and>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="1" id="5"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="wStatus" id="4"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="3" nextID="8" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="2">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<and id="7">
															<contact name="bMarcia" type="Normal" id="0"/>
															<contact name="bRqSbrinamento" type="Normal" id="6"/>
														</and>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="2" id="5"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="wStatus" id="4"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="4" nextID="8" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="2">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<contact name="bFineCiclo" type="Normal" id="0"/>
													</pin>
													<pin name="0" neg="false" type="">
														<const name="3" id="5"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="">
														<var name="wStatus" id="4"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="5" nextID="8" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="MOVE" id="2">
												<inputs>
													<pin name="EN" neg="false" type="BOOL">
														<contact name="bAbilitazioni" type="Closed" id="6"/>
													</pin>
													<pin name="0" neg="false" type="UNDEF">
														<const name="4" id="5"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="wStatus" id="4"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
							</LD2>
						</sourceCode>
					</program>
					<program name="VelocitaVentola" version="1.0.0" creationDate="1728457967" lastModifiedDate="1730237309">
						<vars>
							<localVars>
								<var name="DummyBit" type="BOOL"/>
								<var name="Calc_Vel" type="ScalaLineare"/>
								<var name="TempMandata" type="Calc_Temperatura"/>
								<var name="TempRitorno" type="Calc_Temperatura"/>
								<var name="Test" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="LD2">
							<LD2 version="1">
								<network label="" id="1" nextID="26" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<funcBlock name="Calc_Temperatura" id="23" instance="TempMandata">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="AnaInput" neg="false" type="REAL">
														<var name="irTempMandata" id="24"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="T_Out" neg="false" type="BOOL">
														<var name="rTempMandata" id="25"/>
													</pin>
												</outputs>
											</funcBlock>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="2" nextID="11" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<funcBlock name="Calc_Temperatura" id="8" instance="TempRitorno">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="AnaInput" neg="false" type="REAL">
														<var name="irTempRitorno" id="9"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="T_Out" neg="false" type="BOOL">
														<var name="rTempRitorno" id="10"/>
													</pin>
												</outputs>
											</funcBlock>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="3" nextID="6" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<operator name="SUB" id="2">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="0" neg="false" type="UNDEF">
														<var name="rTempMandata" id="3"/>
													</pin>
													<pin name="1" neg="false" type="UNDEF">
														<var name="rTempRitorno" id="4"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="2" neg="false" type="UNDEF">
														<var name="rDelta" id="5"/>
													</pin>
												</outputs>
											</operator>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="4" nextID="14" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<funcBlock name="ScalaLineare" id="2" instance="Calc_Vel">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="in_val" neg="false" type="REAL">
														<var name="rDelta" id="3"/>
													</pin>
													<pin name="In_min" neg="false" type="REAL">
														<var name="rStartForbice" id="4"/>
													</pin>
													<pin name="In_max" neg="false" type="REAL">
														<expression name="rStartForbice + rForbice" id="10"/>
													</pin>
													<pin name="out_min" neg="false" type="REAL">
														<const name="0.0" id="6"/>
													</pin>
													<pin name="out_Max" neg="false" type="REAL">
														<const name="10.0" id="7"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="out" neg="false" type="REAL">
														<var name="rCostVel" id="8"/>
													</pin>
												</outputs>
											</funcBlock>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="5" nextID="12" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<function name="TO_UINT" id="5">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="#0" neg="false" type="UNDEF">
														<expression name="rCostVel * 8191.0 / 11.0" id="11"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="#O" neg="false" type="UINT">
														<var name="owVentola" id="7"/>
													</pin>
												</outputs>
											</function>
										</input>
										<outputs/>
									</assignment>
								</network>
								<network label="" id="6" nextID="11" comment="" disabled="false" disableCondition="">
									<assignment fromTmpVar="">
										<input>
											<function name="TO_REAL" id="7">
												<inputs>
													<pin name="EN" neg="false" type="BOOL"/>
													<pin name="#0" neg="false" type="UNDEF">
														<expression name="rCostVel *10" id="10"/>
													</pin>
												</inputs>
												<outputs>
													<pin name="ENO" neg="false" type="BOOL">
														<outputLine/>
													</pin>
													<pin name="#O" neg="false" type="REAL">
														<var name="rVelVentola" id="9"/>
													</pin>
												</outputs>
											</function>
										</input>
										<outputs/>
									</assignment>
								</network>
							</LD2>
						</sourceCode>
					</program>
				</programs>
				<macros/>
				<structs/>
				<typedefs/>
				<enums/>
				<subranges/>
				<interfaces/>
			</lib>
			<lib version="1.0.1" name="C:\Program Files (x86)\Arduino PLC IDE\Arduino PLC IDE\Libraries\OSCAT\Oscat - Time and date.plclib" fullXml="true" link="true">
				<descr>Author URL: http://oscat.de</descr>
				<libWorkspace>
					<folder name="Oscat - Time and date" excludeFromBuild="false" excludeFromBuildIfNotDef="">
						<Pou name="CALENDAR_CALC"/>
						<Pou name="DAY_OF_DATE"/>
						<Pou name="DAYS_DELTA"/>
						<Pou name="DAYS_IN_MONTH"/>
						<Pou name="DAY_OF_YEAR"/>
						<Pou name="DAYS_IN_YEAR"/>
						<Pou name="DAY_OF_MONTH"/>
						<Pou name="DAY_TO_TIME"/>
						<Pou name="DATE_ADD"/>
						<Pou name="DT_TO_SDT"/>
						<Pou name="EASTER"/>
						<Pou name="EVENTS"/>
						<Pou name="DCF77"/>
						<Pou name="HOLIDAY"/>
						<Pou name="DT2_TO_SDT"/>
						<Pou name="MINUTE_OF_DT"/>
						<Pou name="HOUR"/>
						<Pou name="MINUTE_TO_TIME"/>
						<Pou name="MONTH_BEGIN"/>
						<Pou name="SDT_TO_TOD"/>
						<Pou name="SECOND_TO_TIME"/>
						<Pou name="HOUR_TO_TOD"/>
						<Pou name="LEAP_DAY"/>
						<Pou name="HOUR_OF_DT"/>
						<Pou name="LTIME_TO_UTC"/>
						<Pou name="SUN_TIME"/>
						<Pou name="TIMECHECK"/>
						<Pou name="YEAR_OF_DATE"/>
						<Pou name="LEAP_OF_DATE"/>
						<Pou name="SDT_TO_DATE"/>
						<Pou name="SECOND"/>
						<Pou name="SUN_POS"/>
						<Pou name="YEAR_END"/>
						<Pou name="MONTH_END"/>
						<Pou name="MONTH_OF_DATE"/>
						<Pou name="SET_DATE"/>
						<Pou name="JD2000"/>
						<Pou name="PERIOD"/>
						<Pou name="SET_DT"/>
						<Pou name="SET_TOD"/>
						<Pou name="YEAR_BEGIN"/>
						<Pou name="PERIOD2"/>
						<Pou name="LEAP_YEAR"/>
						<Pou name="UTC_TO_LTIME"/>
						<Pou name="WORK_WEEK"/>
						<Pou name="RTC_2"/>
						<Pou name="SECOND_OF_DT"/>
						<Pou name="MINUTE"/>
						<Pou name="RTC_MS"/>
						<Pou name="SDT_TO_DT"/>
						<Pou name="SUN_MIDDAY"/>
						<Pou name="HOUR_TO_TIME"/>
						<Pou name="REFRACTION"/>
					</folder>
				</libWorkspace>
				<globalVars/>
				<retainVars/>
				<constantVars/>
				<functions>
					<function name="DAY_OF_DATE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DINT</returnValue>
						<vars>
							<inputVars>
								<var name="idate" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
	version 1.3	7. apr. 2008
	programmer 	oscat
	tested BY	oscat

DAY_OF_DATE returns the days since 1.1.1970

*)

DAY_OF_DATE := TO_DINT(DATE_TO_DWORD(idate) / 86400);


(* revision history
hm		16.9.2007		rev 1.0
	original version

hm		1. okt 2007		rev 1.1
	added step7 compatibility

hm		22. mar. 2008	rev 1.2
	changed output from int to Dint because the total date range is 49710 days

hm		7. apr. 2008	rev 1.3
	deleted unused step7 code

*)
]]>
						</sourceCode>
					</function>
					<function name="DAYS_DELTA" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DINT</returnValue>
						<vars>
							<inputVars>
								<var name="date_1" type="DATE"/>
								<var name="date_2" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.3		25. jan. 2011
programmer 		hugo
tested by		tobias

days_delta calculates the days between two dates. the days are calculated date_2 - date_1.

*)

IF DATE_1 > DATE_2 THEN
	DAYS_DELTA := - TO_DINT((DATE_TO_DWORD(date_1) - DATE_TO_DWORD(date_2)) / 86400);
ELSE
	DAYS_DELTA := TO_DINT((DATE_TO_DWORD(date_2) - DATE_TO_DWORD(date_1)) / 86400);
END_IF;

(* revision history
hm	27. dec 2006	rev 1.0
	original version

hm	16.9.2007		rev 1.1
	coorected an error in formula and changed algorithm to show positive and negative delta

hm	22. mar. 2008	rev 1.2
	changed output from int to dint because the total date range is 49710 days

hm	25. jan. 2011	rev 1.3
	improved performance
*)
]]>
						</sourceCode>
					</function>
					<function name="DAYS_IN_MONTH" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="IDATE" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	27. mar. 2009
programmer 	hugo
tested by		oscat

returs the total days of the current month. e.g. 31 for january.
the function works for dates from 1970 - 2099

*)


DAYS_IN_MONTH := DAY_OF_YEAR(IDATE);
IF LEAP_OF_DATE(IDATE) THEN
	CASE DAYS_IN_MONTH OF
		32..60	:	DAYS_IN_MONTH := 29;
		92..121 :	DAYS_IN_MONTH := 30;
		153..182:	DAYS_IN_MONTH := 30;
		245..274:	DAYS_IN_MONTH := 30;
		306..335:	DAYS_IN_MONTH := 30;
	ELSE
		DAYS_IN_MONTH := 31;
	END_CASE;
ELSE
	CASE DAYS_IN_MONTH OF
		32..59	:	DAYS_IN_MONTH := 28;
		91..120 :	DAYS_IN_MONTH := 30;
		152..181:	DAYS_IN_MONTH := 30;
		244..273:	DAYS_IN_MONTH := 30;
		305..334:	DAYS_IN_MONTH := 30;
	ELSE
		DAYS_IN_MONTH := 31;
	END_CASE;
END_IF;



(* revision history
hm	27. mar. 2009		rev 1.0
	original version

*)
]]>
						</sourceCode>
					</function>
					<function name="DAY_OF_YEAR" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="IDATE" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.4		28. jan. 2011
programmer 	hugo
tested by		oscat

calculates the day of the year

*)

DAY_OF_YEAR := TO_INT((DATE_TO_UDINT(idate) / UDINT#86400) MOD UDINT#1461);
IF DAY_OF_YEAR > 729 THEN
	IF DAY_OF_YEAR > 1095 THEN DAY_OF_YEAR := DAY_OF_YEAR - 1095; ELSE DAY_OF_YEAR := DAY_OF_YEAR - 729; END_IF;
ELSIF DAY_OF_YEAR > 364 THEN
	DAY_OF_YEAR := DAY_OF_YEAR - 364;
ELSE
	DAY_OF_YEAR := DAY_OF_YEAR + 1;
END_IF;


(*
DAY_OF_YEAR := TO_INT((DATE_TO_DWORD(idate) - DATE_TO_DWORD(YEAR_BEGIN(YEAR_OF_DATE(idate)))) / 86400) + 1;
*)


(* revivision history
hm	4. aug. 2007		rev 1.0
	original version

hm	1. oct. 2007		rev 1.1
	added compatibility to STEP7

hm	4. jan. 2008		rev 1.2
	changed code for better performance

hm	7. oct. 2008		rev 1.3
	changed name of function year to year_of_date

hm	28. jan. 2011	rev 1.4
	improved code
*)
]]>
						</sourceCode>
					</function>
					<function name="DAYS_IN_YEAR" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="IDATE" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	27. mar. 2009
programmer 	hugo
tested by		oscat

returs the total days of the year.
the function retruns 366 for leap years and 365 otherwise.
the function works for dates from 1970 - 2099


*)


IF LEAP_OF_DATE(IDATE) THEN
	DAYS_IN_YEAR := 366;
ELSE
	DAYS_IN_YEAR := 365;
END_IF;


(* revision history
hm	27. mar. 2009		rev 1.0
	original version

*)
]]>
						</sourceCode>
					</function>
					<function name="DAY_OF_MONTH" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="IDATE" type="DATE"/>
							</inputVars>
							<localVars>
								<var name="leap" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 2.1	10. mar. 2009
programmer 	hugo
tested by		tobias

returns the day OF month for any DATE

*)

(* calculate the day in the year *)
DAY_OF_MONTH := DAY_OF_YEAR(idate);
(* leap will be set to one for a leap year *)
leap := TO_INT(LEAP_OF_DATE(idate));
(* if leap year deduct one from the days of the year *)
DAY_OF_MONTH := DAY_OF_MONTH - leap;
(* search if we are in month december to march ? *)
IF DAY_OF_MONTH > setup.MTH_OFS[9] THEN
	IF DAY_OF_MONTH > setup.MTH_OFS[11] THEN
		IF DAY_OF_MONTH > setup.mth_ofs[12] THEN
			DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[12];
		ELSE
			DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[11];
		END_IF;
	ELSE
		IF DAY_OF_MONTH > setup.mth_ofs[10] THEN
			DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[10];
		ELSE
			DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[9];
		END_IF;
	END_IF;
ELSIF DAY_OF_MONTH > setup.MTH_OFS[5] THEN
	IF DAY_OF_MONTH > setup.MTH_OFS[7] THEN
		IF DAY_OF_MONTH > setup.mth_ofs[8] THEN
			DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[8];
		ELSE
			DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[7];
		END_IF;
	ELSE
		IF DAY_OF_MONTH > setup.mth_ofs[6] THEN
			DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[6];
		ELSE
			DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[5];
		END_IF;
	END_IF;
ELSIF DAY_OF_MONTH > setup.MTH_OFS[3] THEN
	IF DAY_OF_MONTH > setup.MTH_OFS[4] THEN
		DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[4];
	ELSE
		DAY_OF_MONTH := DAY_OF_MONTH - setup.MTH_OFS[3];
	END_IF;
ELSE
	(* since now we must be in february or january we need to add leap again *)
	DAY_OF_MONTH := DAY_OF_MONTH + leap;
	IF DAY_OF_MONTH > setup.MTH_OFS[2] THEN DAY_OF_MONTH := DAY_OF_MONTH - setup.mth_ofs[2]; END_IF;
	(* since nothing was true before, day_of_month must already be good *)
END_IF;


(*
Revision history

hm 22.1.2007		rev 1.1
	deleted unused variable day_in_year and day_in_year_begin

hm	1. okt 2007	rev 1.2
	changed code to use day_of_year and leap_of_date
	added compatibility to STEP7

hm	8. oct 2007	rev 1.3
	deleted unused variable yr

hm	8. jan 2008	rev 1.4
	improved performance

hm	25. oct. 2008	rev 2.0
	new code using setup constants

hm	10. mar. 2009	rev 2.1
	removed nested comments

*)


]]>
						</sourceCode>
					</function>
					<function name="DAY_TO_TIME" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>TIME</returnValue>
						<vars>
							<inputVars>
								<var name="IN" type="REAL"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	24. feb. 2009
programmer 	hugo
tested by		tobias

converts an amount of days in real to time 
*)

DAY_TO_TIME := DWORD_TO_TIME(TO_DWORD(IN * 86400000.0));


(* revision history
hm	4. aug. 2006	rev 1.0
	original release

hm	24. feb. 2009	rev 1.1
	renamed input to IN
*)
]]>
						</sourceCode>
					</function>
					<function name="DATE_ADD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE</returnValue>
						<vars>
							<inputVars>
								<var name="IDATE" type="DATE"/>
								<var name="D" type="INT"/>
								<var name="W" type="INT"/>
								<var name="M" type="INT"/>
								<var name="Y" type="INT"/>
							</inputVars>
							<localVars>
								<var name="mo" type="INT"/>
								<var name="yr" type="INT"/>
								<var name="dm" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.8		22. mar. 2011
programmer 	hugo
tested by		oscat

date_add adds days, weeks, month or years to a date.
negative inputs are allowed for subtraction.

*)


DATE_ADD := UDINT_TO_DATE(DATE_TO_UDINT(IDATE) + TO_UDINT(D + W * 7) * UDINT#86400);
yr := Y + YEAR_OF_DATE(DATE_ADD);
mo := M + MONTH_OF_DATE(DATE_ADD);
dm := DAY_OF_MONTH(DATE_ADD);
WHILE mo > 12 DO
	mo := mo - 12;
	yr := yr + 1;
END_WHILE;
WHILE mo < 1 DO
	mo := mo + 12;
	yr := yr - 1;
END_WHILE;
DATE_ADD := SET_DATE(yr, mo, dm);


(* revision history

hm 27.12.2006	rev 1.0
	nrw module

hm 12.4.2007		rev 1.1
	corrected an error while date would be incorrect when year  = 0

hm	1.11.2007		rev 1.2
	added int_to_dword stetements to avoid possible overrun with möller ecp4

hm	22. mar. 2008	rev 1.3
	fixed some bugs when month was negative

hm	7. oct. 2008	rev 1.4
	changed function year to year_of_date
	changed function month to month_of_date

hm	29. mar. 2009	rev 1.5
	improved performance

hm	27. jan. 2011	rev 1.6
	faster code

hm	2. feb. 2011		rev 1.7
	fixed an error, weeks not calculated

hm	22. mar. 2011	rev 1.8
	fixed an error in formula
*)
]]>
						</sourceCode>
					</function>
					<function name="DT_TO_SDT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>SDT</returnValue>
						<vars>
							<inputVars>
								<var name="DTI" type="DATE_AND_TIME"/>
							</inputVars>
							<localVars>
								<var name="tmp" type="DATE"/>
								<var name="tdt" type="DWORD"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	18. oct 2008
programmer 	hugo
tested by	oscat

converts date_time to Structured date time (SDT)

*)


tmp := DT_TO_DATE(dti);
tdt := DT_TO_DWORD(dti) - DATE_TO_DWORD(tmp);
DT_TO_SDT.YEAR := YEAR_OF_DATE(tmp);
DT_TO_SDT.MONTH := MONTH_OF_DATE(tmp);
DT_TO_SDT.DAY := DAY_OF_MONTH(tmp);
DT_TO_SDT.WEEKDAY := DAY_OF_WEEK(tmp);
DT_TO_SDT.SECOND := TO_INT(tdt MOD 60);
DT_TO_SDT.MINUTE := TO_INT((tdt / 60) MOD 60);
DT_TO_SDT.HOUR := TO_INT(tdt / 3600);

(* revision history

hm 18. oct. 2008	rev 1.0
	original version

*)
]]>
						</sourceCode>
					</function>
					<function name="EASTER" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE</returnValue>
						<vars>
							<inputVars>
								<var name="year" type="INT"/>
							</inputVars>
							<localVars>
								<var name="b" type="INT"/>
								<var name="c" type="INT"/>
								<var name="oday" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 1.3	7. apr. 2008
programmer 	hugo
tested by	tobias

easter calculates the day of easter sunday for a given year.
most other catholic holidays are calculated in reference to easter sunday.

*)

b := (204 - 11 * (YEAR MOD 19)) MOD 30;
IF b > 27 THEN b := b - 1; END_IF;
c := (year + SHR(year,2) + b - 13) MOD 7;
oday := 28 + b - c;
IF oday > 33 THEN
	EASTER := SET_DATE(year, 4, oday - 31);
ELSE
	EASTER := SET_DATE(year, 3, oday);
END_IF;




(* alternativer algorithmus ueber das pasah fest
execution time roughly 200us
Der sog. Passah-Vollmond wird berechnet, in dem das Jahr durch 19 ge-
teilt wird und der Rest mit der folgenden Tabelle verglichen wird:
 
    0: Apr 14       5: Apr 18      10: Mrz 25      15: Mrz 30
    1: Apr 03       6: Apr 08      11: Apr 13      16: Apr 17
    2: Mrz 23       7: Mrz 28      12: Apr 02      17: Apr 07
    3: Apr 11       8: Apr 16      13: Mrz 22      18: Mrz 27
    4: Mrz 31       9: Apr 05      14: Apr 10
 
Faellt dieses Datum auf einen Sonntag, ist Ostern der naechste Sonntag!
 
Beispiel: 1992 MOD 19 = 16, daraus folgt 17.04., der naechste Sonntag
          ist dann der 19. April (Ostersonntag)
*)


(* this algorithm is 180 us
a := year MOD 19;
b := year / 100;
c := year MOD 100;
d := b / 4;
e := b MOD 4;
f := (b + 8) / 25;
g := (b - f + 1) / 3;
h := (19 * a + b - d -g + 15) MOD 30;
i := C / 4;
k := c MOD 4;
l := (32 + 2*e + 2*i - h - k) MOD 7;
m := (a + 11 * h + 22 * l) / 451;
x := h + l - 7 * m + 114;
n := X / 31;
o := x MOD 31 + 1;

easter := set_Date(year,n,o);
*)
(*
Im Magazin Nature vom 20. April 1876 veröffentlichte ein anonymer Autor eine Tabelle mit Regeln zur Berechnung des (Gregorianischen) Ostersonntages des Jahres J. In Formeln ausgedrückt erhält man das Folgende:
a	=	J mod 19
b	=	int(J / 100)
c	=	J mod 100
d	=	int(b / 4)
e	=	b mod 4
f	=	int((b + 8) / 25)
g	=	int((b - f + 1) / 3
h	=	(19 · a + b - d - g + 15) mod 30
i	=	int(c / 4)
k	=	c mod 4
l	=	(32 + 2 · e + 2 · i - h - k) mod 7
m	=	int((a + 11 · h + 22 · l) / 451)
n	=	int((h + l - 7 · m + 114) / 31)
o	=	(h + l - 7 · m + 114) mod 31

n ist hierbei die Nummer des Monats, o + 1 die Nummer des Tages auf welchen der Ostersonntag im Jahr J fällt. Dieser Algorithmus kommt ohne Hilfszahlen aus.

*)

(* revision history
hm	27. dec 2006	rev 1.0
	original version

hm	15. dec 2007	rev 1.1
	modified code for better performance

hm	3. feb 2008		rev 1.2
	modified code for better performance

hm	7. apr. 2008	rev 1.3
	improved performance
*)
]]>
						</sourceCode>
					</function>
					<function name="DT2_TO_SDT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>SDT</returnValue>
						<vars>
							<inputVars>
								<var name="DI" type="DATE"/>
								<var name="TI" type="TIME_OF_DAY"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	18. oct 2008
programmer 	hugo
tested by	oscat

converts date and time of day to Structured date time (SDT)

*)


DT2_TO_SDT.YEAR := YEAR_OF_DATE(di);
DT2_TO_SDT.MONTH := MONTH_OF_DATE(di);
DT2_TO_SDT.DAY := DAY_OF_MONTH(di);
DT2_TO_SDT.WEEKDAY := DAY_OF_WEEK(di);
DT2_TO_SDT.MS := TO_INT(TOD_TO_DWORD(ti) MOD 1000);
DT2_TO_SDT.SECOND := TO_INT((TOD_TO_DWORD(ti) / 1000) MOD 60);
DT2_TO_SDT.MINUTE := TO_INT((TOD_TO_DWORD(ti) / 60000) MOD 60);
DT2_TO_SDT.HOUR := TO_INT(TOD_TO_DWORD(ti) / 3600000);

(* revision history

hm 18. oct. 2008	rev 1.0
	original version

*)
]]>
						</sourceCode>
					</function>
					<function name="MINUTE_OF_DT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="XDT" type="DATE_AND_TIME"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
	version 1.0	6. jun. 2008
	programmer 	oscat
	tested BY	oscat

MINUTE_OF_DT returns the current minute (minute of the hour) of a DT variable

*)

MINUTE_OF_DT := TO_INT(DT_TO_DWORD(XDT) MOD 3600) / 60;


(* revision history
hm		6.9.2008	rev 1.0
	original version


*)
]]>
						</sourceCode>
					</function>
					<function name="HOUR" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="itod" type="TIME_OF_DAY"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	2 okt 2006
programmer 	hugo
tested by	tobias

extracts the hour of a Time_of_day 
*)

HOUR := TO_INT(TOD_TO_DWORD(itod) / 3600000);


(* change history
hm 4. aug 2006	rev 1.0
	original version

hm 2.10.2006 	rev 1.1
	changed name of input to itod

*)
]]>
						</sourceCode>
					</function>
					<function name="MINUTE_TO_TIME" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>TIME</returnValue>
						<vars>
							<inputVars>
								<var name="IN" type="REAL"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.2	24. feb. 2009
programmer 	hugo
tested by		oscat

converts an amount of minutes in real to time

*) 

MINUTE_TO_TIME := DWORD_TO_TIME(TO_DWORD(IN * 60000.0));


(* revision history
hm	4. aug 2006	rev 1.0
	original version

hm	14. mar 2008	rev 1.1
	rounded the input after the last digit

hm	24. feb. 2009	rev 1.2
	changed input to IN

*)
]]>
						</sourceCode>
					</function>
					<function name="MONTH_BEGIN" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE</returnValue>
						<vars>
							<inputVars>
								<var name="idate" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	15. jun. 2008
programmer 	hugo
tested by	oscat

returns the date for the first day of the current month in the current year.

*)

MONTH_BEGIN := DWORD_TO_DATE(DATE_TO_DWORD(idate) - TO_DWORD(DAY_OF_MONTH(idate) - 1) * 86400);

(* revision history
hm	15. jun. 2008	rev 1.0
	original version	

*)
]]>
						</sourceCode>
					</function>
					<function name="SDT_TO_TOD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>TIME_OF_DAY</returnValue>
						<vars>
							<inputVars>
								<var name="DTI" type="SDT"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	16. nov. 2008
programmer 	hugo
tested by	oscat

converts Structured date time (SDT) to Date Time

*)


SDT_TO_TOD := DWORD_TO_TOD(TO_DWORD(DTI.HOUR) * 3600000 + TO_DWORD(DTI.MINUTE) * 60000 + TO_DWORD(DTI.SECOND) * 1000 + TO_DWORD(DTI.MS));



(* revision history

hm 18. oct. 2008	rev 1.0
	original version

hm	16. nov. 2008	rev 1.1
	added typecasts to avoid warnings
*)
]]>
						</sourceCode>
					</function>
					<function name="SECOND_TO_TIME" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>TIME</returnValue>
						<vars>
							<inputVars>
								<var name="IN" type="REAL"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.2	24. feb. 2009
programmer 	hugo
tested by		tobias

converts an amount of seconds in real to time
execution TIME on wago 750-841 =  17us 

*)

SECOND_TO_TIME := DWORD_TO_TIME(TO_DWORD(IN * 1000.0));

(* revision history
hm	4. aug. 2006	rev 1.0
	original version

hm	14. mar. 2008	rev 1.1
	rounded the input after the last digit

hm	24. feb. 2009	rev 1.2
	changed input to IN
*)
]]>
						</sourceCode>
					</function>
					<function name="HOUR_TO_TOD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>TIME_OF_DAY</returnValue>
						<vars>
							<inputVars>
								<var name="IN" type="REAL"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.2	24. feb 2009
programmer 	hugo
tested by		tobias

converts an amount of hours in real to time of day TOD.

*)

HOUR_TO_TOD := DWORD_TO_TOD(TO_DWORD(IN * 3600000));


(* revision history
hm	4. aug. 2006	rev 1.0
	original version

hm	14. mar. 2008	rev 1.1
	rounded the input after the last digit

hm	24. feb. 2009	rev 1.2
	changed input to IN
*)
]]>
						</sourceCode>
					</function>
					<function name="LEAP_DAY" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="IDATE" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[



(*
version 1.2	24. jan. 2011
programmer 	hugo
tested by	oscat


leap_day is true if the tested day is a leap day (29. of february).  
  
*)


LEAP_DAY := DATE_TO_UDINT(IDATE) MOD 126230400 = 68169600;


(* change history

hm 	15. jun. 2008	rev 1.0
	original version

hm	7. oct. 2008	rev 1.1
	changed function month to month_of_date

hm	24. jan. 2011	rev 1.2
	improved performance
*)
]]>
						</sourceCode>
					</function>
					<function name="HOUR_OF_DT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="XDT" type="DATE_AND_TIME"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
	version 1.0	6. jun. 2008
	programmer 	oscat
	tested BY	oscat

HOUR_OF_DT returns the current hour (hour of the day) of a DT variable

*)

HOUR_OF_DT := TO_INT((DT_TO_DWORD(XDT) MOD 86400) / 3600);


(* revision history
hm		6.9.2008	rev 1.0
	original version


*)
]]>
						</sourceCode>
					</function>
					<function name="LTIME_TO_UTC" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE_AND_TIME</returnValue>
						<vars>
							<inputVars>
								<var name="LTIME" type="DATE_AND_TIME"/>
								<var name="DST" type="BOOL"/>
								<var name="TIME_ZONE_OFFSET" type="INT"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.7	13. nov. 2009
programmer 	hugo
tested by		oscat

LTIME_TO_UTC calculates UTC (World Time) from a local time LTIME. utc is calculated 
by subtracting Time_Zone_Offset from ltime and if dst it true subtracting an additional hour from ltime.

*)

LTIME_TO_UTC := UDINT_TO_DT(DT_TO_UDINT(LTIME) - TO_UDINT(TIME_ZONE_OFFSET) * 60);
IF DST THEN LTIME_TO_UTC := LTIME_TO_UTC - T#1h; END_IF;

(* revision history
hm 5.7.2007		rev 1.0		
	original version

hm 5.11.2007		rev 1.1
	replaced literal constant with variable because of error in möller ecp4 compiler

hm	12.nov 2007	rev 1.2
	changed Type of time_zone_offset from time to int to allow for time zones with negative offset

hm	8. dec 2007	rev 1.3
	corrected a problem with time_zone_offset

hm	14. oct. 2008	rev 1.4
	changed time_zone_offset from int to real to allow for half hour offset

hm	20. oct. 2006	rev 1.5
	changed time_zone_offset from Real to INT, now in Minutes

hm	27. feb. 2009	rev 1.6
	added type conversions to avoid warnings under codesys 3.0

ks	13. nov. 2009	rev 1.7
	corrected error in formula

*)
]]>
						</sourceCode>
					</function>
					<function name="TIMECHECK" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="TD" type="TIME_OF_DAY"/>
								<var name="START" type="TIME_OF_DAY"/>
								<var name="STOP" type="TIME_OF_DAY"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	19. jul. 2009
programmer 	oscat
tested by		oscat

this function retruns true if the daytime TD is between start and stop and returns true if so.
if you want to generate an event to span over midnight, start timemust be later than the stop time.

*)

IF stop < start THEN
	TIMECHECK := start <= TD OR TD < stop;
ELSE
	TIMECHECK := start <= TD AND TD < stop;
END_IF;



(* revision history
hm 19. jul. 2009	rev 1.0
	original release

*)
]]>
						</sourceCode>
					</function>
					<function name="YEAR_OF_DATE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="IDATE" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.4	7. oct. 2008
programmer 	hugo
tested by		oscat

returs the year of a date  
the function works for dates from 1970 - 2099 

*)


YEAR_OF_DATE := TO_INT((DATE_TO_DWORD(idate) + 43200) / 31557600 + 1970);


(* revision history
hm	4. aug 2006		rev 1.0
	original version

hm	1. okt 2007		rev 1.1
	corrected error in algorithm
	adjustment for S7 compatibility

hm	23.12.2007		rev 1.2
	changed code for better performance

hm	7. apr. 2008	rev 1.3
	deleted unused step7 code

hm	7. oct. 2008	rev 1.4
	renamed function (year) to year_of_date

*)
]]>
						</sourceCode>
					</function>
					<function name="LEAP_OF_DATE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="idate" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.3		28. jan. 2011
programmer 	hugo
tested by		tobias

leap_of_date is true if current year is a leap year  

*)


LEAP_OF_DATE := SHL(((DATE_TO_DWORD(idate) + 43200) / 31557600), 30) = 16#80000000;


(* change history

2.10.2006		rev 1.1
the function now calls leap_year to accomodate further accuracy.
the function now works for any year from 1970 to 2100

8. jan 2008		rev 1.2
	improved code for better performance

28. jan. 2011	rev 1.3
	improved performance
*)
]]>
						</sourceCode>
					</function>
					<function name="SDT_TO_DATE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE</returnValue>
						<vars>
							<inputVars>
								<var name="DTI" type="SDT"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	18. oct 2008
programmer 	hugo
tested by	oscat

converts Structured date time (SDT) to Date Time

*)


SDT_TO_DATE := SET_DATE(DTI.YEAR, DTI.MONTH, DTI.DAY);



(* revision history

hm 18. oct. 2008	rev 1.0
	original version

*)
]]>
						</sourceCode>
					</function>
					<function name="SECOND" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="itod" type="TIME_OF_DAY"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	2 oct 2006
programmer 	hugo
tested by	oscat

returns the seconds and milliseconds as real of TOD   
 
*)

SECOND := TO_REAL(TOD_TO_DWORD(itod) - TOD_TO_DWORD(itod)/60000 * 60000) / 1000.0;



(* change history

hm	2. oct. 2006 rev 1.1 
	changed name of input to itod

*)
]]>
						</sourceCode>
					</function>
					<function name="YEAR_END" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE</returnValue>
						<vars>
							<inputVars>
								<var name="y" type="INT"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	24. jan. 2011
programmer 	hugo
tested by	oscat

returs the date of december 31st for the given year  
the function works for dates from 1970 - 2099 

*)

YEAR_END := DWORD_TO_DATE(SHR(TO_DWORD(y) * 1461 - 2876712, 2) * 86400);



(* revision history
hm	15. jun. 2008	rev 1.0
	original version

hm	24. jan 2011	rev 1.1
	improved performance
*)

]]>
						</sourceCode>
					</function>
					<function name="MONTH_END" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE</returnValue>
						<vars>
							<inputVars>
								<var name="IDATE" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	7. oct. 2008
programmer 	hugo
tested by	oscat

returns the date for the last day of the current month in the current year.

*)

MONTH_END := DWORD_TO_DATE(DATE_TO_DWORD(SET_DATE(YEAR_OF_DATE(idate),MONTH_OF_DATE(idate)+1,1)) - 86400);



(* revision history
hm	15. jun. 2008	rev 1.0
	original version	

hm	7. oct. 2008	rev 1.1
	changed function year to year_of_date
	changed function month to month_of_date

*)
]]>
						</sourceCode>
					</function>
					<function name="MONTH_OF_DATE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="IDATE" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.3	27. mar. 2009
programmer 	hugo
tested by		tobias

returns the current month of the year.

*)

MONTH_OF_DATE := DAY_OF_YEAR(idate);
IF MONTH_OF_DATE < 32 THEN
	MONTH_OF_DATE := 1;
ELSIF LEAP_OF_DATE(IDATE) THEN
	MONTH_OF_DATE := (MONTH_OF_DATE * 53 + 1668) / 1623;
ELSE
	MONTH_OF_DATE := (MONTH_OF_DATE * 53 + 1700) / 1620;
END_IF;


(* code for rev 1.2
MONTH_OF_DATE := DAY_OF_YEAR(IDATE);
IF LEAP_OF_DATE(IDATE) THEN
	CASE MONTH_OF_DATE OF
		1..31 	:	MONTH_OF_DATE := 1;
		32..60	:	MONTH_OF_DATE := 2;
		61..91	:	MONTH_OF_DATE := 3;
		92..121 :	MONTH_OF_DATE := 4;
		122..152:	MONTH_OF_DATE := 5;
		153..182:	MONTH_OF_DATE := 6;
		183..213:	MONTH_OF_DATE := 7;
		214..244:	MONTH_OF_DATE := 8;
		245..274:	MONTH_OF_DATE := 9;
		275..305:	MONTH_OF_DATE := 10;
		306..335:	MONTH_OF_DATE := 11;
		336..366:	MONTH_OF_DATE := 12;
	END_CASE;
ELSE
	CASE MONTH_OF_DATE OF
		1..31 	:	MONTH_OF_DATE := 1;
		32..59	:	MONTH_OF_DATE := 2;
		60..90	:	MONTH_OF_DATE := 3;
		91..120 :	MONTH_OF_DATE := 4;
		121..151:	MONTH_OF_DATE := 5;
		152..181:	MONTH_OF_DATE := 6;
		182..212:	MONTH_OF_DATE := 7;
		213..243:	MONTH_OF_DATE := 8;
		244..273:	MONTH_OF_DATE := 9;
		274..304:	MONTH_OF_DATE := 10;
		305..334:	MONTH_OF_DATE := 11;
		335..365:	MONTH_OF_DATE := 12;
	END_CASE;
END_IF;
*)


(* revision history
hm	1. aug 2006	rev 1.0
	original version	

hm	1. okt 2007	rev 1.1
	replaced old code (string conversion) with mathematics
	the execution time is now multiple times faster.

hm	7. oct. 2008	rev 1.2
	changed name of function from month to MONTH_OF_DATE

hm	27. mar. 2009	rev 1.3
	new improved code

*)
]]>
						</sourceCode>
					</function>
					<function name="SET_DATE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE</returnValue>
						<vars>
							<inputVars>
								<var name="YEAR" type="INT"/>
								<var name="MONTH" type="INT"/>
								<var name="DAY" type="INT"/>
							</inputVars>
							<localVars>
								<var name="count" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 2.3	29. dec. 2011
programmer 	hugo
tested by	tobias

creates a date output from year, month and day of month   

*)

IF month > 2 THEN
	count := (month - 1) * 30;
	IF month > 7 THEN count := count + SHR(month - 3,1); ELSE count := count + SHR(month - 4,1); END_IF;
	(* chech for leap year and add one day if true *)
	IF SHL(year,14) = 0 THEN count := count + 1; END_IF;
ELSE
	count := (month - 1) * 31;
END_IF;

SET_DATE := DWORD_TO_DATE((TO_DWORD(count + day - 1) + SHR(TO_DWORD(year) * 1461 - 2878169, 2)) * 86400);


(* revision history
hm	4. aug. 2006	rev 1.0
	original version

hm	19 sep. 2007	rev 1.1
	use function leap_year to calculate leap year, more exceptions are handled

hm	1. okt	2007	rev 1.2
	added compatibility to step7

hm	16.dec 2007		rev 1.3
	changed code to improove performance

hm	3. jan. 2008	rev 1.4
	further improvements in performance

hm	16. mar. 2008	rev 1.5
	added type conversions to avoid warnings under codesys 3.0

hm	7. apr. 2008	rev 1.6
	deleted unused step7 code

hm	14. oct. 2008	rev 1.7
	optimized code for better performance

hm	25. oct. 2008	rev 2.0
	new code using setup constants

hm	16. nov. 2008	rev 2.1
	added typecasts to avoid warnings

hm	22. jan. 2011	rev 2.2
	improved performance

hm	29. dec. 2011	rev 2.3
	improved performance
*)
]]>
						</sourceCode>
					</function>
					<function name="JD2000" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="DTI" type="DATE_AND_TIME"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	15. jul. 2008
programmer 	hugo
tested by	oscat

JULIAN calculates the astronomic julian date from 1.1.2000-12:00.

*)

JD2000 := TO_REAL(DT_TO_DWORD(DTI) - 946728000) / 86400.0;

(* revision histroy
hm	15. jul. 2008	rev 1.0
	original release


*)	

]]>
						</sourceCode>
					</function>
					<function name="PERIOD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="d1" type="DATE"/>
								<var name="dx" type="DATE"/>
								<var name="d2" type="DATE"/>
							</inputVars>
							<localVars>
								<var name="day1" type="INT"/>
								<var name="day2" type="INT"/>
								<var name="dayx" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 1.3	22. mar. 2008
programmer 	hugo
tested by		tobias

PERIOD checks if a given date is between two dates (d1 and d2) d1 is the starting date and d2 the last date for the period.
the years of the dates are ignored, so the function period cheks for a time period within a year independet of the year.

*)

day1 := DAY_OF_YEAR(d1);
day2 := DAY_OF_YEAR(d2);
dayx := DAY_OF_YEAR(dx);
IF NOT LEAP_OF_DATE(dx) AND dayx > 58 THEN dayx := dayx + 1; END_IF;
IF NOT LEAP_OF_DATE(d1) AND day1 > 58 THEN day1 := day1 + 1; END_IF;
IF NOT LEAP_OF_DATE(d2) AND day2 > 58 THEN day2 := day2 + 1; END_IF;

IF day2 < day1 THEN
	(* the period spans over the new year *)
	PERIOD := dayx <= day2 OR dayx >= day1;
ELSE
	PERIOD := dayx >= day1 AND dayx <= day2;
END_IF;

(* code before rev 1.2
yx := year(dx);
p1 := date_add(d1,0,0,0,yx - year(d1));
p2 := date_add(d2,0,0,0,yx - year(d2));

IF p2 >= p1 THEN
	period := dx <= p2  AND dx >= p1;
ELSE
	period := dx <= p2 OR dx >= p1;
END_IF;
*)


(* revision history

hm		19. sep 2007	rev 1.0
	original version

hm		20. sep 2007	rev 1.1
	corrected a problem with leap year

hm		4. jan 2008		rev 1.2
	changed code for better performance

hm		22. mar. 2008	rev 1.3
	function would deliver wrong results when d1, d2 or dx are a leap_year

*)
]]>
						</sourceCode>
					</function>
					<function name="SET_DT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE_AND_TIME</returnValue>
						<vars>
							<inputVars>
								<var name="year" type="INT"/>
								<var name="month" type="INT"/>
								<var name="day" type="INT"/>
								<var name="hour" type="INT"/>
								<var name="minute" type="INT"/>
								<var name="second" type="INT"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.5	16 mar 2008
programmer 	hugo
tested by	tobias


creates a date output from year, month and day of month
year must be in the form of 4 digits ie 2006 or 1977.
*)

SET_DT := DWORD_TO_DT(DATE_TO_DWORD(SET_DATE(YEAR, MONTH, day)) + TO_DWORD(SECOND) + TO_DWORD(MINUTE) * 60 + TO_DWORD(HOUR) * 3600);


(* revision history
hm	4. aug. 2006		rev 1.0
	original version

hm		19 sep. 2007	rev 1.1
	use function leap_year to calculate leap year, more exceptions are handled

hm		1. okt 2007		rev 1.2
	added step7 compatibility
	call function set_date

hm		8. oct 2007		rev 1.3
	deleted unused variables count and leap

hm		1. 11 2007		rev 1.4
	converted hour type integer to dword in calculation to avoid overrun on möller ecp4

hm		16. mar 2008	rev 1.5
	added type conversions to avoid warnings under codesys 3.0
*)


]]>
						</sourceCode>
					</function>
					<function name="SET_TOD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>TIME_OF_DAY</returnValue>
						<vars>
							<inputVars>
								<var name="hour" type="INT"/>
								<var name="minute" type="INT"/>
								<var name="second" type="REAL"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.5	16. mar 2008
programmer 	hugo
tested by	tobias

creates tod from hour minute and second 

*)

SET_TOD := DWORD_TO_TOD(TO_DWORD(SECOND * 1000.0) + TO_DWORD(MINUTE) * 60000 + TO_DWORD(HOUR) * 3600000);

(* revision history

hm		4.aug.2006		rev 1.0
	original version

hm		11. sep 2007	rev 1.1
	changed coding to avoid a compiler warning under twincat.

hm		1. nov 2007	rev 1.2
	changed coding to avoid possible overrun situation on möller ecp4

hm		2. Nov	2007	rev 1.3
	changed dword to DINT in calcualtion to avoid warnings with some compilers

hm		14. mar 2008	rev 1.4
	changed code to avoid rounding problem at last digit of millisecond

hm		16. mar. 2008	rev 1.5
	added type conversions to avoid warning under codesys 3.0
*)
]]>
						</sourceCode>
					</function>
					<function name="YEAR_BEGIN" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE</returnValue>
						<vars>
							<inputVars>
								<var name="y" type="INT"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.2	7. Apr. 2008
programmer 	hugo
tested by	tobias

returs the date of january 1st for the given year  
the function works for dates from 1970 - 2099 

*)

YEAR_BEGIN := DWORD_TO_DATE(SHR(TO_DWORD(y) * 1461 - 2878169,2) * 86400);



(* revision history
hm	19. dec 2007	rev 1.0
	original version

hm	4. jan 2008		rev 1.1
	formula for step7 was incorrect during leap years

hm	7. apr. 2008	rev 1.2
	deleted unused step7 code
*)

]]>
						</sourceCode>
					</function>
					<function name="PERIOD2" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="DP" type="DATE" dim0="4" dim1="2"/>
								<var name="DX" type="DATE"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	27. apr. 2008
programmer 	hugo
tested by	tobias

PERIOD2 checks if DX is within one of 4 periods and sets the output true if so.

*)

PERIOD2 := 	(DX >= DP[0,0] AND DX <= DP[0,1]) OR
			(DX >= DP[1,0] AND DX <= DP[1,1]) OR
			(DX >= DP[2,0] AND DX <= DP[2,1]) OR
			(DX >= DP[3,0] AND DX <= DP[3,1]);


(* revision history

hm		27. apr 2008	rev 1.0
	original version


*) 
]]>
						</sourceCode>
					</function>
					<function name="LEAP_YEAR" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>BOOL</returnValue>
						<vars>
							<inputVars>
								<var name="yr" type="INT"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	2. oct. 2006
programmer 	hugo
tested by	tobias


leap_year is true if the tested year is a leap year  
  
*)

LEAP_YEAR := SHL(yr,14) = 0;

(* this code was used prior to rev 1.1

IF yr MOD 400 = 0 THEN leap_year := TRUE;
ELSIF yr MOD 100 = 0 THEN leap_year := FALSE;
ELSIF yr MOD 4 =0 THEN leap_year := TRUE;
ELSE leap_year := FALSE;
END_IF;

*)

(* change history

hm 	2.10.2006		rev 1.1
	the function now works for any year from 1970 up to 2100

hm	1. oct 2007		rev 1.2
	chaged code for higher performance
*)
]]>
						</sourceCode>
					</function>
					<function name="UTC_TO_LTIME" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE_AND_TIME</returnValue>
						<vars>
							<inputVars>
								<var name="UTC" type="DATE_AND_TIME"/>
								<var name="DST_ENABLE" type="BOOL"/>
								<var name="TIME_ZONE_OFFSET" type="INT"/>
							</inputVars>
							<localVars>
								<var name="tmp" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[

(*

version 1.9	27. feb. 2009
programmer 	oscat
tested by		oscat

ltime is a real time clock that uses the system rtc as utc time and calculates and given time zone.
the utc time is supplied on the input UTC.
according to the input variable time_zone_offset when the input dst_enable is true,
the dst on and off times are calculated by a formula for any given year and the time is advanced and reset by one hour
at 02:00 and 03:00 for the last sunday of march and last sunday of october.
the code is high performance and the rtc counts every second.
if more then one time zone is needed by the systen the clock can be started many times by placing more then one function block.

 
*)


tmp := TIME_ZONE_OFFSET * 60 + TO_INT(DST_ENABLE AND DST(UTC)) * 3600;
IF tmp < 0 THEN
	tmp := ABS(tmp);
	UTC_TO_LTIME := DWORD_TO_DT(DT_TO_DWORD(UTC) -  TO_DWORD(tmp));
ELSE
	UTC_TO_LTIME := DWORD_TO_DT(DT_TO_DWORD(UTC) +  TO_DWORD(tmp));
END_IF;


(* revision history

hm 2.10.2006	rev 1.1
	corrected an error where dst would be delayed by 0.1second

hm 17.1.2007	rev 1.2
	added utc input instead of internal sysrtcgettime because this would only work on wago.
	dst_enable would not be checked before dst would be enabled.

hm 18.3.2007	rev 1.3
	changed code, dst would not work during first cycle.

hm 24.10.2007	rev 1.4
	changed code because the execution every 100ms can cause major problems if the supplied time was not correct at start.
	use of new dst function

hm 12. nov 2007	rev 1.5
		changed Type of time_zone_offset from time to int to allow for time zones with negative offset

hm	8 dec 2007		rev 1.6
	corrected a problem with time_zone_offset

hm	14. oct. 2008	rev 1.7
	renamed module from LTIME to UTC_TO_LTIME
	changed function weekday to day_of_week
	optimized code for better performance

hm	20. oct. 2008	rev 1.8
	changes type of input TIME_ZONE_OFFSET from real to int, now is in +/-minutes
	deleted outputs DST_ON and WDAY
	converted to function

hm	27. feb. 2009	rev 1.9
	added type conversions to avoid warnings under codesys 3.0

*)
]]>
						</sourceCode>
					</function>
					<function name="WORK_WEEK" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="idate" type="DATE"/>
							</inputVars>
							<localVars>
								<var name="d1" type="DATE"/>
								<var name="w1" type="INT"/>
								<var name="ds" type="DWORD"/>
								<var name="yr" type="INT"/>
								<var name="w31" type="INT"/>
								<var name="w01" type="INT"/>
								<var name="wm" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 1.5	25. oct. 2008
programmer 	hugo
tested by	oscat

calculates the work week for a given date according to iso8601

*)

(* berechne den 1.1 des jahres von idate. *)
yr := YEAR_OF_DATE(idate);
d1 := YEAR_BEGIN(yr);
(* wochentag von d1 *)
w1 := DAY_OF_WEEK(d1);
(* offset des montags der eletzten KW des vorjahres *)
(* wenn der erste tag des jahres größer als donnerstag ist dann beginnt die letzte kw am montag davor *)
(* wenn der erste tag des jahres ein donnerstag oder kleiner ist beginnt die erste kw 2 montage davor *)
IF w1 < 5 THEN
	ds := DATE_TO_DWORD(d1) - TO_DWORD(w1+6) * 86400;
ELSE
	ds := DATE_TO_DWORD(d1) - TO_DWORD(w1-1) * 86400;
END_IF;

(* kalenderwoche des eingangsdatums *)
WORK_WEEK := TO_INT((DATE_TO_DWORD(idate) - ds) / 604800);

(* korrektur wenn work_week = 0 *)
IF work_week = 0 THEN
	(* work_week needs to be 53 when 1.jan of the year before is thursday or dec 31. is thursday. *)
	(* first and last weekday of a year is equal and one more day for a leap_year. *)
	IF w1 > 1 THEN w31 := w1 - 1; ELSE W31 := 7; END_IF;
	IF LEAP_YEAR(yr - 1) AND w31 > 1 THEN w01 := W31 - 1; ELSE w1 := 7; END_IF;
	(* if first or last day of a year is a thursday, the year has 53 weeks *)
	WORK_WEEK := 52 + TO_INT(w31 = 4 OR w01 = 4);
ELSE
	(* end of year calculation *)
	(* calculated the first and last weekday *)
	IF leap_year(yr) THEN
		IF w1 < 7 THEN w31 := w1 + 1; ELSE w31 := 1; END_IF;
	ELSE
		w31 := w1;
	END_IF;
	(* if first or last day is thursday then the year has 53 weeks otherwise only 52 *)
	wm := 52 + TO_INT(w31 = 4 OR w1 = 4);
	IF WORK_WEEK > wm THEN WORK_WEEK := 1; END_IF;
END_IF;



(* revision history

hm 	17.1.2007		rev 1.1
	deleted unused variable yday

hm	19. dec 2007	rev 1.2
	changed code for better performance
	changed code to comply with ISO8601

hm	16. mar 2008	rev 1.3
	added type conversions to avoid warnings under codesys 3.0

hm	7. oct. 2008	rev 1.4
	changed function year to year_of_date
	changed function weekday to day_of_week

hm	25. oct. 2008	rev 1.5
	optimized code for performance
*)
]]>
						</sourceCode>
					</function>
					<function name="SECOND_OF_DT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="XDT" type="DATE_AND_TIME"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
	version 1.0	6. jun. 2008
	programmer 	oscat
	tested BY	oscat

SECOND_OF_DT returns the current second (second of minute) of a DT variable

*)

SECOND_OF_DT := TO_INT(DT_TO_DWORD(XDT) MOD 60);

(* revision history
hm		6.9.2008	rev 1.0
	original version

*)
]]>
						</sourceCode>
					</function>
					<function name="MINUTE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="itod" type="TIME_OF_DAY"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	2 oct 2006
programmer 	hugo
tested by	tobias

extracts the minutes out of TOD truncating the seconds 

*)  

MINUTE := TO_INT(TOD_TO_DWORD(itod) / 60000 - TOD_TO_DWORD(itod) / 3600000 * 60);


(* change history

2.10.2006 changes name of input to itod

*)
]]>
						</sourceCode>
					</function>
					<function name="SDT_TO_DT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>DATE_AND_TIME</returnValue>
						<vars>
							<inputVars>
								<var name="DTI" type="SDT"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.0	18. oct 2008
programmer 	hugo
tested by	oscat

converts Structured date time (SDT) to Date Time

*)


SDT_TO_DT := SET_DT(DTI.YEAR, DTI.MONTH, DTI.DAY, DTI.HOUR, DTI.MINUTE, DTI.SECOND);



(* revision history

hm 18. oct. 2008	rev 1.0
	original version

*)
]]>
						</sourceCode>
					</function>
					<function name="SUN_MIDDAY" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>TIME_OF_DAY</returnValue>
						<vars>
							<inputVars>
								<var name="LON" type="REAL"/>
								<var name="UTC" type="DATE"/>
							</inputVars>
							<localVars>
								<var name="T" type="REAL"/>
								<var name="OFFSET" type="REAL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 1.0	26. jan. 2011
programmer 	hugo
tested by	oscat

this FUNCTION calculates the time when the sun stand exactly south of a given location.

*)

T := TO_REAL(DAY_OF_YEAR(utc));
OFFSET := -0.1752 * SIN(0.033430 * T + 0.5474) - 0.1340 * SIN(0.018234 * T - 0.1939);
SUN_MIDDAY := HOUR_TO_TOD(12.0 - OFFSET - lon * 0.0666666666666);


(* revision history

hm	26. jan. 2011	rev 1.0
	initial release

*)
]]>
						</sourceCode>
					</function>
					<function name="HOUR_TO_TIME" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>TIME</returnValue>
						<vars>
							<inputVars>
								<var name="IN" type="REAL"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.2	24. feb. 2009
programmer 	hugo
tested by		tobias

converts an amount of hours in real to time

*)

HOUR_TO_TIME := DWORD_TO_TIME(TO_DWORD(IN * 3600000));


(* revision history
hm		4. aug 2006	rev 1.0
	original version

hm	14. mar. 2008	rev 1.1
	rounded the input after the last digit

hm	24. feb. 2009	rev 1.2
	changed input to IN
*)
]]>
						</sourceCode>
					</function>
					<function name="REFRACTION" version="1.0.0" creationDate="0" lastModifiedDate="1631603909" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="ELEV" type="REAL"/>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	7. mar. 2009
programmer 	hugo
tested by		oscat

REFRACTION calculates the atmospheric refraction in degrees.
the input angle goes from 0 at the hirizon to 90 at midday.

*)

elev := LIMIT(elev, -1.9, 80.0);
REFRACTION := 0.0174532925199433 / TAN(0.0174532925199433 * (ELEV + 10.3 / (ELEV + 5.11)));


(* revision histroy
hm	14. jul. 2008	rev 1.0
	original release

hm	7. mar. 2009	rev 1.1
	using new formula

*)	

]]>
						</sourceCode>
					</function>
				</functions>
				<functionBlocks>
					<functionBlock name="CALENDAR_CALC" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<vars>
							<inoutVars>
								<var name="XCAL" type="CALENDAR"/>
								<var name="HOLIDAYS" type="HOLIDAY_DATA" dim0="30"/>
							</inoutVars>
							<inputVars>
								<var name="SPE" type="BOOL"/>
								<var name="H" type="REAL">
									<initValue>-0.83333333333</initValue>
								</var>
							</inputVars>
							<localVars>
								<var name="last" type="DATE_AND_TIME"/>
								<var name="last_day" type="DINT"/>
								<var name="holy" type="HOLIDAY"/>
								<var name="sun" type="SUN_TIME"/>
								<var name="last_hour" type="INT"/>
								<var name="utod" type="TIME_OF_DAY"/>
								<var name="pos" type="SUN_POS"/>
								<var name="plast" type="DATE_AND_TIME"/>
								<var name="dtemp" type="DINT"/>
								<var name="tmp" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.6	6. apr. 2011
programmer 	hugo
tested by		oscat

calendar_calc liest die weltzeit .UTC aus einer CALENDAR Struktur und berechnet die restlichen Werte der Struktur.
calendar_calc stellt sicher das die Werte fortlaufend aktualisiert werden und dabei funktionen nur dann aufgerufen werden wenn dies nötig ist.
calendar_calc will calculate sun position data when SPE = TRUE;

*)



IF xcal.UTC <> last THEN
	(* run once per second *)
	(* update utc last calculated  *)
	last := XCAL.UTC;
	utod := DT_TO_TOD(xcal.UTC);

	(* calculate ltc from utc *)
	XCAL.LDT := UTC_TO_LTIME(XCAL.UTC, XCAL.DST_EN, XCAL.OFFSET);
	XCAL.LDATE := DT_TO_DATE(XCAL.LDT);
	XCAL.LTOD := DT_TO_TOD(XCAL.LDT);
	dtemp := DAY_OF_DATE(XCAL.LDATE);
	xcal.night := XCAL.LTOD < XCAL.SUN_RISE OR XCAL.LTOD > XCAL.SUN_SET;

	(* run once per hour *)
	tmp := HOUR(xcal.LTOD);
	IF  tmp <> last_hour THEN
		XCAL.DST_ON := DST(XCAL.UTC) AND xcal.DST_EN;
		last_hour := tmp;
	END_IF;

	(* run once per day *)
	IF dtemp <> last_day THEN
		last_day := dtemp;
		(* a new day has started, recalculate daily events *)
		XCAL.YEAR := YEAR_OF_DATE(XCAL.LDATE);
		XCAL.MONTH := MONTH_OF_DATE(XCAL.LDATE);
		XCAL.DAY := DAY_OF_MONTH(XCAL.LDATE);
		XCAL.WEEKDAY := DAY_OF_WEEK(XCAL.LDATE);
		HOLY(date_in := XCAL.LDATE, LANGU := xcal.LANGUAGE, HOLIDAYS := HOLIDAYS);
		XCAL.HOLIDAY := HOLY.Y;
		XCAL.HOLY_NAME := HOLY.NAME;
		sun(latitude := XCAL.LATITUDE, longitude := xcal.LONGITUDE, utc := DT_TO_DATE(xcal.UTC), H := H);
		XCAL.SUN_RISE := DINT_TO_TOD(TOD_TO_DINT(sun.sun_rise) + XCAL.OFFSET * 60000 + SEL(XCAL.DST_ON,DINT#0,3600000));
		XCAL.SUN_SET := DINT_TO_TOD(TOD_TO_DINT(sun.sun_set) + XCAL.OFFSET * 60000 + SEL(XCAL.DST_ON,DINT#0,3600000));
		XCAL.SUN_MIDDAY := DINT_TO_TOD(TOD_TO_DINT(sun.MIDDAY) + XCAL.OFFSET * 60000 + SEL(XCAL.DST_ON,DINT#0,3600000));
		XCAL.SUN_HEIGTH := sun.sun_declination;
		XCAL.WORK_WEEK := WORK_WEEK(XCAL.LDATE);
	END_IF;

	(* calculate the suns position every 10 seconds when SPE = TRUE *)
	IF SPE AND xcal.UTC -  plast >= t#25s THEN
		plast := last;
		pos(latitude := xcal.LATITUDE, longitude := xcal.LONGITUDE, utc := xcal.UTC);
		xcal.SUN_HOR := pos.B;
		xcal.SUN_VER := pos.HR;
	END_IF;
END_IF;



(* revision history

hm 23. oct. 2008	rev 1.0
	original version

hm	8. feb. 2009	rev 1.1
	night was calculated wrong
	added sun position data

hm	10. mar. 2009	rev 1.2
	added work_week, sun_midday, sun_heigth
	sun_position will only be calculated evey 25 seconds
	dst will only become true when dst_en = true

hm	23. jan 2010	rev 1.3
	sun_rise, sun_set and sun_midday are now calculated in local time

hm	18. jan. 2011	rev 1.4
	added input holidays to specify local holidays
	changed call for function sun_time

hm	2. feb. 2011	rev 1.5
	added input H to specify twilight

hm	6. apr. 2011	rev 1.6
	night was calculated wrong
*)
]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="EVENTS" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<vars>
							<inoutVars>
								<var name="ELIST" type="HOLIDAY_DATA" dim0="50"/>
							</inoutVars>
							<inputVars>
								<var name="DATE_IN" type="DATE"/>
								<var name="ENA" type="BOOL"/>
							</inputVars>
							<outputVars>
								<var name="Y" type="BOOL"/>
								<var name="NAME" type="STRING" length="30"/>
							</outputVars>
							<localVars>
								<var name="i" type="INT"/>
								<var name="last_active" type="DATE"/>
								<var name="size" type="INT">
									<initValue>49</initValue>
								</var>
								<var name="day_in" type="DINT"/>
								<var name="cyr" type="INT"/>
								<var name="lday" type="DINT"/>
								<var name="check" type="HOLIDAY_DATA"/>
								<var name="y_int" type="BOOL"/>
								<var name="name_int" type="STRING" length="30"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 1.0	18. jan. 2010
programmer 	hugo
tested by		tobias

event checks an array with a list of events and displays the event if today is one.

*)

(* for performance reasons only activate once a day *)
IF last_active <> date_in THEN
	last_active := DATE_IN;
	Y_int := FALSE;
	name_int := '';
	day_in := DAY_OF_DATE(DATE_IN);
	cyr := YEAR_OF_DATE(DATE_IN);

	(* search list for events *)
	FOR i := 0 TO size DO
		check := elist[i];
		lday := DAY_OF_DATE(SET_DATE(cyr,check.month, check.day));
		IF day_in >= lday AND day_in <= lday + check.use - 1 THEN
			y_int := TRUE;
			name_int := check.name;
			EXIT;
		END_IF;
	END_FOR;
END_IF;

IF ENA THEN
	Y := y_int;
	NAME := name_int;
ELSE
	Y := FALSE;
	NAME := '';
END_IF;

(* revision history
hm  18. jan. 2011	rev 1.0
	new module

*)


]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="DCF77" version="1.0.0" creationDate="0" lastModifiedDate="1637665579" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<vars>
							<inputVars>
								<var name="REC" type="BOOL"/>
								<var name="SET" type="BOOL"/>
								<var name="SDT" type="DATE_AND_TIME"/>
								<var name="DSI" type="BOOL"/>
								<var name="SYNC_TIMEOUT" type="TIME">
									<initValue>t#2m</initValue>
								</var>
								<var name="TIME_OFFSET" type="INT">
									<initValue>1</initValue>
								</var>
								<var name="DST_EN" type="BOOL">
									<initValue>TRUE</initValue>
								</var>
							</inputVars>
							<outputVars>
								<var name="TP" type="BOOL"/>
								<var name="DS" type="BOOL"/>
								<var name="WDAY" type="INT"/>
								<var name="ERROR" type="BOOL">
									<initValue>TRUE</initValue>
								</var>
								<var name="RTC" type="DATE_AND_TIME"/>
								<var name="RTC1" type="DATE_AND_TIME"/>
								<var name="MSEC" type="INT"/>
								<var name="SYNC" type="BOOL"/>
							</outputVars>
							<externalVars>
								<var name="sysTimer" type="UDINT"/>
							</externalVars>
							<localVars>
								<var name="mez" type="DATE_AND_TIME"/>
								<var name="utc" type="DATE_AND_TIME"/>
								<var name="state" type="INT"/>
								<var name="edge" type="BOOL"/>
								<var name="tx" type="TIME"/>
								<var name="ty" type="TIME"/>
								<var name="last" type="TIME"/>
								<var name="bits" type="BOOL" dim0="59"/>
								<var name="cnt" type="INT"/>
								<var name="i" type="INT"/>
								<var name="old_time" type="DATE_AND_TIME"/>
								<var name="minute" type="INT"/>
								<var name="hour" type="INT"/>
								<var name="day" type="INT"/>
								<var name="month" type="INT"/>
								<var name="year" type="INT"/>
								<var name="last_sync" type="TIME"/>
								<var name="t1" type="TIME"/>
								<var name="tz" type="TIME"/>
								<var name="init" type="BOOL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.10	7. oct. 2008
programmer 	hugo
tested by	oscat

this is a decoder for a DCF77 signal.
the decoder decodes the DCF77 signal and checks for a valid Date_Time.
since the dcf77 signal is only secured with a simple parity the decoder waits for two consecutive valid transmissions before it sets the output signals.
given a valid reception by the receiver the decoder can take up to 3 minutes to start its clocks the first time.
after a valid signal is detected the error output goes low and dignals a valid dcf signal from the receiver.
a tp is only valid for one program cycle to allow for external rtc setting.
after a valid signal is detected two independent internal clocks are started (RTC and RTC1), the seconds  of these clocks are generated by software since the dcf signal is only valid for minutes.
rtc is always utc ( world time) and rtc1 can be set to any time zone by setting the time_zone_offset and enabling dst for automatic summertime.
a sync output signals the the rtc and rtc1 are in sync with the dcf77 signal, if the dcf77 signal is lost for more then the sync time the sync output goes low
but the rtc and rtc1 outputs keep running based on software timing until a valid dcf77 signal is received again and triggers the clock.
in addition a millisecond output gives further resolutionof the clocks.
a dst output shows if daylight saving time is enables and the weekday output shows which day of week currently is ( 1= monday ... 7= sunday).

*)


(* if tp was set it should only be active for 1 cycle *)
TP := FALSE;

(* read system time *)
t1 := DWORD_TO_TIME(sysTimer);
tx := t1 - last;

IF rec XOR edge THEN
	edge := rec;
	IF NOT rec AND tx > t#1700ms AND tx < t#2000ms THEN
		(* start condition reached *)
		state := 0;
		tp := NOT error;
	ELSIF NOT rec AND tx > t#700ms AND tx < t#1000ms THEN
		(* second switch detected *)
		IF state < 58 THEN state := state +1; ELSE state := 0; END_IF;
	ELSIF rec AND tx  < t#120ms THEN
		(* bit 0 detected  *)
		bits[state] := 0;
	ELSIF rec AND tx > t#120ms AND tx < t#250ms THEN
		(* bit 1 detected *)
		bits[state] := 1;
	ELSE
		(* error condition received signal is not valid *)
		error := TRUE;
		state := 0;
	END_IF;
	last := last + tx;
	IF rec AND state = 58 THEN
		error := FALSE;

		(* decode the bits and check for possible errors *)
		IF bits[0] OR NOT (bits[17] XOR bits[18]) OR NOT bits[20] THEN error := TRUE; END_IF;
		(* decode minute *)
		MINUTE := 0;
		MINUTE.0 := bits[21];
		MINUTE.1 := bits[22];
		MINUTE.2 := bits[23];
		MINUTE.3 := bits[24];
		IF bits[25] THEN MINUTE := MINUTE + 10; END_IF;
		IF bits[26] THEN MINUTE := MINUTE + 20; END_IF;
		IF bits[27] THEN MINUTE := MINUTE + 40; END_IF;
		IF MINUTE > 59 OR (bits[21] XOR bits[22] XOR bits[23] XOR bits[24] XOR bits[25] XOR bits[26] XOR bits[27] XOR bits[28]) THEN error := TRUE; END_IF;

		(* decode hour *)
		HOUR := 0;
		HOUR.0 := bits[29];
		HOUR.1 := bits[30];
		HOUR.2 := bits[31];
		HOUR.3 := bits[32];
		IF bits[33] THEN HOUR := HOUR + 10; END_IF;
		IF bits[34] THEN HOUR := HOUR +20; END_IF;
		IF HOUR > 23 OR (bits[29] XOR bits[30] XOR bits[31] XOR bits[32] XOR bits[33] XOR bits[34] XOR bits[35]) THEN error := TRUE; END_IF;

		(* decode day of month *)
		day := 0;
		day.0 := bits[36];
		day.1 := bits[37];
		day.2 := bits[38];
		day.3 := bits[39];
		IF bits[40] THEN day := day + 10; END_IF;
		IF bits[41] THEN day := day + 20; END_IF;
		IF day > 31 THEN error := TRUE; END_IF;

		(* decode day of week *)
		wday := 0;
		wday.0 := bits[42];
		wday.1 := bits[43];
		wday.2 := bits[44];
		IF wday > 7 OR wday < 1 THEN error := TRUE; END_IF;

		(* decode month *)
		MONTH := 0;
		MONTH.0 := bits[45];
		MONTH.1 := bits[46];
		MONTH.2 := bits[47];
		MONTH.3 := bits[48];
		IF bits[49] THEN MONTH := MONTH +10; END_IF;
		IF MONTH > 12 THEN error := TRUE; END_IF;

		(* decode year *)
		YEAR := 0;
		YEAR.0 := bits[50];
		YEAR.1 := bits[51];
		YEAR.2 := bits[52];
		YEAR.3 := bits[53];
		IF bits[54] THEN YEAR := YEAR + 10; END_IF;
		IF bits[55] THEN YEAR := YEAR + 20; END_IF;
		IF bits[56] THEN YEAR := YEAR + 40; END_IF;
		IF bits[57] THEN YEAR := YEAR + 80; END_IF;

		(* check parity for bits 36 to 58 *)
		cnt := 0;
		FOR i := 36 TO 58 DO IF bits[i] THEN cnt := cnt + 1; END_IF; END_FOR;
		IF NOT EVEN(cnt) THEN error := TRUE; END_IF;

		(* time must be valid for two cycles to clear error flag *)
		IF NOT error THEN
			(* set outputs *)
			old_time := mez;
			IF YEAR >= 70 THEN YEAR := YEAR + 1900; ELSE YEAR := YEAR + 2000; END_IF;
			mez := SET_DT(YEAR,MONTH,day,HOUR,MINUTE,0);
			DS := bits[17];
			IF DS THEN
				UTC := DWORD_TO_DT(DT_TO_DWORD(mez) - 7200);
			ELSE
				UTC := DWORD_TO_DT(DT_TO_DWORD(mez) - 3600);
			END_IF;

			(* set trigger signal only if the receiver has received 2 successive minutes *)
			IF mez <> old_time + t#1m THEN error := TRUE ; END_IF;
		END_IF;
	END_IF;
END_IF;

(* this portion implements a free running clock which is triggered by the dcf77 signal *)
tz := DWORD_TO_TIME(TO_DWORD(ABS(time_offset))* 3600000);

(* input sdt is copied to utc at first power up *)
IF NOT init OR SET THEN
	init := TRUE;
	utc := sdt;
	tp := TRUE;
	DS := DSI;
END_IF;

IF tp THEN
	rtc := utc;
	IF DS AND dst_en THEN
		IF time_offset < 0 THEN	rtc1 := rtc - tz + t#1h; ELSE rtc1 := rtc + tz + t#1h; END_IF;
	ELSE
		IF time_offset < 0 THEN rtc1 := rtc - tz; ELSE rtc1 := rtc + tz; END_IF;
	END_IF;
	sync := TRUE;
	last_sync := last;
	ty := last;
ELSIF rtc > DWORD_TO_DT(0) AND T1 - ty >= t#1s THEN
	rtc := rtc + t#1s;
	rtc1 := rtc1 + t#1s;
	ty := ty + t#1s;
	sync := ty - last_sync < sync_timeout AND last_sync > DWORD_TO_TIME(0);
	wday := DAY_OF_WEEK(DT_TO_DATE(rtc1));
	DS := dst_en AND DST(utc);
END_IF;
msec := TIME_TO_INT(t1 - ty);



(* decode information
bits		content
0			Bitwert immer 0
1 bis 14	reserviert für Betriebsinformationen (nicht für DCF77-Nutzer bestimmt)
15			Rufbit für Alarmierung der PTB-Mitarbeiter
			(bis Mai 2003: Bitwert = 0 falls normale Antenne in Verwendung; 1 = Backupantenne)
16			Bitwert = 1 falls ein Wechsel von MEZ nach MESZ oder umgekehrt bevorsteht; Dauer der Anzeige: 1 Stunde
17 + 18	gültige Zeit = MEZ, falls Bit 17=0 und Bit 18=1
			gültige Zeit = MESZ, falls Bit 17=1 und Bit 18=0
19			Bitwert = 1 falls innerhalb den nächsten 59 Minuten eine Schaltsekunde angeordnet ist. Beim Einfügen einer Schaltsekunde wird anstelle der 59. die 60. Sekundenmarke weggelassen und in der 58. erfolgt ausnahmsweise ein Trägerabfall.
20			Startbit für Zeitinformation (immer 1)
21 - 27		1, 2, 4, 8, 10, 20, 40 Minuten (bitweise Addition)
28			Prüfbit (gerade Parität) für die Bits 21-27
29 - 34		1, 2, 4, 8, 10, 20 Stunden (bitweise Addition)
35			Prüfbit (gerade Parität) für die Bits 29-34
36 - 41		Tagesnummer im aktuellen Monat: 1, 2, 4, 8, 10, 20 (bitweise Addition)
42 - 44		Tagesnummer in der aktuellen Woche: 1, 2, 4 (bitweise Addition)
45 - 49		Monatsnummer: 1, 2, 4, 8, 10 (bitweise Addition)
50 - 57		Jahr (zweistellig): 1, 2, 4, 8, 10, 20, 40, 80 (bitweise Addition)
58			Prüfbit (gerade Parität) füR die Bits 36-57

*)
(* revision history

AXEL	23 nov 2021
	replaced T_PLC_MS with sysTimer to avoid dependencies


hm 2.feb 2007		rev 1.1
	change wday and dst outputs when there is no dcf reception

hm	26.feb 2007		rev 1.2
	changed statements where t#1h would be substracted from DT.
	under certain conditions the compiler would crash translating this statement

hm	17. sep 2007	rev 1.3
	replaced time() with T_PLC_MS() for compatibility reasons

hm	24. oct 2007		rev 1.4
	changed dst calculation because function dst was upgraded no error in DCF77 only a change in DST

hm	12. nov 2007		rev 1.5
	changed time_offset from time to integer to allow for negative offset time zones

hm	8. dec 2007		rev 1.6
	corrected an error in time_zone calculation

hm 23. jan 2008		rev 1.7
	added sdt input which is used to initialize rtc and rtc1 during first cycle.

hm 16. mar 2008		rev 1.8
	changed output weekday to wday and dst to ds for compatibility reasons

hm	19. apr. 2008	rev 1.9
	added input dsi to allow to set daylight savings time when SDT is TRUE.
	added asynchronous SET input

hm	7. oct. 2008	rev 1.10
	changed function weekday to day_of_week

*)



]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="HOLIDAY" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<vars>
							<inoutVars>
								<var name="HOLIDAYS" type="HOLIDAY_DATA" dim0="30"/>
							</inoutVars>
							<inputVars>
								<var name="DATE_IN" type="DATE"/>
								<var name="LANGU" type="INT"/>
								<var name="FRIDAY" type="BOOL"/>
								<var name="SATURDAY" type="BOOL"/>
								<var name="SUNDAY" type="BOOL"/>
							</inputVars>
							<outputVars>
								<var name="Y" type="BOOL"/>
								<var name="NAME" type="STRING" length="30"/>
							</outputVars>
							<localVars>
								<var name="SIZE" type="INT">
									<initValue>29</initValue>
								</var>
								<var name="last_active" type="DATE"/>
								<var name="ostern" type="DATE"/>
								<var name="i" type="INT"/>
								<var name="jahr" type="INT"/>
								<var name="x_date" type="DATE"/>
								<var name="lx" type="INT"/>
								<var name="wdx" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 2.0	18. jans 2011
programmer 	hugo
tested by		tobias

holiday calculates if a given day is a holiday and displays the name of the holiday as string as well as a boolean flag to indicate a holiday.
the holidays are specified in the country setup under global constants.
a holiday can be of fixed date for example new years day on january 1st.
a holiday can have a fixed offset from easter sunday as for most church holidays.
a holiday can be a specific weekday before a fixed date, for example buss und bettag is the last wednesday before nov 23rd.
with a simple f_use flag any specific holiday can be turned on or off if needed.

please check the manual for examples of holiday definitions
*)

(* for performance reasons only activate once a day *)
IF last_active = date_in THEN RETURN; END_IF;
last_active := DATE_IN;

(* determine language *)
IF LANGU = 0 THEN
	lx := language.DEFAULT;
ELSE
	lx := MIN(language.LMAX, LANGU);
END_IF;

(* berechnung von ostern für das aktuelle jahr *)
jahr := YEAR_OF_DATE(date_in);
ostern := EASTER(jahr);
wdx := DAY_OF_WEEK(DATE_IN);
Y := FALSE;

(* check for holidays *)
FOR i := 0 TO size DO
	x_date := SET_DATE(jahr, HOLIDAYS[i].MONTH , HOLIDAYS[i].DAY);
	IF HOLIDAYS[i].USE = 1 AND HOLIDAYS[i].MONTH > 0 THEN
		(* check for fixed date holiday *)
		IF x_date = date_in THEN
			Y := TRUE;
			NAME := HOLIDAYS[i].NAME;
			RETURN;
		END_IF;
	ELSIF HOLIDAYS[i].USE = 1 AND HOLIDAYS[i].MONTH = 0 THEN
		(* check for holiday in reference to easter *)
		IF DATE_ADD(ostern, HOLIDAYS[i].DAY ,0,0,0) = date_in THEN
			Y := TRUE;
			NAME := HOLIDAYS[i].NAME;
			RETURN;
		END_IF;
	ELSIF HOLIDAYS[i].USE < 0 THEN
		(* check for holiday on a weekday before date *)
		IF DAY_OF_WEEK(date_in) = ABS(HOLIDAYS[i].USE) AND date_in < x_date AND date_in >= DATE_ADD(x_date,-7,0,0,0) THEN
			Y := TRUE;
			NAME := HOLIDAYS[i].NAME;
			RETURN;
		END_IF;
	END_IF;
END_FOR;

(* check array if today is weekend *)
IF NOT Y AND (wdx = 5 AND FRIDAY OR wdx = 6 AND SATURDAY OR wdx = 7 AND SUNDAY) THEN
	Y := TRUE;
	NAME := LANGUAGE.WEEKDAYS[LOCATION.LANGUAGE[lx],wdx];
ELSE
	NAME := '';
END_IF;


(*
Neujahrstag 	1. Januar 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	•
Heilige Drei Könige 	6. Januar 	• 	• 												• 		
Karfreitag 	Ostersonntag - 2d 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	•
Ostersonntag 	siehe Osterdatum 				(•) 												
Ostermontag 	Ostersonntag + 1d 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	•
Tag der Arbeit 	1. Mai 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	•
Christi Himmelfahrt 	Ostersonntag + 39d 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	•
Pfingstsonntag 	Ostersonntag + 49d 				(•) 												
Pfingstmontag 	Ostersonntag + 50d 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	•
Fronleichnam 	Ostersonntag + 60d 	• 	• 					• 			• 	• 	• 	1) 			2)
Augsburger Friedensfest 	8. August 		(3) 														
Mariä Himmelfahrt 	15. August 		(5) 										• 				
Tag der Deutschen Einheit 	3. Oktober 6) 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	•
Reformationstag 	31. Oktober 				• 				• 					• 	• 		•
Allerheiligen 	1. November 	• 	• 								• 	• 	• 				
Buß- und Bettag 4) 	Mittwoch vor dem 23.11. 			7 										• 			
1. Weihnachtstag 	25. Dezember 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	•
2. Weihnachtstag 	26. Dezember 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	• 	•
*)



(* revision history
hm 	27. feb. 2007	rev 1.1
	deleted unused variable init

hm	31. oct. 2007	rev 1.2
	changed holiday definition from constant to input constant to allow easier changes by user without recompilation of the lib

hm 	24. nov. 2007	rev 1.3
	changes F_use of  Buß_und_Bettag to 0 because this is no official holiday

hm	7. apr. 2008	rev 1.4
	improved performance

hm	7. oct. 2008	rev 1.5
	changed code to use setup data from global constants
	changed length of output NAME from 20 to 30
	holiday will now also be indicated on a weekend
	changed function year to year_of_date
	changed function weekday to day_of_week

hm	21. oct. 2008	rev 1.6
	using location constants

hm	18. jan 2011	rev 2.0
	using user specified array for holidays

*)


]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="SUN_TIME" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<vars>
							<inputVars>
								<var name="LATITUDE" type="REAL">
									<descr>latitude of geographical position</descr>
								</var>
								<var name="LONGITUDE" type="REAL">
									<descr>longitude of geographical position</descr>
								</var>
								<var name="UTC" type="DATE">
									<descr>world time</descr>
								</var>
								<var name="H" type="REAL">
									<descr>heighth above horizon for sunrise</descr>
									<initValue>-0.83333333333</initValue>
								</var>
							</inputVars>
							<outputVars>
								<var name="MIDDAY" type="TIME_OF_DAY">
									<descr>astrological midday in hours when sun stands
									at south direction</descr>
								</var>
								<var name="SUN_RISE" type="TIME_OF_DAY">
									<descr>sun rise for current day in local time</descr>
								</var>
								<var name="SUN_SET" type="TIME_OF_DAY">
									<descr>sun set for current day in local time</descr>
								</var>
								<var name="SUN_DECLINATION" type="REAL">
									<descr>sun declination above horizon at midday in
									degrees</descr>
								</var>
							</outputVars>
							<localVars>
								<var name="dk" type="REAL">
									<descr>sun declination at midday</descr>
								</var>
								<var name="delta" type="TIME">
									<descr>delta from midday for sunrise and sunset</descr>
								</var>
								<var name="b" type="REAL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 1.7	25. jan. 2011
programmer 	hugo
tested by	tobias

this FUNCTION block calculates the sun rise, sun set, sun offset at midday sun declination for a given date 
for performance reasons the algorithm has been simplified and is accurate within a few minutes only 
the times are calculated in utc and have to be corrected for the given time zone
this correction is not done within sun_time because it would be a problem on days where dst is enabled or disabled

*)

B := latitude * 0.0174532925199433;
MIDDAY := SUN_MIDDAY(longitude, utc);
DK := 0.40954 * SIN(0.0172 * (TO_REAL(DAY_OF_YEAR(utc)) - 79.35));
sun_declination := DEG(DK);
IF sun_declination > 180.0 THEN sun_declination := sun_declination - 360.0; END_IF;
sun_declination := 90.0 - LATITUDE + sun_declination;
delta := HOUR_TO_TIME(ACOS((SIN(RAD(H)) - SIN(B) * SIN(DK)) / (COS(B) * COS(DK))) * 3.819718632);
sun_rise := MIDDAY - delta;
sun_set := MIDDAY + delta;

(* revision history

rev 1.1	hm	20.1.2007
	deleted unused variables sun_riseR and sun_setR

rev 1.2 hm 17.4.2007
	corrected error while sun:midday would not be corrected for longitude.

rev 1.3	hm	6. jan 2008
	performance improvements

rev	1.4 hm	17. jan 2008
	calculation is now only performed once a day

hm	10. mar. 2009	rev 1.5
	improved performance
	calculation will be performed on every call to allow movong installations

hm	26. jul 2009	rev 1.6
	fixed a problem with wrong midday calculation

hm	25. jan. 2011	rev 1.7
	using function sun_midday
	corrected angle of sun_declination
	added input H
*)
]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="SUN_POS" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<vars>
							<inputVars>
								<var name="latitude" type="REAL">
									<descr>latitude of geographical position</descr>
								</var>
								<var name="longitude" type="REAL">
									<descr>longitude of geographical position</descr>
								</var>
								<var name="utc" type="DATE_AND_TIME">
									<descr>world time</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="B" type="REAL"/>
								<var name="H" type="REAL"/>
								<var name="HR" type="REAL"/>
							</outputVars>
							<localVars>
								<var name="g" type="REAL"/>
								<var name="a" type="REAL"/>
								<var name="d" type="REAL"/>
								<var name="t1" type="REAL"/>
								<var name="n" type="REAL"/>
								<var name="e" type="REAL"/>
								<var name="c" type="REAL"/>
								<var name="tau" type="REAL"/>
								<var name="sin_d" type="REAL"/>
								<var name="rlat" type="REAL"/>
								<var name="sin_lat" type="REAL"/>
								<var name="cos_lat" type="REAL"/>
								<var name="cos_tau" type="REAL"/>
								<var name="cos_d" type="REAL"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 2.1	7. mar. 2009
programmer 	hugo
tested by		oscat

this FUNCTION block calculates the sun position for a given date and time.
the times are calculated in utc and have to be corrected for the given time zone.
B is the angle from north and HR is the highth in degrees.

*)


(* n is the julian date and the number of days since 1.1.2000-12:00 midday *)
(* be careful for step7 date startes 1.1.1990 instead of 1.1.1970 *)
(* for step7 this line must change *)
n := TO_REAL(DT_TO_DWORD(UTC) - 946728000) * 0.000011574074074074;
g :=MODR(6.240040768 + 0.01720197 * n, math.PI2);
d := MODR(4.89495042 + 0.017202792 * n, math.PI2) + 0.033423055 * SIN(g) + 0.000349066 * SIN(2.0*g);
e := 0.409087723 - 0.000000006981317008 * n;
cos_d := COS(d);
sin_d := SIN(d);
a := ATAN(COS(e) * sin_d / cos_d);
IF cos_d < 0.0 THEN a := a + math.PI; END_IF;
c := ASIN(SIN(e) * sin_d);

(* also here we must be very careful utc is from 1.1.1970 for step7 the formula must change *)
tau := RAD(MODR(6.697376 + (n - 0.25) * 0.0657098245037645 + TO_REAL(TOD_TO_DWORD(DT_TO_TOD(utc))) * 0.0000002785383333, 24.0) * 15.0 + longitude) - a;
rlat := RAD(latitude);
sin_lat := SIN(rlat);
cos_lat := COS(rlat);
cos_tau := COS(tau);
t1 := cos_tau * sin_lat - TAN(c) * cos_lat;
B := ATAN(SIN(tau) / t1);
IF t1< 0.0 THEN B := B + math.PI2; ELSE B := B + math.PI; END_IF;
B := DEG(MODR(B, math.PI2));
h := DEG(ASIN(COS(C) * cos_tau * cos_lat +SIN(c) * sin_lat));
IF h > 180.0 THEN h := h - 360.0; END_IF;
(* consider refraction *)
HR := h + REFRACTION(h);


(* revision history
hm	1. feb 2007	rev 1.0
	original version

hm	6. jan 2008	rev 1.1
	performance improvements

hm	18. jan 2008	rev 1.2
	further performance improvements
	only calculate once every 10 seconds

hm	16. mar. 2008	rev 1.3
	added type conversion to avoid warnings under codesys 3.0

hm	30. jun. 2008	rev 1.4
	added type conversions to avoid warnings under codesys 3.0

hm	18. oct. 2008	rev 1.5
	using math constants

hm	17. dec. 2008	rev 1.6
	angles below horizon are displayed in negative degrees

hm	27. feb. 2009	rev 2.0
	new code with better accuracy

hm	7. mar. 2009	rev 2.1
	refraction is added after angle normalization
	deleted 10 second lockout
	added output for astronomical heigth h
*)
]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="RTC_2" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<vars>
							<inputVars>
								<var name="SET" type="BOOL"/>
								<var name="SDT" type="DATE_AND_TIME"/>
								<var name="SMS" type="INT"/>
								<var name="DEN" type="BOOL"/>
								<var name="OFS" type="INT"/>
							</inputVars>
							<outputVars>
								<var name="UDT" type="DATE_AND_TIME"/>
								<var name="LDT" type="DATE_AND_TIME"/>
								<var name="DSO" type="BOOL"/>
								<var name="XMS" type="INT"/>
							</outputVars>
							<localVars>
								<var name="RT" type="RTC_MS"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 1.4	27. 	apr. 2011
programmer 	hugo
tested by		tobias

RTC_2 is a real time clock module which runs utc and generates local time from utc.
daylight savings time can be enabled with den and an additional local time is generated with a delay of ofs im minutes.

*)


(* call rtc *)
RT(SET := SET, SDT := SDT, SMS := SMS);
UDT := rt.xdt;
XMS := rt.XMS;

(* check for daylight savings time and set dso output *)
DSO := DST(udt) AND DEN;

(* calculate time offset and set ldt output *)
LDT := DWORD_TO_DT(DT_TO_DWORD(UDT) + TO_DWORD(ofs + TO_INT(DSO)*60) * 60);


(* revision history
hm		20. jan. 2008	rev 1.0
	original version

hm		20. feb. 2008	rev 1.1
	added Millisecond Set input

hm		12. jun. 2008	rev 1.2
	improved performance

hm		20. jan. 2011	rev 1.3
	changed offset to be in minutes

hm		27. apr. 2011	rev 1.4
	fixed error with local time calculation

*)
]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="RTC_MS" version="1.0.0" creationDate="0" lastModifiedDate="1637665534" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<vars>
							<inputVars>
								<var name="SET" type="BOOL"/>
								<var name="SDT" type="DATE_AND_TIME"/>
								<var name="SMS" type="INT"/>
							</inputVars>
							<outputVars>
								<var name="XDT" type="DATE_AND_TIME"/>
								<var name="XMS" type="INT"/>
							</outputVars>
							<externalVars>
								<var name="sysTimer" type="UDINT"/>
							</externalVars>
							<localVars>
								<var name="init" type="BOOL"/>
								<var name="last" type="DWORD"/>
								<var name="Tx" type="DWORD"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[

(*
version 1.1	20. feb. 2008
programmer 	hugo
tested by	tobias

RTC_MS is a real time clock module which can be set to SDT when set is TRUE and the outputs XDT and XT present the DateTime and TOD with a resolution of milliseconds.

*)


tx := sysTimer;
IF set OR NOT init THEN
	(* clock needs to be set when set is true or after power up *)
	init := TRUE;
	xdt := SDT;
	XMS := SMS;
ELSE
	XMS := XMS + TO_INT(tx - last);
	(* check if one second has expired *)
	IF XMS > 999 THEN
		XDT := XDT + T#1s;
		XMS := XMS - 1000;
	END_IF;
END_IF;
last := tx;


(* revision history
AXEL	23 nov 2021
	replaced T_PLC_MS with sysTimer to avoid dependencies

hm		20. jan. 2008	rev 1.0
	original version

hm		20. feb. 2008	rev 1.1
	added Millisecond Set input
*)
]]>
						</sourceCode>
					</functionBlock>
				</functionBlocks>
				<programs/>
				<macros/>
				<structs/>
				<typedefs/>
				<enums/>
				<subranges/>
				<interfaces/>
			</lib>
			<lib version="1.0.1" name="C:\Program Files (x86)\Arduino PLC IDE\Arduino PLC IDE\Libraries\OSCAT\Oscat - Calculations.plclib" fullXml="true" link="true">
				<descr>Calculations. Author URL: http://oscat.de/</descr>
				<libWorkspace>
					<folder name="Oscat - Calculations" excludeFromBuild="false" excludeFromBuildIfNotDef="">
						<Pou name="ASTRO"/>
						<Pou name="ENERGY"/>
						<Pou name="GEO_TO_DEG"/>
						<Pou name="LENGTH"/>
						<Pou name="PRESSURE"/>
						<Pou name="DIR_TO_DEG"/>
						<Pou name="PT_TO_F"/>
						<Pou name="F_TO_OM"/>
						<Pou name="F_TO_PT"/>
						<Pou name="OM_TO_F"/>
						<Pou name="BFT_TO_MS"/>
						<Pou name="KMH_TO_MS"/>
						<Pou name="MS_TO_BFT"/>
						<Pou name="MS_TO_KMH"/>
						<Pou name="SPEED"/>
						<Pou name="C_TO_F"/>
						<Pou name="C_TO_K"/>
						<Pou name="F_TO_C"/>
						<Pou name="K_TO_C"/>
						<Pou name="TEMPERATURE"/>
					</folder>
				</libWorkspace>
				<globalVars/>
				<retainVars/>
				<constantVars/>
				<functions>
					<function name="GEO_TO_DEG" version="1.0.0" creationDate="0" lastModifiedDate="1631182375" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>GEO_TO_DEG calculates an angle expressed in degrees, minutes, seconds into decimal degrees.</descr>
						<returnValue>LREAL</returnValue>
						<vars>
							<inputVars>
								<var name="D" type="INT">
									<descr>Angle in degrees</descr>
								</var>
								<var name="M" type="INT">
									<descr>Arc minutes</descr>
								</var>
								<var name="SEC" type="LREAL">
									<descr>Arc seconds</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.0	22. jan. 2009
programmer 	hugo
tested by	oscat

This function converts degrees, minutes and seconds to decimal degrees.

*)


GEO_TO_DEG := TO_LREAL(D) + TO_LREAL(M) * LREAL#0.016666666666667 + sec * LREAL#0.00027777777777778;


(* revision histroy
hm	22. jan. 2009	rev 1.0
	original release
*)
]]>
						</sourceCode>
					</function>
					<function name="DIR_TO_DEG" version="1.0.0" creationDate="0" lastModifiedDate="1631180421" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="DIR" type="STRING" length="3">
									<descr>Direction in compass readings</descr>
								</var>
								<var name="L" type="INT">
									<descr>Language selection</descr>
								</var>
							</inputVars>
							<localVars>
								<var name="ly" type="INT"/>
								<var name="i" type="INT"/>
							</localVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	22. oct. 2008
programmer 	hugo
tested by	oscat

This function converts compass directions to degrees.
It will recognize up to 3 letter directions in english and german writing.

*)

IF L = 0 THEN 
	ly := LANGUAGE.DEFAULT;
ELSE 
	ly := MIN(L, LANGUAGE.LMAX);
END_IF;

FOR i := 0 TO 15 DO
	IF language.DIRS[ly, i] = DIR THEN
		EXIT;
	END_IF;
END_FOR;
DIR_TO_DEG := SHR(i * 45 + 1, 1);



(* revision histroy
hm	22. oct. 2008	rev 1.1
	original release
*)
]]>
						</sourceCode>
					</function>
					<function name="PT_TO_F" version="1.0.0" creationDate="0" lastModifiedDate="1631113787" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>PT_TO_F converts a period of time into frequency in Hz.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="PT" type="TIME">
									<descr>Period time</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*
version 1.1	11. mar. 2009
programmer 	hugo
tested by	tobias

This function converts time period to frequency in Hz

*)


PT_TO_F := 1000.0 / TO_REAL(TO_DWORD(PT));


(*	revision history
hm	4. aug. 2006	rev 1.0
	original version

hm	11. mar. 2009	rev 1.1
	real constants updated to new systax using dot
*)

]]>
						</sourceCode>
					</function>
					<function name="F_TO_OM" version="1.0.0" creationDate="0" lastModifiedDate="1637333784" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>F_TO_OM calculates the angular frequency omega of the frequency in Hz.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="F" type="REAL">
									<descr>Frequency in Hz</descr>
								</var>
							</inputVars>
							<localConsts>
								<const name="PI2" type="REAL">
									<descr>PI*2</descr>
									<initValue>6.28318530717958647692528676655900576</initValue>
								</const>
							</localConsts>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[


(*
version 1.1	18. oct. 2008
programmer 	hugo
tested by	oscat

this function converts frequency to Omega F
Omega = 2*PI*F
*)

F_TO_OM := PI2 * F;


(* revision history
hm	22. jan. 2007	rev 1.0
	original version

hm	18. oct. 2008	rev 1.1
	unsing math constants

*)
]]>
						</sourceCode>
					</function>
					<function name="F_TO_PT" version="1.0.0" creationDate="0" lastModifiedDate="1631113698" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>F_TO_PT converts a frequency value in Hz into the corresponding period.</descr>
						<returnValue>TIME</returnValue>
						<vars>
							<inputVars>
								<var name="F" type="REAL">
									<descr>Frequency in Hz</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	11. mar. 2009
programmer 	hugo
tested by	tobias

this function converts frequency (in Hz) to time period

*)


F_TO_PT := TO_TIME(TO_DWORD(1.0 / F * 1000.0));


(* revision history
hm	4. aug. 2006	rev 1.0
	original version

hm	11. mar. 2009	rev 1.1
	real constants updated to new systax using dot
*)

]]>
						</sourceCode>
					</function>
					<function name="OM_TO_F" version="1.0.0" creationDate="0" lastModifiedDate="1637334097" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>OM_TO_F calculates the frequency in Hz into the corresponding angular frequency omega.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="OM" type="REAL">
									<descr>Angular frequency omega</descr>
								</var>
							</inputVars>
							<localConsts>
								<const name="PI2" type="REAL">
									<descr>PI * 2</descr>
									<initValue>6.28318530717958647692528676655900576</initValue>
								</const>
							</localConsts>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	18. oct. 2008
programmer 	hugo
tested by	tobias

This function converts Omega F to frequency
F = OM / (2*PI)

*)


OM_TO_F := OM / PI2;


(* revision history
hm	22. jan. 2007	rev 1.0
	original version

hm	18. oct. 2008	rev 1.1
	using math constants
*)
]]>
						</sourceCode>
					</function>
					<function name="BFT_TO_MS" version="1.0.0" creationDate="0" lastModifiedDate="1631111931" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>BFT_TO_MS converts the wind speed from the Beaufort scale into meters per second.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="BFT" type="INT">
									<descr>Wind force on the Beaufort scale</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*
version 1.0	12. jun 2008
programmer 	hugo
tested by	oscdat

This function converts wind speed from beaufort to m/s
*)

BFT_TO_MS := POW(TO_LREAL(BFT), 1.5) * 0.836;


(* revision history
hm	12. 6. 2008		rev 1.0
	original version
*)
]]>
						</sourceCode>
					</function>
					<function name="KMH_TO_MS" version="1.0.0" creationDate="0" lastModifiedDate="1631183010" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>KMH_TO_MS converts Kilomters per Hour into Meters per Second.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="kmh" type="REAL">
									<descr>Speed in Km/h</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*
version 1.1	6 jan 2007
programmer 	hugo
tested by	tobias

This function converts velocities from Kilometers / hour to Meters / Second

*)

KMH_TO_MS := kmh * 0.2777777777777;

(* revision history
hm	4. feb 2007		rev 1.0
	original version

hm	6. jan 2008		rev 1.1
	improved performance
*)


]]>
						</sourceCode>
					</function>
					<function name="MS_TO_BFT" version="1.0.0" creationDate="0" lastModifiedDate="1631114758" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>MS_TO_BFT converts wind speed from meters per second into the Beaufort scale.</descr>
						<returnValue>INT</returnValue>
						<vars>
							<inputVars>
								<var name="MS" type="REAL">
									<descr>Wind speed in meters / second</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.0	12. jun 2008
programmer 	hugo
tested by	oscdat

This function converts wind speed from M/s to beaufort

*)


MS_TO_BFT := TO_INT(POW(MS * 1.196172, 0.666667));


(* revision history
hm	12. 6. 2008		rev 1.0
	original version
*)
]]>
						</sourceCode>
					</function>
					<function name="MS_TO_KMH" version="1.0.0" creationDate="0" lastModifiedDate="1631190346" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>MS_TO_KMH converts a speed value of meters/second to kilometers/hour.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="ms" type="REAL">
									<descr>Speed in m/s</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.0	4 Feb 2007
programmer 	hugo
tested by	tobias

This function converts velocities from Meters / Second to Kilometers / hour.

*)

MS_TO_KMH := ms * 3.6;


]]>
						</sourceCode>
					</function>
					<function name="C_TO_F" version="1.0.0" creationDate="0" lastModifiedDate="1631112226" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>C_TO_F converts a temperature from Celsius degrees to Fahrenheit.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="celsius" type="REAL">
									<descr>Temperature in Celsius degrees</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*
version 1.1	11. mar. 2009
programmer 	hugo
tested by	tobias

This function converts celsius to fahrenheit 

*)


C_TO_F := celsius * 1.8 + 32.0;


(* revision history

hm	4. aug. 2006	rev 1.0
	original version

hm	11. mar. 2009	rev 1.1
	real constants updated to new systax using dot
*)
]]>
						</sourceCode>
					</function>
					<function name="C_TO_K" version="1.0.0" creationDate="0" lastModifiedDate="1637333825" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>C_TO_K converts a temperature from Celsius to Kelvin.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="Celsius" type="REAL">
									<descr>Temperature in Celsius degrees</descr>
								</var>
							</inputVars>
							<localConsts>
								<const name="T0" type="REAL">
									<descr>Absolute zero</descr>
									<initValue>-273.15</initValue>
								</const>
							</localConsts>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	19. aug 2009
programmer 	hugo
tested by		tobias

This function converts celsius to kelvin

*)


C_TO_K := Celsius - T0;


(* revision history

hm	4. aug 2006	rev 1.0
	original version

hm	19. aug 2009	rev 1.1
	fixed calculation error
*)

]]>
						</sourceCode>
					</function>
					<function name="F_TO_C" version="1.0.0" creationDate="0" lastModifiedDate="1631113351" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>F_TO_C converts a temperature from Fahrenheit to Celsius.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="fahrenheit" type="REAL">
									<descr>Temperature value in Fahrenheit</descr>
								</var>
							</inputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	11. mar. 2009
programmer 	hugo
tested by	tobias

This function converts fahrenheit to celsius

*)


F_TO_C := (fahrenheit - 32.0) * 0.5555555555555;


(* revision history
hm	4. aug 2006	rev 1.0
	original version

hm	11. mar. 2009	rev 1.1
	real constants updated to new systax using dot
*)
]]>
						</sourceCode>
					</function>
					<function name="K_TO_C" version="1.0.0" creationDate="0" lastModifiedDate="1637333873" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>K_TO_C converts a temperature from Kelvin to Celsius.</descr>
						<returnValue>REAL</returnValue>
						<vars>
							<inputVars>
								<var name="Kelvin" type="REAL">
									<descr>Temperature value in Kelvin</descr>
								</var>
							</inputVars>
							<localConsts>
								<const name="T0" type="REAL">
									<descr>Absolute zero</descr>
									<initValue>-273.15</initValue>
								</const>
							</localConsts>
						</vars>
						<iecDeclaration active="FALSE"/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	19. aug 2009
programmer 	hugo
tested by	tobias

This function converts kelvin to celsius

*)


K_TO_C := Kelvin + T0;


(* revision history

hm	4. aug 2006	rev 1.0
	original version

hm	19. aug 2009	rev 1.1
	fixed calculation error
*)

]]>
						</sourceCode>
					</function>
				</functions>
				<functionBlocks>
					<functionBlock name="ASTRO" version="1.0.0" creationDate="0" lastModifiedDate="1631111203" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>&lt;HTML&gt;&lt;p&gt;The module ASTRO converts various distance units commonly used in
						astronomy. Normally, only the input to be converted is occupied and the
						remaining inputs remain free. However, if several inputs are loaded with
						values, all input values are converted and then summed.&lt;/p&gt;</descr>
						<vars>
							<inputVars>
								<var name="m" type="LREAL">
									<descr>Distance in Meters</descr>
								</var>
								<var name="AU" type="LREAL">
									<descr>Distance in Astronomical Units</descr>
								</var>
								<var name="PC" type="LREAL">
									<descr>Distance in Parsecs</descr>
								</var>
								<var name="LY" type="LREAL">
									<descr>Distance in Light Years</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Ym" type="LREAL">
									<descr>Distance in Meters</descr>
								</var>
								<var name="YAU" type="LREAL">
									<descr>Distance in Astronomical Units</descr>
								</var>
								<var name="YPC" type="LREAL">
									<descr>Distance in Parsecs</descr>
								</var>
								<var name="YLY" type="LREAL">
									<descr>Distance in Light Years</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	11. mar. 2009
programmer 	hugo
tested by	oscat

This function converts different length units
Any unused input can simply be left open.
Different inputs connected at the same time will be added up.

*)

YAU :=	AU
		+ m * 6.6845871535E-012
		+ PC * 206265.0
		+ LY * 63240.0;
Ym := YAU * 149.597870E9;
YPC := YAU * 4.8481322570E-006;
YLY := YAU * 1.5812776724E-005;

(* revision history

hm	27. mar. 2007	rev 1.0
	original version

hm	11. mar. 2009	rev 1.1
	improved code
*)

]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="ENERGY" version="1.0.0" creationDate="0" lastModifiedDate="1631181875" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>&lt;HTML&gt;&lt;p&gt;The module converts ENERGY in different units of
						energy. Normally, only the input to be converted is written and the remaining
						inputs remain free. However, if several inputs are loaded with values,
						the values of all inputs are converted and then summed.&lt;/p&gt;</descr>
						<vars>
							<inputVars>
								<var name="J" type="REAL">
									<descr>Joule</descr>
								</var>
								<var name="C" type="REAL">
									<descr>Calories</descr>
								</var>
								<var name="Wh" type="REAL">
									<descr>Watt hours</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="YJ" type="REAL">
									<descr>Joule</descr>
								</var>
								<var name="YC" type="REAL">
									<descr>Calories</descr>
								</var>
								<var name="YWh" type="REAL">
									<descr>Watt hours</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[
(*
version 1.2	16. jan. 2010
programmer 	hugo
tested by	oscat

This function converts different energy units
Any unused input can simply be left open.
Different inputs connected at the same time will be added up.
*)

YJ := J + Wh * 3600.0 + C * 4.1868;
YC := YJ * 0.238845896627496;
YWh := YJ * 2.7777777778E-004;

(*
Arbeit, Energie, Joule* J 1 J = 1 N · m = 1 W · s = (1/3,6) E–6 kW · h = 1 kg · m2/s2
Wärmemenge Kilowattstunde kW · h 1 kW · h = 3,6 MJ = 860 kcal
Elektronvolt eV 1 eV = 160,218 92 E–21 J
Erg erg 1 erg = 1E–7 J
Kalorie calorie 1 calalorie = 4,1868 J = 1,163 E–3 W · h
Therm therm 1 therm = 105,50 · 106 J
*)

(* revision history
hm	27. mar. 2007	rev 1.0
	original version

hm	11. mar. 2009	rev 1.1
	improved code

hm 16. jan 2010	rev 1.2
	avoid the string cal in comments for codesys import bug
*)
]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="LENGTH" version="1.0.0" creationDate="0" lastModifiedDate="1631190013" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>&lt;HTML&gt;&lt;p&gt;The module LENGTH converts different units of
						length. Normally, only the input to be converted is written and the remaining
						inputs remain free. However, if several inputs are loaded with values,
						the values of all inputs are converted and then summed.&lt;/p&gt;</descr>
						<vars>
							<inputVars>
								<var name="m" type="REAL">
									<descr>Meter</descr>
								</var>
								<var name="p" type="REAL">
									<descr>Typographic point</descr>
								</var>
								<var name="in" type="REAL">
									<descr>Inch</descr>
								</var>
								<var name="ft" type="REAL">
									<descr>Foot</descr>
								</var>
								<var name="yd" type="REAL">
									<descr>Yard</descr>
								</var>
								<var name="mile" type="REAL">
									<descr>Mile</descr>
								</var>
								<var name="sm" type="REAL">
									<descr>International nautical mile</descr>
								</var>
								<var name="fm" type="REAL">
									<descr>Fathom</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Ym" type="REAL">
									<descr>Meter</descr>
								</var>
								<var name="Yp" type="REAL">
									<descr>Typographic point</descr>
								</var>
								<var name="Yin" type="REAL">
									<descr>Inch</descr>
								</var>
								<var name="Yft" type="REAL">
									<descr>Foot</descr>
								</var>
								<var name="Yyd" type="REAL">
									<descr>Yard</descr>
								</var>
								<var name="Ymile" type="REAL">
									<descr>Mile</descr>
								</var>
								<var name="Ysm" type="REAL">
									<descr>International nautical mile</descr>
								</var>
								<var name="Yfm" type="REAL">
									<descr>Fathom</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	11. mar. 2009
programmer 	hugo
tested by		oscat

This function converts different length units.
Any unused input can simply be left open.
Different inputs connected at the same time will be summed up.

*)


Ym :=	m
		+ p * 0.000376065
		+ in * 0.0254
		+ ft * 0.3048
		+ yd * 0.9144
		+ mile * 1609.344
		+ sm * 1852.0
		+ fm * 1.829;
Yp := Ym * 2659.11478068951;
Yin := Ym * 39.37007874016;
Yft := Ym * 3.28083989501;
Yyd := Ym * 1.09361329834;
Ymile := Ym * 0.00062137119;
Ysm := Ym * 0.00053995680;
Yfm := Ym * 0.54674685621;

(*
Länge Meter m SI-Basiseinheit
Astronomische Einheit* AE 1 AE = 149,597 870 · E9 m
Parsec pc 1 pc = 206265 AE = 30,857 · E15 m
Lichtjahr Lj 1 Lj = 9,460 530 · E15 m = 63240 AE = 0,306 59 pc
Ångström Å 1 Å = E–l0 m
typograph. Punkt p 1 p = 0,376 065 mm • im Druckereigewerbe
inch** in 1 in = 2,54 · E–2 m = 25,4 mm***
foot ft 1 ft = 0,3048 m = 30,48 cm
yard yd 1 yd = 0,9144 m
mile mile 1 mile = 1609,344 m
Internat. Seemeile sm 1 sm = 1852 m
Fathom fm 1 fm = 1,829 m • in der Seeschifffahrt
*)

(* revision history

hm	27. mar. 2007	rev 1.0
	original version

hm	11. mar. 2009	rev 1.1
	improved code
*)

]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="PRESSURE" version="1.0.0" creationDate="0" lastModifiedDate="1631190625" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>&lt;HTML&gt;&lt;p&gt;The module PRESSURE converts different units for pressure. Usually, only the input to be converted is written and the remaining
						inputs remain free. However, if several inputs are loaded with values,
						the values of all inputs are converted and then summed.&lt;/p&gt;</descr>
						<vars>
							<inputVars>
								<var name="mws" type="REAL">
									<descr>Water column in meters</descr>
								</var>
								<var name="torr" type="REAL">
									<descr>Torr respectively mercury column in mm</descr>
								</var>
								<var name="att" type="REAL">
									<descr>Technical atmosphere</descr>
								</var>
								<var name="atm" type="REAL">
									<descr>Atmospheric physics</descr>
								</var>
								<var name="pa" type="REAL">
									<descr>Pascal</descr>
								</var>
								<var name="bar" type="REAL">
									<descr>Bar</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Ymws" type="REAL">
									<descr>Water column in meters</descr>
								</var>
								<var name="Ytorr" type="REAL">
									<descr>Torr respectively mercury column in mm</descr>
								</var>
								<var name="Yatt" type="REAL">
									<descr>Technical atmosphere</descr>
								</var>
								<var name="Yatm" type="REAL">
									<descr>Atmospheric physics</descr>
								</var>
								<var name="Ypa" type="REAL">
									<descr>Pascal</descr>
								</var>
								<var name="Ybar" type="REAL">
									<descr>Bar</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	11. mar. 2009
programmer 	hugo
tested by		oscat

This function converts different pressure units.
Any unused input can simply be left open.
Different inputs connected at the same time will be summed up.

*)

Ybar := bar +
		pa * 1.0E-5 +
		0.980665 * att +
		1.01325 * atm +
		0.001333224 * torr +
		0.0980665 * mws;
Ymws := ybar * 10.1971621297793;
Ytorr := ybar * 750.0615050434140;
Yatt := ybar * 1.0197162129779;
yatm := ybar * 0.9869232667160;
Ypa := ybar * 100000.0;


(*
Druck, Pascal Pa 1 Pa = 1 N/m2 = 1 kg/(s2 E m) . 0,75 E 10.2 mmHg
mechanische 1 MPa = 1 N/mm2 . fur Festigkeitsangaben
Spannung Bar bar 1 bar = 105 Pa = 103 mbar = 105 kg/(s2 E m)
Millimeter- mmHg 1 mmHg = 133,322 Pa = 1,333 22 mbar
Quecksilbersaule . nur in Heilkunde zulassig
physik. Atmosphare atm 1 atm = 1,013 25 bar
techn. Atmosphare at 1 at = 1 kp/cm2 = 0,980665 bar
Torr Torr 1 Torr = (101325/760) Pa = 1,333224 mbar
Meter-Wassersaule mWS 1 mWS = 9806,65 Pa = 98,0665 mbar
psi lbf/in2 1 lbf/in2 = 68,947 57 mbar = 6894,757 Pa
*)

(* revision history

hm	27. mar. 2007	rev 1.0
	original version

hm	11. mar. 2009	rev 1.1
	improved code
*)
]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="SPEED" version="1.0.0" creationDate="0" lastModifiedDate="1631191904" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>&lt;HTML&gt;&lt;p&gt;The module SPEED converts various units for speed.
						Normally, only the input to be converted is written and the remaining inputs remain free. However, if several inputs are loaded with values, the values
						of all inputs are converted and then summed.&lt;/p&gt;</descr>
						<vars>
							<inputVars>
								<var name="ms" type="REAL">
									<descr>meters / second</descr>
								</var>
								<var name="kmh" type="REAL">
									<descr>kilometers / hour</descr>
								</var>
								<var name="kn" type="REAL">
									<descr>knots</descr>
								</var>
								<var name="mh" type="REAL">
									<descr>miles / hour</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="Yms" type="REAL">
									<descr>meters / second</descr>
								</var>
								<var name="Ykmh" type="REAL">
									<descr>kilometers / hour</descr>
								</var>
								<var name="Ykn" type="REAL">
									<descr>knots</descr>
								</var>
								<var name="Ymh" type="REAL">
									<descr>miles / hour</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.1	11. mar. 2009
programmer 	hugo
tested by		oscat

This function converts different speed units.
Any unused input can simply be left open.
Different inputs connected at the same time will be summed up.

*)


Yms := ms +
		kmh * 0.27777777777778 +
		kn * 0.5144444 +
		mh * 0.44704;
Ykmh := Yms * 3.6;
Ykn := Yms * 1.94384466037535;
Ymh := Yms * 2.23693629205440;


(*
Geschwindigkeit Meter durch Sekunde m/s 1 m/s = 3,6 km/h
km durch (pro) Stunde, nicht „Stundenkilometer“ verwenden
Knoten kn 1 kn = 1 sm/h = 0,5144 m/s
*)

(* revision history
hm	27. mar. 2009	rev 1.0
	original version

hm	11. mar. 2009	rev 1.1
	improved code
*)
]]>
						</sourceCode>
					</functionBlock>
					<functionBlock name="TEMPERATURE" version="1.0.0" creationDate="0" lastModifiedDate="1631192547" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
						<descr>&lt;HTML&gt;&lt;p&gt;The module TEMPERATURE converts different units for
						temperature. Normally, only the input to be converted is written and the
						remaining inputs remain free. However, if several inputs are loaded with values,
						the values of all inputs are converted and then summed.&lt;/p&gt;</descr>
						<vars>
							<inputVars>
								<var name="K" type="REAL">
									<descr>Kelvin</descr>
								</var>
								<var name="C" type="REAL">
									<descr>Celsius</descr>
									<initValue>-273.15</initValue>
								</var>
								<var name="F" type="REAL">
									<descr>Fahrenheit</descr>
									<initValue>-459.67</initValue>
								</var>
								<var name="Re" type="REAL">
									<descr>Reaumur</descr>
									<initValue>-218.52</initValue>
								</var>
								<var name="Ra" type="REAL">
									<descr>Rankine</descr>
								</var>
							</inputVars>
							<outputVars>
								<var name="YK" type="REAL">
									<descr>Kelvin</descr>
								</var>
								<var name="YC" type="REAL">
									<descr>Celsius</descr>
								</var>
								<var name="YF" type="REAL">
									<descr>Fahrenheit</descr>
								</var>
								<var name="YRe" type="REAL">
									<descr>Reaumur</descr>
								</var>
								<var name="YRa" type="REAL">
									<descr>Rankine</descr>
								</var>
							</outputVars>
						</vars>
						<iecDeclaration active="FALSE"/>
						<interfaces/>
						<methods/>
						<sourceCode type="ST">
							<![CDATA[
(*

version 1.0	21 feb 2008
programmer 	hugo
tested by	oscat

This function converts different temperature units.
Any unused input can simply be left open.
Different inputs connected at the same time will be summed up.

*)


YK := K + (C + 273.15) + (F + 459.67) * 0.555555555555 + (Re * 1.25 + 273.15) + (Ra * 0.555555555555);
YC := YK -273.15;
YF := YK * 1.8 - 459.67;
YRe := (YK - 273.15) * 0.8;
YRa := YK * 1.8;


(* revision history
hm	21. feb. 2008	rev 1.0
	original version
*)
]]>
						</sourceCode>
					</functionBlock>
				</functionBlocks>
				<programs/>
				<macros/>
				<structs/>
				<typedefs/>
				<enums/>
				<subranges/>
				<interfaces/>
			</lib>
		</libraries>
		<aux>
			<src fullXml="false" name="Global shared.plc" order="0" hidden="false">
				<![CDATA[(* Automatically generated by LogicLab, do not edit! *)
]]>
			</src>
			<src fullXml="false" name="ParDB.plc" order="1" hidden="false">
				<![CDATA[(* Automatically generated, do not edit! *)

PROGRAM InitParDB WITH Init;

PROGRAM InitParDB
	{ HIDDEN:ON }
	{ CODE:ST }
	VAR
		warningsKiller: USINT;
		dummyCrc32: UDINT;
	END_VAR

	dummyCrc32 := 0;

	warningsKiller := sysDBase_SetExtTable( TO_DWORD( 0 ), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

END_PROGRAM

]]>
			</src>
			<src fullXml="false" name="IO.plc" order="0" hidden="false">
				<![CDATA[(* Automatically generated, do not edit! *)

PROGRAM $$IOConfig WITH Init;

PROGRAM $$IOConfig
	{ HIDDEN:ON }
VAR
	warningsKiller: BOOL;
END_VAR
	{ CODE:ST }

	/* ------	GLOBAL CONFIGURATION OF PROGRAMMABLE INPUTS	--------	*/
	warningsKiller := sysCfgAnalogRes(16);

	/* ------	CONFIGURATION OF EACH PROGRAMMABLE INPUTS	--------	*/
	warningsKiller := sysCfgProgInput(0, 0);
	warningsKiller := sysCfgProgInput(1, 0);
	warningsKiller := sysCfgProgInput(2, 0);
	warningsKiller := sysCfgProgInput(3, 0);
	warningsKiller := sysCfgProgInput(4, 0);
	warningsKiller := sysCfgProgInput(5, 0);
	warningsKiller := sysCfgProgInput(6, 0);
	warningsKiller := sysCfgProgInput(7, 0);

END_PROGRAM

]]>
			</src>
			<src fullXml="false" name="SharedVars.plc" order="0" hidden="false">
				<![CDATA[VAR_GLOBAL
{ G: "INPUTS" }
TimeStamp AT %IB4.0 : UDINT;
{ G: "INPUTS" }
TimeSetOk AT %IB4.4 : BOOL;
{ G: "INPUTS" }
NtpSetOk AT %IB4.5 : BOOL;
{ G: "INPUTS" }
NtpSetKo AT %IB4.6 : BOOL;
{ G: "OUTPUTS" }
TimeToSet AT %QB4.0 : UDINT;
{ G: "OUTPUTS" }
Set_Time AT %QB4.4 : BOOL;
{ G: "OUTPUTS" }
NTP_Set AT %QB4.5 : BOOL;
END_VAR

]]>
			</src>
		</aux>
		<workspace>
			<root name="DataLogger" nextID="1131">
				<GlobalVars name="Global_vars" id="2"/>
				<GlobalVars name="I_O_mappings_LEDOut" id="9"/>
				<Pou name="Inizilaizzazione" id="18"/>
				<GlobalVars name="Ungrouped_vars" id="38"/>
				<folder name="Lib_DateTime" id="937">
					<Pou name="Curr_Date_Time" id="574"/>
					<Pou name="Data_ora" id="265"/>
					<Definition name="Set_Data_Ora" id="116"/>
					<Pou name="DST" id="465"/>
					<Pou name="Set_Data_Time" id="232"/>
					<Pou name="WeekDay" id="702"/>
					<Pou name="YEAR_OF_DT" id="480"/>
				</folder>
				<GlobalVars name="I_O_mappings_ButInp" id="1031"/>
			</root>
		</workspace>
	</sources>
	<codegen crossReference="false" crossReferenceOptions="0x3000001D" listing="true" unusedObjs="false" saveEXPFile="false" saveEXPFileLibraries="false" saveTargetFiles="true" warningEnable="true" symMap="true" checkIndexType="false" waitExtension="false" allocateUnusedVariables="false" checkArrayBounds="false" checkDivisionByZero="false" checkPointers="0" checkReferences="false" checkInterfaces="false" ioVarsAsReferences="false" customTargetBINFileName="PlcCode0.bin" customTargetTSCFileName="PlcSource0.bin" customTargetTDSFileName="PlcDebug0.bin" generateCustomFilesName="true" initFunVarsWithZero="false" enablePreprocessDirectives="false">
		<disabledWarnings/>
		<applicationDataBlocks/>
	</codegen>
	<debug watchRefresh="20" watchVarRefresh="0" watchMaxArray="20" autoSaveWatchList="false" watchFBLocalVars="false"/>
	<editor useOldGridSize="false"/>
	<userDef>
		<release/>
		<author/>
		<note/>
		<version/>
		<password disabled="false"/>
	</userDef>
	<downloadSequence sourceCode="never" debugSymbols="never"/>
	<commands>
		<postbuild/>
		<postdown/>
		<predown/>
	</commands>
	<resources>
		<configuration template="LogicLab.pct" version="1">
			<data protocol="root">
				<project_config nextID="2">
					<datacomment/>
				</project_config>
				<ArduinoOpta_1p2 template="ArduinoOpta_1p2\ArduinoOpta\ArduinoOpta.pct" version="7" name="Opta" caption="Opta">
					<config>
						<params/>
						<paramsRO/>
						<menus/>
						<ioMappings_ProgInp resolution="16">
							<ioMapping id="0" IOType="0">
								<label/>
							</ioMapping>
							<ioMapping id="1" IOType="0">
								<label/>
							</ioMapping>
							<ioMapping id="2" IOType="0">
								<label/>
							</ioMapping>
							<ioMapping id="3" IOType="0">
								<label/>
							</ioMapping>
							<ioMapping id="4" IOType="0">
								<label/>
							</ioMapping>
							<ioMapping id="5" IOType="0">
								<label/>
							</ioMapping>
							<ioMapping id="6" IOType="0">
								<label/>
							</ioMapping>
							<ioMapping id="7" IOType="0">
								<label/>
							</ioMapping>
						</ioMappings_ProgInp>
						<ioMappings_RelayOut>
							<ioMapping id="0">
								<label/>
							</ioMapping>
							<ioMapping id="1">
								<label/>
							</ioMapping>
							<ioMapping id="2">
								<label/>
							</ioMapping>
							<ioMapping id="3">
								<label/>
							</ioMapping>
						</ioMappings_RelayOut>
						<ioMappings_LEDOut>
							<ioMapping id="0">
								<label>Led1</label>
							</ioMapping>
							<ioMapping id="1">
								<label>Led2</label>
							</ioMapping>
							<ioMapping id="2">
								<label>Led3</label>
							</ioMapping>
							<ioMapping id="3">
								<label>Led4</label>
							</ioMapping>
							<ioMapping id="4">
								<label/>
							</ioMapping>
							<ioMapping id="5">
								<label>GreenLed</label>
							</ioMapping>
							<ioMapping id="6">
								<label/>
							</ioMapping>
						</ioMappings_LEDOut>
						<ioMappings_ButInp>
							<ioMapping id="0">
								<label/>
							</ioMapping>
						</ioMappings_ButInp>
						<sharedInputs>
							<sharedIO label="TimeStamp" type="UDINT" size=""/>
							<sharedIO label="TimeSetOk" type="BOOL" size=""/>
							<sharedIO label="NtpSetOk" type="BOOL" size=""/>
							<sharedIO label="NtpSetKo" type="BOOL" size=""/>
						</sharedInputs>
						<sharedOutputs>
							<sharedIO label="TimeToSet" type="UDINT" size=""/>
							<sharedIO label="Set_Time" type="BOOL" size=""/>
							<sharedIO label="NTP_Set" type="BOOL" size=""/>
						</sharedOutputs>
					</config>
					<RS485 protocol="" mode="0" baudRate="38400" serialMode="none,8,1" slaveAddress="1" COMnumber="2" rsmode="1" netId="0" maxSlaves="32" serCfg="1"/>
					<CANopen id="0" protocol="" mode="0" nodeID="127" baudRate="250000" hbTime="0" syncCOBID="128" syncCycle="0" networkID="0" slaveNodeID="1" slaveDeviceType="301" slaveSyncCOBID="128" slaveSyncCycle="0" slaveManufacturerDeviceName="" slaveManufacturerHardwareVer="" slaveManufacturerSoftwareVer="" slaveGuardTime="200" slaveLifeTimeFactor="3" slaveConsumerHeartbeatTime="0" slaveProducerHeartbeatTime="0" slaveVendorID="0" slaveProductCode="0" slaveRevisionNumber="0" slaveSerialNumber="0" slaveCfgGranularity="8" slaveCfgCOBIDAutoAssignment="1" slaveCfgMaxTPDONum="8" slaveCfgMaxRPDONum="8"/>
					<Ethernet protocol="" enableMaster="0" enableSlave="1" enableSlaveRtuGateway="0" rtuGatewayDefaultTimeout="100" slavePort="502"/>
					<SketchContent>// shared variables can be accessed with PLCIn.varname and PLCOut.varname
#include &lt;NTPClient.h&gt;
#include &lt;EthernetUdp.h&gt;
#include &lt;Arduino_UnifiedStorage.h&gt;

EthernetUDP ntpUDP;
// Set NTP  IP adress
IPAddress ip_npt (192, 168, 1, 225);
// Set NTP  on UTC
NTPClient timeClient(ntpUDP, ip_npt, -6*0, 0);
unsigned long last_timestamp = 1;
unsigned long  timestamp = 0;


// Timing control variables
unsigned long previousMillis = 0;
const long interval = 1000;


// USB storage and folder instances
USBStorage usbStorage;
Folder backupFolder = Folder();
bool usbIntialized = false;
volatile bool usbAvailable = false;


void connectionCallback() {
    usbAvailable = true;
    Arduino_UnifiedStorage::debugPrint("- USB device connected!");
    usbStorage.removeOnConnectCallback();
}

/**
  Function to handle USB disconnection callback.
  Resets the USB available flag and reinstalls the connection callback.

  @param none
  @return none
*/
void disconnectionCallback() {
    usbAvailable = false;
    Arduino_UnifiedStorage::debugPrint("- USB device disconnected!");
    usbStorage.onConnect(connectionCallback);
}


void writeToUSB() {
  if (usbAvailable &amp;&amp; !usbIntialized) {
    usbStorage.begin();
    Folder usbRoot = usbStorage.getRootFolder();
    String folderName = "backup_data";
    backupFolder = usbRoot.createSubfolder(folderName);
    Arduino_UnifiedStorage::debugPrint("- Backup folder created: " + backupFolder.getPathAsString());
    usbStorage.unmount();
    usbIntialized = true;
  } else if (usbAvailable &amp;&amp; usbIntialized) {
    if (!usbStorage.isMounted()) {
      if (usbStorage.begin()) {
        performUpdate();
      }
    } else if (usbStorage.isMounted()) {
      performUpdate();
    }
  }
}

/**
  Function to perform data update on USB storage.
  Writes analog sensor data in a formatted string to a text file.

  @param none
  @return none
*/
void performUpdate() {
  UFile backupFile = backupFolder.createFile("analog_inputs_data.txt", FileMode::APPEND);
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis &gt;= interval) 
  {
    previousMillis = currentMillis;

    String buffer = "PIPPO";
    buffer += "\n";
    backupFile.write(buffer);
    Arduino_UnifiedStorage::debugPrint("- Data written to file: " + buffer);
  }
  
  backupFile.close();
  usbStorage.unmount();
  Arduino_UnifiedStorage::debugPrint("- File closed and USB storage unmounted!");
}



void setup()
{
    
	// Configure static IP address
	IPAddress ip(192, 168, 1, 12);
	IPAddress dns(8, 8, 8, 8);
	IPAddress gateway(192, 168, 1, 1);
	IPAddress subnet(255, 255, 255, 0);
	// If cable is not connected this will block the start of PLC with about 60s of timeout!
	Ethernet.begin(ip, dns, gateway, subnet);
	timeClient.begin();
    
   
}

void loop()
{
  // set time manualy
  if(PLCOut.Set_Time)
  {
      set_time(PLCOut.TimeToSet);
      PLCIn.TimeSetOk = true;
      
  }
  else
  {
     PLCIn.TimeSetOk = false; 
  }
  
  //  read rtc
   time_t t = time(NULL);
   timestamp = (unsigned long) t;
  
  // sent time to plc
  if (timestamp != last_timestamp)
  {
      PLCIn.TimeStamp = t;
      last_timestamp = timestamp;
  }
  
  // set time by ntp
  if (PLCOut.NTP_Set)
  {
      updateTime();
  }
  else
  {
      PLCIn.NtpSetOk = false;
      PLCIn.NtpSetKo = false;
  }
  
}



void updateTime() 
{
  timeClient.update();
   if(timeClient.isTimeSet())
      {
          const unsigned long epoch = timeClient.getEpochTime();
          set_time(epoch);
          PLCIn.NtpSetOk = true;
      }
      else
      {
          PLCIn.NtpSetKo = true;
      }
}</SketchContent>
					<SketchLibraries>
						<SketchLibrary name="NTPClient" ver="3.2.1"/>
						<SketchLibrary name="Arduino_UnifiedStorage" ver="1.1.0"/>
						<SketchLibrary name="Arduino_POSIXStorage" ver="1.2.1"/>
						<SketchLibrary name="Arduino_USBHostMbed5" ver="0.3.1"/>
					</SketchLibraries>
					<IOExpansions/>
				</ArduinoOpta_1p2>
			</data>
		</configuration>
	</resources>
</plcProject>